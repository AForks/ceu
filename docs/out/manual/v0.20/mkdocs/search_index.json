{
    "docs": [
        {
            "location": "/", 
            "text": "C\u00e9u v0.20 - Reference Manual", 
            "title": "C\u00e9u v0.20 - Reference Manual"
        }, 
        {
            "location": "/overview/", 
            "text": "Introduction\n\n\nC\u00e9u provides \nStructured Synchronous Reactive Programming\n, extending classical\nstructured programming with two main functionalities:\n\n\n\n\nEvent Handling:\n\n\nAn \nawait\n statement to suspend a line of execution and wait for an input\n  event from the environment.\n\n\nAn \nemit\n statement to signal an output event back to the environment.\n\n\n\n\n\n\nConcurrency:\n\n\nA set of parallel constructs to compose concurrent lines of execution.\n\n\n\n\n\n\n\n\nThe lines of execution in C\u00e9u, known as \ntrails\n, react all together to input\nevents one after another, in discrete steps.\nAn input event is broadcast to all active trails, which share the event as\ntheir unique and global time reference.\n\n\nThe program that follows blinks a LED every second and terminates on a button\npress:\n\n\ninput  void BUTTON;\noutput bool LED;\npar/or do\n    await BUTTON;\nwith\n    loop do\n        await 1s;\n        emit LED(true);\n        await 1s;\n        emit LED(false);\n    end\nend\n\n\n\n\nThe synchronous concurrency model of C\u00e9u greatly diverges from multithreaded\nand actor-based models (e.g. \npthreads\n and \nerlang\n).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, accesses to shared variables among trails are deterministic\nand do not require synchronization primitives (i.e., \nlocks\n or\n\nqueues\n).\n\n\nC\u00e9u provides static memory management based on lexical scopes and does not\nrequire a garbage collector.\n\n\nC\u00e9u integrates safely with C, particularly when manipulating external resources\n(e.g., file handles).\nPrograms can make native calls seamlessly while avoiding common pitfalls such\nas memory leaks and dangling pointers.\n\n\nC\u00e9u is \nfree software\n.", 
            "title": "Introduction"
        }, 
        {
            "location": "/overview/#introduction", 
            "text": "C\u00e9u provides  Structured Synchronous Reactive Programming , extending classical\nstructured programming with two main functionalities:   Event Handling:  An  await  statement to suspend a line of execution and wait for an input\n  event from the environment.  An  emit  statement to signal an output event back to the environment.    Concurrency:  A set of parallel constructs to compose concurrent lines of execution.     The lines of execution in C\u00e9u, known as  trails , react all together to input\nevents one after another, in discrete steps.\nAn input event is broadcast to all active trails, which share the event as\ntheir unique and global time reference.  The program that follows blinks a LED every second and terminates on a button\npress:  input  void BUTTON;\noutput bool LED;\npar/or do\n    await BUTTON;\nwith\n    loop do\n        await 1s;\n        emit LED(true);\n        await 1s;\n        emit LED(false);\n    end\nend  The synchronous concurrency model of C\u00e9u greatly diverges from multithreaded\nand actor-based models (e.g.  pthreads  and  erlang ).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, accesses to shared variables among trails are deterministic\nand do not require synchronization primitives (i.e.,  locks  or queues ).  C\u00e9u provides static memory management based on lexical scopes and does not\nrequire a garbage collector.  C\u00e9u integrates safely with C, particularly when manipulating external resources\n(e.g., file handles).\nPrograms can make native calls seamlessly while avoiding common pitfalls such\nas memory leaks and dangling pointers.  C\u00e9u is  free software .", 
            "title": "Introduction"
        }, 
        {
            "location": "/overview/environments/", 
            "text": "Environments\n\n\nAs a reactive language, C\u00e9u depends on an external host platform, known as an\n\nenvironment\n, which exposes \ninput\n and \noutput\n events programs can use.\n\n\nAn environment senses the world and broadcasts \ninput\n events to programs.\nIt also intercepts programs signalling \noutput\n events to actuate in the\nworld:\n\n\n\n\nAs examples of typical environments, an embedded system may provide button\ninput and LED output, and a video game engine may provide keyboard input and\nvideo output.", 
            "title": "Environments"
        }, 
        {
            "location": "/overview/environments/#environments", 
            "text": "As a reactive language, C\u00e9u depends on an external host platform, known as an environment , which exposes  input  and  output  events programs can use.  An environment senses the world and broadcasts  input  events to programs.\nIt also intercepts programs signalling  output  events to actuate in the\nworld:   As examples of typical environments, an embedded system may provide button\ninput and LED output, and a video game engine may provide keyboard input and\nvideo output.", 
            "title": "Environments"
        }, 
        {
            "location": "/overview/synchronous_execution_model/", 
            "text": "Synchronous Execution Model\n\n\nC\u00e9u is grounded on a precise definition of \nlogical time\n (as opposed to\n\nphysical\n) as a discrete sequence of input events:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see \nBounded Execution\n).\n\n\nThe execution model for C\u00e9u programs is as follows:\n\n\n\n\nThe program initiates the \nboot reaction\n from the first line of code in a\n   single trail.\n\n\nActive trails, one after another, execute until they await or terminate.\n   This step is named a \nreaction chain\n, and always runs in bounded time.\n   New trails can be created with \nparallel compositions\n.\n\n\nThe program goes idle.\n\n\nOn the occurrence of a new input event, \nall\n trails awaiting that event\n   awake.\n   It then goes to step 2.\n\n\n\n\nThe synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run \ninfinitely faster\n in comparison to the rate of input events.\nA reaction chain, aka. \nexternal reaction\n, is the set of computations that\nexecute when an input event occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is arbitrary, but provides a priority scheme for trails, and also\nensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.\n\n\nThe program and diagram below illustrate the behavior of the scheduler of C\u00e9u:\n\n\n 1:  input void A, B, C;  // A, B, and C are input events\n 2:  par/and do\n 3:      // trail 1\n 4:      \n...\n            // \n...\n represents non-awaiting statements\n 5:      await A;\n 6:      \n...\n\n 7:  with\n 8:      // trail 2\n 9:      \n...\n\n10:      await B;\n11:      \n...\n\n12:  with\n13:      // trail 3\n14:      \n...\n\n15:      await A;\n16:      \n...\n\n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:          \n...\n\n21:      with\n22:          // trail 4\n23:          \n...\n\n24:      end\n25:  end\n\n\n\n\n\n\nThe program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows (\nt0\n in the diagram):\n\n\n\n\ntrail-1\n executes up to the \nawait A\n (line 5);\n\n\ntrail-2\n executes up to the \nawait B\n (line 10);\n\n\ntrail-3\n executes up to the \nawait A\n (line 15).\n\n\n\n\nAs no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event \nA\n occurs (\nt1\n in the diagram):\n\n\n\n\ntrail-1\n awakes, executes and terminates (line 6);\n\n\ntrail-2\n remains suspended, as it is not awaiting \nA\n.\n\n\ntrail-3\n executes up to \nawait B\n (line 17).\n\n\n\n\nDuring the reaction \nt1\n, new instances of events \nA\n, \nB\n, and \nC\n occur and\nare enqueued to be handled in the reactions in sequence.\nAs \nA\n happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n(\nt2\n in the diagram).\nThe next reaction dequeues the event \nB\n (\nt3\n in the diagram):\n\n\n\n\ntrail-2\n awakes, executes and terminates;\n\n\ntrail-3\n splits in two and they both terminate immediately.\n\n\n\n\nSince a \npar/and\n rejoins after all trails terminate, the program also\nterminates and does not react to the pending event \nC\n.\n\n\nNote that each step in the logical time line (\nt0\n, \nt1\n, etc.) is identified \nby the unique occurring event.\nInside a reaction, trails only react to the same shared global event (or remain \nsuspended).", 
            "title": "Synchronous Execution Model"
        }, 
        {
            "location": "/overview/synchronous_execution_model/#synchronous-execution-model", 
            "text": "C\u00e9u is grounded on a precise definition of  logical time  (as opposed to physical ) as a discrete sequence of input events:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see  Bounded Execution ).  The execution model for C\u00e9u programs is as follows:   The program initiates the  boot reaction  from the first line of code in a\n   single trail.  Active trails, one after another, execute until they await or terminate.\n   This step is named a  reaction chain , and always runs in bounded time.\n   New trails can be created with  parallel compositions .  The program goes idle.  On the occurrence of a new input event,  all  trails awaiting that event\n   awake.\n   It then goes to step 2.   The synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run  infinitely faster  in comparison to the rate of input events.\nA reaction chain, aka.  external reaction , is the set of computations that\nexecute when an input event occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is arbitrary, but provides a priority scheme for trails, and also\nensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.  The program and diagram below illustrate the behavior of the scheduler of C\u00e9u:   1:  input void A, B, C;  // A, B, and C are input events\n 2:  par/and do\n 3:      // trail 1\n 4:       ...             //  ...  represents non-awaiting statements\n 5:      await A;\n 6:       ... \n 7:  with\n 8:      // trail 2\n 9:       ... \n10:      await B;\n11:       ... \n12:  with\n13:      // trail 3\n14:       ... \n15:      await A;\n16:       ... \n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:           ... \n21:      with\n22:          // trail 4\n23:           ... \n24:      end\n25:  end   The program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows ( t0  in the diagram):   trail-1  executes up to the  await A  (line 5);  trail-2  executes up to the  await B  (line 10);  trail-3  executes up to the  await A  (line 15).   As no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event  A  occurs ( t1  in the diagram):   trail-1  awakes, executes and terminates (line 6);  trail-2  remains suspended, as it is not awaiting  A .  trail-3  executes up to  await B  (line 17).   During the reaction  t1 , new instances of events  A ,  B , and  C  occur and\nare enqueued to be handled in the reactions in sequence.\nAs  A  happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n( t2  in the diagram).\nThe next reaction dequeues the event  B  ( t3  in the diagram):   trail-2  awakes, executes and terminates;  trail-3  splits in two and they both terminate immediately.   Since a  par/and  rejoins after all trails terminate, the program also\nterminates and does not react to the pending event  C .  Note that each step in the logical time line ( t0 ,  t1 , etc.) is identified \nby the unique occurring event.\nInside a reaction, trails only react to the same shared global event (or remain \nsuspended).", 
            "title": "Synchronous Execution Model"
        }, 
        {
            "location": "/overview/parallel_compositions_and_abortion/", 
            "text": "Parallel Compositions and Abortion\n\n\nThe use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:\n\n\n\n\na \npar/and\n rejoins after all trails in parallel terminate;\n\n\na \npar/or\n rejoins after any trail in parallel terminates, aborting all\n   other trails automatically;\n\n\na \npar\n never rejoins, even if all trails terminate.\n\n\n\n\nAs mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions support \nawaiting in parallel\n, rather than\n\nexecuting in parallel\n.", 
            "title": "Parallel Compositions and Abortion"
        }, 
        {
            "location": "/overview/parallel_compositions_and_abortion/#parallel-compositions-and-abortion", 
            "text": "The use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:   a  par/and  rejoins after all trails in parallel terminate;  a  par/or  rejoins after any trail in parallel terminates, aborting all\n   other trails automatically;  a  par  never rejoins, even if all trails terminate.   As mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions support  awaiting in parallel , rather than executing in parallel .", 
            "title": "Parallel Compositions and Abortion"
        }, 
        {
            "location": "/overview/bounded_execution/", 
            "text": "Bounded Execution\n\n\nReaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle incoming input events.\nFor this reason, C\u00e9u requires every path inside the body of a \nloop\n statement\nto contain at least one \nawait\n or \nbreak\n statement.\nThis prevents \ntight loops\n, i.e., unbounded loops that do not await.\n\n\nIn the example below, the true branch of the \nif\n may never execute, resulting\nin a tight loop when the condition is false:\n\n\nloop do\n    if \ncond\n then\n        break;\n    end\nend\n\n\n\n\nC\u00e9u warns about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides \nAsynchronous \nExecution\n.", 
            "title": "Bounded Execution"
        }, 
        {
            "location": "/overview/bounded_execution/#bounded-execution", 
            "text": "Reaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle incoming input events.\nFor this reason, C\u00e9u requires every path inside the body of a  loop  statement\nto contain at least one  await  or  break  statement.\nThis prevents  tight loops , i.e., unbounded loops that do not await.  In the example below, the true branch of the  if  may never execute, resulting\nin a tight loop when the condition is false:  loop do\n    if  cond  then\n        break;\n    end\nend  C\u00e9u warns about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides  Asynchronous \nExecution .", 
            "title": "Bounded Execution"
        }, 
        {
            "location": "/overview/deterministic_execution/", 
            "text": "Deterministic Execution\n\n\nTODO (shared memory + deterministic scheduler + optional static analysis)", 
            "title": "Deterministic Execution"
        }, 
        {
            "location": "/overview/deterministic_execution/#deterministic-execution", 
            "text": "TODO (shared memory + deterministic scheduler + optional static analysis)", 
            "title": "Deterministic Execution"
        }, 
        {
            "location": "/overview/internal_reactions/", 
            "text": "Internal Reactions\n\n\nC\u00e9u supports inter-trail communication through \nawait\n and \nemit\n statements\nfor \ninternal events\n.\nA trail can \nawait\n an internal event to suspend it.\nThen, another trail can \nemit\n and broadcast an event, awaking all trails\nawaiting that event.\n\n\nUnlike input events, multiple internal events can coexist during an external\nreaction.\nAn \nemit\n starts a new \ninternal reaction\n in the program which relies on a\nruntime stack:\n\n\n\n\nThe \nemit\n suspends the current trail and its continuation is pushed into\n    the stack (i.e., the statement in sequence with the \nemit\n).\n\n\nAll trails awaiting the emitted event awake and execute in sequence\n    (see \nrule 2\n for external reactions).\n    If an awaking trail emits another internal event, a nested internal\n    reaction starts with \nrule 1\n.\n\n\nThe top of stack is popped and the last emitting trail resumes execution\n    from its continuation.\n\n\n\n\nExample:\n\n\n1:  par/and do      // trail 1\n2:      await e;\n3:      emit f;\n4:  with            // trail 2\n5:      await f;\n6:  with            // trail 3\n8:      emit e;\n9:  end\n\n\n\n\nThe \nemit e\n in \ntrail-3\n (line 7) starts an internal reaction that awakes the \n\nawait e\n in \ntrail-1\n (line 2).\nThen, the \nemit f\n (line 3) starts another internal reaction that awakes the \n\nawait f\n in \ntrail-2\n (line 5).\n\nTrail-2\n terminates and the \nemit f\n resumes in \ntrail-1\n.\n\nTrail-1\n terminates and the \nemit e\n resumes in \ntrail-3\n.\n\nTrail-3\n terminates.\nFinally, the \npar/and\n rejoins and the program terminates.", 
            "title": "Internal Reactions"
        }, 
        {
            "location": "/overview/internal_reactions/#internal-reactions", 
            "text": "C\u00e9u supports inter-trail communication through  await  and  emit  statements\nfor  internal events .\nA trail can  await  an internal event to suspend it.\nThen, another trail can  emit  and broadcast an event, awaking all trails\nawaiting that event.  Unlike input events, multiple internal events can coexist during an external\nreaction.\nAn  emit  starts a new  internal reaction  in the program which relies on a\nruntime stack:   The  emit  suspends the current trail and its continuation is pushed into\n    the stack (i.e., the statement in sequence with the  emit ).  All trails awaiting the emitted event awake and execute in sequence\n    (see  rule 2  for external reactions).\n    If an awaking trail emits another internal event, a nested internal\n    reaction starts with  rule 1 .  The top of stack is popped and the last emitting trail resumes execution\n    from its continuation.   Example:  1:  par/and do      // trail 1\n2:      await e;\n3:      emit f;\n4:  with            // trail 2\n5:      await f;\n6:  with            // trail 3\n8:      emit e;\n9:  end  The  emit e  in  trail-3  (line 7) starts an internal reaction that awakes the  await e  in  trail-1  (line 2).\nThen, the  emit f  (line 3) starts another internal reaction that awakes the  await f  in  trail-2  (line 5). Trail-2  terminates and the  emit f  resumes in  trail-1 . Trail-1  terminates and the  emit e  resumes in  trail-3 . Trail-3  terminates.\nFinally, the  par/and  rejoins and the program terminates.", 
            "title": "Internal Reactions"
        }, 
        {
            "location": "/lexical_rules/keywords/", 
            "text": "Keywords\n\n\nKeywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):\n\n\n    and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    lock            loop            lua             native          new\n\n    nohold          not             nothing         null            or\n\n    outer           output          par             pause           plain\n\n    pool            pos             pre             pure            recursive\n\n    request         resume          sizeof          spawn           static\n\n    then            thread          tight           traverse        true\n\n    until           val             var             vector          watching\n\n    with            bool            byte            f32             f64\n\n    float           int             s16             s32             s64\n\n    s8              ssize           u16             u32             u64\n\n    u8              uint            usize           void", 
            "title": "Keywords"
        }, 
        {
            "location": "/lexical_rules/keywords/#keywords", 
            "text": "Keywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):      and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    lock            loop            lua             native          new\n\n    nohold          not             nothing         null            or\n\n    outer           output          par             pause           plain\n\n    pool            pos             pre             pure            recursive\n\n    request         resume          sizeof          spawn           static\n\n    then            thread          tight           traverse        true\n\n    until           val             var             vector          watching\n\n    with            bool            byte            f32             f64\n\n    float           int             s16             s32             s64\n\n    s8              ssize           u16             u32             u64\n\n    u8              uint            usize           void", 
            "title": "Keywords"
        }, 
        {
            "location": "/lexical_rules/identifiers/", 
            "text": "Identifiers\n\n\nC\u00e9u uses identifiers to refer to \ntypes\n (\nID_type\n), \nvariables\n (\nID_int\n),\n\nvectors\n (\nID_int\n), \npools\n (\nID_int\n), \ninternal events\n (\nID_int\n),\n\nexternal events\n (\nID_ext\n), \ncode abstractions\n (\nID_abs\n),\n\ndata abstractions\n (\nID_abs\n), \nfields\n (\nID_field\n),\n\nnative symbols\n (\nID_nat\n), and \nblock labels\n (\nID_int\n).\n\n\nID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\n\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n\n\n\nDeclarations for \ncode\n and \ndata\n create new \ntypes\n which can\nbe used as type identifiers.\n\n\nExamples:\n\n\nvar int a;                    // \na\n is a variable, \nint\n is a type\nemit e;                       // \ne\n is an internal event\nawait E;                      // \nE\n is an external input event\nspawn Move();                 // \nMove\n is a code abstraction and a type\nvar Rect r;                   // \nRect\n is a data abstraction and a type\nreturn r.width;               // \nwidth\n is a field\n_printf(\nhello world!\\n\n);    // \n_printf\n is a native symbol", 
            "title": "Identifiers"
        }, 
        {
            "location": "/lexical_rules/identifiers/#identifiers", 
            "text": "C\u00e9u uses identifiers to refer to  types  ( ID_type ),  variables  ( ID_int ), vectors  ( ID_int ),  pools  ( ID_int ),  internal events  ( ID_int ), external events  ( ID_ext ),  code abstractions  ( ID_abs ), data abstractions  ( ID_abs ),  fields  ( ID_field ), native symbols  ( ID_nat ), and  block labels  ( ID_int ).  ID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\n\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )  Declarations for  code  and  data  create new  types  which can\nbe used as type identifiers.  Examples:  var int a;                    //  a  is a variable,  int  is a type\nemit e;                       //  e  is an internal event\nawait E;                      //  E  is an external input event\nspawn Move();                 //  Move  is a code abstraction and a type\nvar Rect r;                   //  Rect  is a data abstraction and a type\nreturn r.width;               //  width  is a field\n_printf( hello world!\\n );    //  _printf  is a native symbol", 
            "title": "Identifiers"
        }, 
        {
            "location": "/lexical_rules/literals/", 
            "text": "Literals\n\n\nC\u00e9u supports literals for \nbooleans\n, \nintegers\n, \nfloats\n, \nstrings\n, and\n\nnull pointers\n.\n\n\n\n\n\nBooleans\n\n\nThe boolean type has only two possible values: \ntrue\n and \nfalse\n.\n\n\nIntegers\n\n\nC\u00e9u supports decimal and hexadecimal integers:\n\n\n\n\nDecimals: a sequence of digits (i.e., \n[0-9]+\n).\n\n\nHexadecimals: a sequence of hexadecimal digits (i.e., \n[0-9, a-f, A-F]+\n)\n                prefixed by \n0x\n.\n\n\n\n\n\n\n\nExamples:\n\n\n// both are equal to the decimal 127\nv = 127;    // decimal\nv = 0x7F;   // hexadecimal\n\n\n\n\nFloats\n\n\nTODO (like C)\n\n\nStrings\n\n\nA sequence of characters surrounded by \n\"\n is converted into a \nnull-terminated \nstring\n, just like in C:\n\n\nExample:\n\n\n_printf(\nHello World!\\n\n);\n\n\n\n\nNull pointer\n\n\nThe \nnull\n literal represents \nnull pointers\n.", 
            "title": "Literals"
        }, 
        {
            "location": "/lexical_rules/literals/#literals", 
            "text": "C\u00e9u supports literals for  booleans ,  integers ,  floats ,  strings , and null pointers .", 
            "title": "Literals"
        }, 
        {
            "location": "/lexical_rules/literals/#booleans", 
            "text": "The boolean type has only two possible values:  true  and  false .", 
            "title": "Booleans"
        }, 
        {
            "location": "/lexical_rules/literals/#integers", 
            "text": "C\u00e9u supports decimal and hexadecimal integers:   Decimals: a sequence of digits (i.e.,  [0-9]+ ).  Hexadecimals: a sequence of hexadecimal digits (i.e.,  [0-9, a-f, A-F]+ )\n                prefixed by  0x .    Examples:  // both are equal to the decimal 127\nv = 127;    // decimal\nv = 0x7F;   // hexadecimal", 
            "title": "Integers"
        }, 
        {
            "location": "/lexical_rules/literals/#floats", 
            "text": "TODO (like C)", 
            "title": "Floats"
        }, 
        {
            "location": "/lexical_rules/literals/#strings", 
            "text": "A sequence of characters surrounded by  \"  is converted into a  null-terminated \nstring , just like in C:  Example:  _printf( Hello World!\\n );", 
            "title": "Strings"
        }, 
        {
            "location": "/lexical_rules/literals/#null-pointer", 
            "text": "The  null  literal represents  null pointers .", 
            "title": "Null pointer"
        }, 
        {
            "location": "/lexical_rules/comments/", 
            "text": "Comments\n\n\nC\u00e9u provides C-style comments:\n\n\n\n\nSingle-line comments begin with \n//\n and run to end of the line.\n\n\nMulti-line comments use \n/*\n and \n*/\n as delimiters.\n  Multi-line comments can be nested by using a different number of \n*\n as\n  delimiters.\n\n\n\n\nExamples:\n\n\nvar int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Comments"
        }, 
        {
            "location": "/lexical_rules/comments/#comments", 
            "text": "C\u00e9u provides C-style comments:   Single-line comments begin with  //  and run to end of the line.  Multi-line comments use  /*  and  */  as delimiters.\n  Multi-line comments can be nested by using a different number of  *  as\n  delimiters.   Examples:  var int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Comments"
        }, 
        {
            "location": "/types/", 
            "text": "Types\n\n\nC\u00e9u is statically typed, requiring all variables, events, and other entities to\nbe declared before they are used in programs.\n\n\nA type is composed of a \ntype identifier\n, followed by an optional\nsequence of \npointer modifiers\n \n, followed by an optional\n\noption modifier\n \n?\n:\n\n\nType ::= ID_type {`\n\u00b4} [`?\u00b4]\n\n\n\n\nExamples:\n\n\nvar   u8     v;    // \nv\n is of 8-bit unsigned integer type\nvar   _rect  r;    // \nr\n is of external native type \nrect\n\nvar   Tree   t;    // \nt\n is a data of type \nTree\n\nvar   int?   ret;  // \nret\n is either unset or is of integer type\ninput byte\n RECV; // \nRECV\n is an input event carrying a pointer to a \nbyte", 
            "title": "Types"
        }, 
        {
            "location": "/types/#types", 
            "text": "C\u00e9u is statically typed, requiring all variables, events, and other entities to\nbe declared before they are used in programs.  A type is composed of a  type identifier , followed by an optional\nsequence of  pointer modifiers   , followed by an optional option modifier   ? :  Type ::= ID_type {` \u00b4} [`?\u00b4]  Examples:  var   u8     v;    //  v  is of 8-bit unsigned integer type\nvar   _rect  r;    //  r  is of external native type  rect \nvar   Tree   t;    //  t  is a data of type  Tree \nvar   int?   ret;  //  ret  is either unset or is of integer type\ninput byte  RECV; //  RECV  is an input event carrying a pointer to a  byte", 
            "title": "Types"
        }, 
        {
            "location": "/types/primitives/", 
            "text": "Primitives\n\n\nC\u00e9u has the following primitive types:\n\n\nvoid               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integers\ns16      u16       // signed and unsigned 16-bit integers\ns32      u32       // signed and unsigned 32-bit integers\ns64      u64       // signed and unsigned 64-bit integers\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types", 
            "title": "Primitives"
        }, 
        {
            "location": "/types/primitives/#primitives", 
            "text": "C\u00e9u has the following primitive types:  void               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integers\ns16      u16       // signed and unsigned 16-bit integers\ns32      u32       // signed and unsigned 32-bit integers\ns64      u64       // signed and unsigned 64-bit integers\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types", 
            "title": "Primitives"
        }, 
        {
            "location": "/types/natives/", 
            "text": "Natives\n\n\nTypes defined externally in C can be prefixed by \n_\n to be used in C\u00e9u programs.\n\n\nExample:\n\n\nvar _message_t msg;      // \nmessage_t\n is a C type defined in an external library\n\n\n\n\nNative types support \nannotations\n to provide additional information to\nthe compiler.", 
            "title": "Natives"
        }, 
        {
            "location": "/types/natives/#natives", 
            "text": "Types defined externally in C can be prefixed by  _  to be used in C\u00e9u programs.  Example:  var _message_t msg;      //  message_t  is a C type defined in an external library  Native types support  annotations  to provide additional information to\nthe compiler.", 
            "title": "Natives"
        }, 
        {
            "location": "/types/abstractions/", 
            "text": "Abstractions\n\n\n\n\n\nSee \nAbstractions\n.", 
            "title": "Abstractions"
        }, 
        {
            "location": "/types/abstractions/#abstractions", 
            "text": "See  Abstractions .", 
            "title": "Abstractions"
        }, 
        {
            "location": "/types/modifiers/", 
            "text": "Modifiers\n\n\nTypes can be suffixed with the pointer modifier \n and the option modifier\n\n?\n.\n\n\nPointer\n\n\nTODO (like in C)\n\n\nTODO cannot cross yielding statements\n\n\nOption\n\n\nTODO (like \"Maybe\")", 
            "title": "Modifiers"
        }, 
        {
            "location": "/types/modifiers/#modifiers", 
            "text": "Types can be suffixed with the pointer modifier   and the option modifier ? .", 
            "title": "Modifiers"
        }, 
        {
            "location": "/types/modifiers/#pointer", 
            "text": "TODO (like in C)  TODO cannot cross yielding statements", 
            "title": "Pointer"
        }, 
        {
            "location": "/types/modifiers/#option", 
            "text": "TODO (like \"Maybe\")", 
            "title": "Option"
        }, 
        {
            "location": "/storage_classes/", 
            "text": "Storage Classes\n\n\nStorage classes represent all entities that are stored in memory during\nexecution.\nC\u00e9u supports \nvariables\n, \nvectors\n, \nevents\n (external and internal), and\n\npools\n as storage classes.\n\n\nAn entity \ndeclaration\n consists of a storage class,\na \ntype\n, and an \nidentifier\n.\n\n\nExamples:\n\n\nvar       int    v;     // \nv\n is a variable of type \nint\n\nvector[9] byte   buf;   // \nbuf\n is a vector with at most 9 values of type \nbyte\n\ninput     void\n A;     // \nA\n is an input event that carries values of type \nvoid\n\nevent     bool   e;     // \ne\n is an internal event that carries values of type \nbool\n\npool[]    Anim   anims; // \nanims\n is a dynamic \npool\n for instances of type \nAnim\n\n\n\n\n\nA declaration binds the identifier with a memory location that holds values of\nthe associated type.", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/storage_classes/#storage-classes", 
            "text": "Storage classes represent all entities that are stored in memory during\nexecution.\nC\u00e9u supports  variables ,  vectors ,  events  (external and internal), and pools  as storage classes.  An entity  declaration  consists of a storage class,\na  type , and an  identifier .  Examples:  var       int    v;     //  v  is a variable of type  int \nvector[9] byte   buf;   //  buf  is a vector with at most 9 values of type  byte \ninput     void  A;     //  A  is an input event that carries values of type  void \nevent     bool   e;     //  e  is an internal event that carries values of type  bool \npool[]    Anim   anims; //  anims  is a dynamic  pool  for instances of type  Anim   A declaration binds the identifier with a memory location that holds values of\nthe associated type.", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/storage_classes/lexical_scope/", 
            "text": "Lexical Scope\n\n\nStorage entities have lexical scope, i.e., they are visible only in the\n\nblock\n in which they are declared.\n\n\nThe lifetime of entities, which is the period between allocation and\ndeallocation in memory, is also limited to the scope of the enclosing block.\nHowever, individual elements inside \nvector\n and \npool\n entities have dynamic\nlifetime, but which never outlive the scope of the declaration.", 
            "title": "Lexical Scope"
        }, 
        {
            "location": "/storage_classes/lexical_scope/#lexical-scope", 
            "text": "Storage entities have lexical scope, i.e., they are visible only in the block  in which they are declared.  The lifetime of entities, which is the period between allocation and\ndeallocation in memory, is also limited to the scope of the enclosing block.\nHowever, individual elements inside  vector  and  pool  entities have dynamic\nlifetime, but which never outlive the scope of the declaration.", 
            "title": "Lexical Scope"
        }, 
        {
            "location": "/storage_classes/classes/", 
            "text": "Classes\n\n\nVariables\n\n\nA variable in C\u00e9u holds a value of a \ndeclared\n \ntype\n that may\nvary during program execution.\nThe value of a variable can be read in \nexpressions\n or written in\n\nassignments\n.\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.\n\n\n\n\n\nExample:\n\n\nvar int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)\n\n\n\n\nVectors\n\n\nA vector In C\u00e9u is a dynamic and contiguous collection of elements of the same\ntype.\n\n\nA vector \ndeclaration\n specifies its type and maximum number of elements\n(possibly unlimited).\nThe current size of a vector is dynamic and can be accessed through the\n\noperator \n$\n.\n\n\nIndividual elements of a vector can be accessed through a\n\nnumeric index\n starting from \n0\n.\nC\u00e9u generates an \nerror\n for out-of-bounds vector accesses.\n\n\nExample:\n\n\nvector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)\n\n\n\n\nEvents\n\n\nEvents account for the reactive nature of C\u00e9u.\nPrograms manipulate events through the \nawait\n and \nemit\n\nstatements.\nAn \nawait\n halts the running trail until the specified event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.\n\n\nUnlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through \nemit\n and \nawait\n statements.\nA \ndeclaration\n includes the type of value the occurring event carries.\n\n\nNote: \nvoid\n is a valid type for signal-only events.\n\n\nExample:\n\n\ninput  void I;           // \nI\n is an input event that carries no values\noutput int  O;           // \nO\n is an output event that carries values of type \nint\n\nevent  int  e;           // \ne\n is an internal event that carries values of type \nint\n\npar/and do\n    await I;             // awakes when \nI\n occurs\n    emit e(10);          // broadcasts \ne\n passing 10, awakes the \nawait\n below\nwith\n    var int v = await e; // awaits \ne\n assigning the received value to \nv\n\n    emit O(v);           // emits \nO\n back to the environment passing \nv\n\nend\n\n\n\n\nAs described in \nInternal Reactions\n, C\u00e9u supports external and internal\nevents with different behavior.\n\n\nExternal Events\n\n\nExternal events are used as interfaces between programs and devices from the \nreal world:\n\n\n\n\ninput events\n represent input devices such as sensor, button, mouse, etc.\n\n\noutput events\n represent output devices such as LED, motor, screen, etc.\n\n\n\n\nThe availability of external events depends on the \nenvironment\n in use.\n\n\nPrograms can \nemit\n output events and \nawait\n input events.\n\n\n\n\n\n\n\n\nInternal Events\n\n\nInternal events, unlike external events, do not represent real devices and are\ndefined by the programmer.\nInternal events serve as signalling and communication mechanisms among trails\nin a program.\n\n\nPrograms can \nemit\n and \nawait\n internal events.\n\n\nPools\n\n\nA pool is a dynamic container to hold running \ncode abstractions\n.\n\n\nA pool \ndeclaration\n specifies the type of the abstraction and maximum\nnumber of concurrent instances (possibly unlimited).\nIndividual elements of pools can only be accessed through \niterators\n.\nNew elements are created with \nspawn\n and are removed automatically\nwhen the code execution terminates.\n\n\nExample:\n\n\ncode/await Anim (void) =\n void do       // defines the \nAnim\n code abstraction\n    \n...\n                               // body of \nAnim\n\nend\npool[] Anim ms;                         // declares an unlimited container for \nAnim\n instances\nloop i in [0-\n10[ do\n    spawn Anim() in ms;                 // creates 10 instances of \nAnim\n into \nms\n\nend\n\n\n\n\nWhen a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.", 
            "title": "Classes"
        }, 
        {
            "location": "/storage_classes/classes/#classes", 
            "text": "", 
            "title": "Classes"
        }, 
        {
            "location": "/storage_classes/classes/#variables", 
            "text": "A variable in C\u00e9u holds a value of a  declared   type  that may\nvary during program execution.\nThe value of a variable can be read in  expressions  or written in assignments .\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.   Example:  var int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)", 
            "title": "Variables"
        }, 
        {
            "location": "/storage_classes/classes/#vectors", 
            "text": "A vector In C\u00e9u is a dynamic and contiguous collection of elements of the same\ntype.  A vector  declaration  specifies its type and maximum number of elements\n(possibly unlimited).\nThe current size of a vector is dynamic and can be accessed through the operator  $ .  Individual elements of a vector can be accessed through a numeric index  starting from  0 .\nC\u00e9u generates an  error  for out-of-bounds vector accesses.  Example:  vector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)", 
            "title": "Vectors"
        }, 
        {
            "location": "/storage_classes/classes/#events", 
            "text": "Events account for the reactive nature of C\u00e9u.\nPrograms manipulate events through the  await  and  emit \nstatements.\nAn  await  halts the running trail until the specified event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.  Unlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through  emit  and  await  statements.\nA  declaration  includes the type of value the occurring event carries.  Note:  void  is a valid type for signal-only events.  Example:  input  void I;           //  I  is an input event that carries no values\noutput int  O;           //  O  is an output event that carries values of type  int \nevent  int  e;           //  e  is an internal event that carries values of type  int \npar/and do\n    await I;             // awakes when  I  occurs\n    emit e(10);          // broadcasts  e  passing 10, awakes the  await  below\nwith\n    var int v = await e; // awaits  e  assigning the received value to  v \n    emit O(v);           // emits  O  back to the environment passing  v \nend  As described in  Internal Reactions , C\u00e9u supports external and internal\nevents with different behavior.", 
            "title": "Events"
        }, 
        {
            "location": "/storage_classes/classes/#external-events", 
            "text": "External events are used as interfaces between programs and devices from the \nreal world:   input events  represent input devices such as sensor, button, mouse, etc.  output events  represent output devices such as LED, motor, screen, etc.   The availability of external events depends on the  environment  in use.  Programs can  emit  output events and  await  input events.", 
            "title": "External Events"
        }, 
        {
            "location": "/storage_classes/classes/#internal-events", 
            "text": "Internal events, unlike external events, do not represent real devices and are\ndefined by the programmer.\nInternal events serve as signalling and communication mechanisms among trails\nin a program.  Programs can  emit  and  await  internal events.", 
            "title": "Internal Events"
        }, 
        {
            "location": "/storage_classes/classes/#pools", 
            "text": "A pool is a dynamic container to hold running  code abstractions .  A pool  declaration  specifies the type of the abstraction and maximum\nnumber of concurrent instances (possibly unlimited).\nIndividual elements of pools can only be accessed through  iterators .\nNew elements are created with  spawn  and are removed automatically\nwhen the code execution terminates.  Example:  code/await Anim (void) =  void do       // defines the  Anim  code abstraction\n     ...                                // body of  Anim \nend\npool[] Anim ms;                         // declares an unlimited container for  Anim  instances\nloop i in [0- 10[ do\n    spawn Anim() in ms;                 // creates 10 instances of  Anim  into  ms \nend  When a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.", 
            "title": "Pools"
        }, 
        {
            "location": "/storage_classes/locations/", 
            "text": "Locations\n\n\nA location (aka. \nl-value\n) is a path to a memory location holding a storage\nclass entity (\nID_int\n) or a native symbol (\nID_nat\n):\n\n\nLoc    ::= Loc_01\nLoc_01 ::= [`*\u00b4|`$\u00b4] Loc_02\nLoc_02 ::= Loc_03 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nLoc_03 ::= `(\u00b4 Loc_01 [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4 \ncode in C\n `}\u00b4\n\n\n\n\nThe list that follows enumerates all valid locations:\n\n\n\n\nstorage class entity: variable, vector, internal event (but not external), or pool\n\n\nnative expressions and symbols\n\n\ndata field (which are storage class entities)\n\n\ntypecast\n\n\nvector index\n\n\nvector length \n$\n\n\npointer dereferencing \n*\n\n\noption dereferencing \n!\n\n\n\n\nLocations appear in assignments, event manipulation, iterators, and\nexpressions.\n\n\nExamples:\n\n\nemit e(1);          // \ne\n is an internal event\n_UDR = 10;          // \n_UDR\n is a native symbol\nperson.age = 70;    // \nage\n is a variable in \nperson\n\nvec[0] = $vec;      // \nvec[0]\n is a vector index\n$vec = 1;           // \n$vec\n is a vector length\n*ptr = 1;           // \nptr\n is a pointer to a variable\na! = 1;             // \na\n is of an option type", 
            "title": "Locations"
        }, 
        {
            "location": "/storage_classes/locations/#locations", 
            "text": "A location (aka.  l-value ) is a path to a memory location holding a storage\nclass entity ( ID_int ) or a native symbol ( ID_nat ):  Loc    ::= Loc_01\nLoc_01 ::= [`*\u00b4|`$\u00b4] Loc_02\nLoc_02 ::= Loc_03 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nLoc_03 ::= `(\u00b4 Loc_01 [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4  code in C  `}\u00b4  The list that follows enumerates all valid locations:   storage class entity: variable, vector, internal event (but not external), or pool  native expressions and symbols  data field (which are storage class entities)  typecast  vector index  vector length  $  pointer dereferencing  *  option dereferencing  !   Locations appear in assignments, event manipulation, iterators, and\nexpressions.  Examples:  emit e(1);          //  e  is an internal event\n_UDR = 10;          //  _UDR  is a native symbol\nperson.age = 70;    //  age  is a variable in  person \nvec[0] = $vec;      //  vec[0]  is a vector index\n$vec = 1;           //  $vec  is a vector length\n*ptr = 1;           //  ptr  is a pointer to a variable\na! = 1;             //  a  is of an option type", 
            "title": "Locations"
        }, 
        {
            "location": "/storage_classes/references/", 
            "text": "References\n\n\nC\u00e9u supports \naliases\n and \npointers\n as references to entities\n(a.k.a. as \nstrong\n and \nweak\n references, respectively).\n\n\nAn alias is an alternate view for an entity---after the entity and alias are\nbounded, they are indistinguishable.\nA pointer is the address of an entity and provides indirect access to it.\n\n\nAs an analogy with a person's identity,\na family nickname used by her family to refer to her is an alias;\na job position used by her company to refer to her is a pointer.\n\n\nAliases\n\n\nAn alias is \ndeclared\n by suffixing the storage class with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\n\n\nExample:\n\n\nvar  int v = 0;\nvar\n int a = \nv;        // \na\n is an alias to \nv\n\n...\na = 1;                  // \na\n and \nv\n are indistinguishable\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nAn alias must have a narrower scope than the entity it refers to.\nThe \nassignment\n to the alias is immutable and must occur between its\ndeclaration and first access or next \nyielding statement\n.\nIt is not possible to acquire aliases to external events or to pointer types.\n\n\nTODO: \n?\n\n\nPointers\n\n\nA pointer is \ndeclared\n by suffixing the type with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\nApplying the operator \n*\n to a pointer provides indirect access to its\nreferenced entity.\n\n\nExample:\n\n\nvar int   v = 0;\nvar int\n p = \nv;      // \np\n holds a pointer to \nv\n\n...\n*p = 1;                 // \np\n provides indirect access to \nv\n\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nC\u00e9u only supports pointers to \nprimitive\n and\n\ndata abstraction\n types.\nAlso, it is only possible to acquire pointers to variables (not to events,\nvectors, or pools).\nHowever, a variable of a pointer type is only visible between its declaration\nand the next \nyielding statement\n.", 
            "title": "References"
        }, 
        {
            "location": "/storage_classes/references/#references", 
            "text": "C\u00e9u supports  aliases  and  pointers  as references to entities\n(a.k.a. as  strong  and  weak  references, respectively).  An alias is an alternate view for an entity---after the entity and alias are\nbounded, they are indistinguishable.\nA pointer is the address of an entity and provides indirect access to it.  As an analogy with a person's identity,\na family nickname used by her family to refer to her is an alias;\na job position used by her company to refer to her is a pointer.", 
            "title": "References"
        }, 
        {
            "location": "/storage_classes/references/#aliases", 
            "text": "An alias is  declared  by suffixing the storage class with the modifier  and is acquired by prefixing an entity with the operator  .  Example:  var  int v = 0;\nvar  int a =  v;        //  a  is an alias to  v \n...\na = 1;                  //  a  and  v  are indistinguishable\n_printf( %d\\n , v);     // prints 1  An alias must have a narrower scope than the entity it refers to.\nThe  assignment  to the alias is immutable and must occur between its\ndeclaration and first access or next  yielding statement .\nIt is not possible to acquire aliases to external events or to pointer types.  TODO:  ?", 
            "title": "Aliases"
        }, 
        {
            "location": "/storage_classes/references/#pointers", 
            "text": "A pointer is  declared  by suffixing the type with the modifier  and is acquired by prefixing an entity with the operator  .\nApplying the operator  *  to a pointer provides indirect access to its\nreferenced entity.  Example:  var int   v = 0;\nvar int  p =  v;      //  p  holds a pointer to  v \n...\n*p = 1;                 //  p  provides indirect access to  v \n_printf( %d\\n , v);     // prints 1  C\u00e9u only supports pointers to  primitive  and data abstraction  types.\nAlso, it is only possible to acquire pointers to variables (not to events,\nvectors, or pools).\nHowever, a variable of a pointer type is only visible between its declaration\nand the next  yielding statement .", 
            "title": "Pointers"
        }, 
        {
            "location": "/statements/", 
            "text": "Statements\n\n\nA program in C\u00e9u is a sequence of statements delimited by an enclosing block as\nfollows:\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\n\n\n\nNote: statements terminated with the \nend\n keyword do not require a\nterminating semicolon.", 
            "title": "Statements"
        }, 
        {
            "location": "/statements/#statements", 
            "text": "A program in C\u00e9u is a sequence of statements delimited by an enclosing block as\nfollows:  Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}  Note: statements terminated with the  end  keyword do not require a\nterminating semicolon.", 
            "title": "Statements"
        }, 
        {
            "location": "/statements/declarations/", 
            "text": "Declarations\n\n\nA declaration exposes a \nstorage entity\n to the program.\nDeclarations have \nlexical scope\n.\n\n\nC\u00e9u supports variables, vectors, external events, internal events, and pools:\n\n\nVar  ::= var [`\n\u00b4|`\n?\u00b4] Type LIST(ID_int [`=\u00b4 Cons])\nVec  ::= vector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\nExt  ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      |  output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\nInt  ::= event [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Cons])\nPool ::= pool [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\n\nVec_Cons ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4) }\n\n\n\n\nSee also \nStorage Classes\n for an overview of storage entities.\n\n\nVariable\n\n\nA \nvariable\n declaration has an associated \ntype\n and can be\noptionally \ninitialized\n.\nA single statement can declare multiple variables of the same type.\nDeclarations can also be \naliases\n or \noption aliases\n.\n\n\nExamples:\n\n\nvar  int v = 10;    // \nv\n is an integer variable initialized to 10\nvar  int a=0, b=3;  // \na\n and \nb\n are integer variables initialized to 0 and 3\nvar\n int z = \nv;    // \nz\n is an alias to \nv\n\n\n\n\n\nVector\n\n\nA \nvector\n declaration has a dimension, an associated \ntype\n and\ncan be optionally \ninitialized\n.\nA single statement can declare multiple vectors of the same dimension and type.\nDeclarations can also be \naliases\n.\nThe expression between the brackets specifies the \ndimension\n of the\nvector.\n\n\nTODO: constructor\n\n\nExamples:\n\n\nvar int n = 10;\nvector[10] int vs1 = [];    // \nvs1\n is a static vector of 10 elements max\nvector[n]  int vs2 = [];    // \nvs2\n is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    // \nvs3\n is an unbounded vector\nvector\n[]  int vs4 = \nvs1;  // \nvs4\n is an alias to \nvs1\n\n\n\n\n\nEvent\n\n\nAn \nevent\n has a \ntype\n for the value it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.\n\n\nSee also \nIntroduction\n for a general overview of events.\n\n\nExternal Event\n\n\nExamples:\n\n\ninput  void A,B;        // \nA\n and \nB\n are input events carrying no values\noutput int  MY_EVT;     // \nMY_EVT\n is an output event carrying integer values\ninput (int,byte\n) BUF; // \nBUF\n is an input event carrying an \n(int,byte\n)\n pair\n\n\n\n\nInternal Event\n\n\nDeclarations for internal events can also be \naliases\n or\n\noption aliases\n.\nOnly in this case they can contain an \ninitialization\n.\n\n\nExamples:\n\n\nevent  void a,b;        // \na\n and \nb\n are internal events carrying no values\nevent\n void z = \na;     // \nz\n is an alias to event \na\n\nevent (int,int) c;      // \nc\n is a internal event carrying an \n(int,int)\n pair\n\n\n\n\nPool\n\n\nA \npool\n has a dimension, an associated \ntype\n and can be\noptionally \ninitialized\n.\nA single statement can declare multiple pools of the same dimension and type.\nDeclarations can also be \naliases\n.\nThe expression between the brackets specifies the \ndimension\n of the\npool.\n\n\nExamples:\n\n\ncode/await Play (...) do ... end\npool[10] Play plays;        // \nplays\n is a static pool of 10 elements max\npool\n[]  Play a = \nplays;   // \na\n is an alias to \nplays\n\n\n\n\n\nSee also \nCode Invocation\n.\n\n\nTODO: data\n\n\nDimension\n\n\nA declaration for \nvector\n or \npool\n requires an expression\nbetween brackets to specify its \ndimension\n as follows:\n\n\n\n\nconstant expression\n: Maximum number of elements is fixed and space is\n                         statically pre-allocated.\n\n\nvariable expression\n: Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.\n\n\nomitted\n: Maximum number of elements is unbounded and space is dynamically\n             allocated.\n\n\n\n\nThe space for dynamic dimensions grow and shrink automatically.", 
            "title": "Declatations"
        }, 
        {
            "location": "/statements/declarations/#declarations", 
            "text": "A declaration exposes a  storage entity  to the program.\nDeclarations have  lexical scope .  C\u00e9u supports variables, vectors, external events, internal events, and pools:  Var  ::= var [` \u00b4|` ?\u00b4] Type LIST(ID_int [`=\u00b4 Cons])\nVec  ::= vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\nExt  ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      |  output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\nInt  ::= event [` \u00b4|` ?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Cons])\nPool ::= pool [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\n\nVec_Cons ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4) }  See also  Storage Classes  for an overview of storage entities.", 
            "title": "Declarations"
        }, 
        {
            "location": "/statements/declarations/#variable", 
            "text": "A  variable  declaration has an associated  type  and can be\noptionally  initialized .\nA single statement can declare multiple variables of the same type.\nDeclarations can also be  aliases  or  option aliases .  Examples:  var  int v = 10;    //  v  is an integer variable initialized to 10\nvar  int a=0, b=3;  //  a  and  b  are integer variables initialized to 0 and 3\nvar  int z =  v;    //  z  is an alias to  v", 
            "title": "Variable"
        }, 
        {
            "location": "/statements/declarations/#vector", 
            "text": "A  vector  declaration has a dimension, an associated  type  and\ncan be optionally  initialized .\nA single statement can declare multiple vectors of the same dimension and type.\nDeclarations can also be  aliases .\nThe expression between the brackets specifies the  dimension  of the\nvector.  TODO: constructor  Examples:  var int n = 10;\nvector[10] int vs1 = [];    //  vs1  is a static vector of 10 elements max\nvector[n]  int vs2 = [];    //  vs2  is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    //  vs3  is an unbounded vector\nvector []  int vs4 =  vs1;  //  vs4  is an alias to  vs1", 
            "title": "Vector"
        }, 
        {
            "location": "/statements/declarations/#event", 
            "text": "An  event  has a  type  for the value it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.  See also  Introduction  for a general overview of events.", 
            "title": "Event"
        }, 
        {
            "location": "/statements/declarations/#external-event", 
            "text": "Examples:  input  void A,B;        //  A  and  B  are input events carrying no values\noutput int  MY_EVT;     //  MY_EVT  is an output event carrying integer values\ninput (int,byte ) BUF; //  BUF  is an input event carrying an  (int,byte )  pair", 
            "title": "External Event"
        }, 
        {
            "location": "/statements/declarations/#internal-event", 
            "text": "Declarations for internal events can also be  aliases  or option aliases .\nOnly in this case they can contain an  initialization .  Examples:  event  void a,b;        //  a  and  b  are internal events carrying no values\nevent  void z =  a;     //  z  is an alias to event  a \nevent (int,int) c;      //  c  is a internal event carrying an  (int,int)  pair", 
            "title": "Internal Event"
        }, 
        {
            "location": "/statements/declarations/#pool", 
            "text": "A  pool  has a dimension, an associated  type  and can be\noptionally  initialized .\nA single statement can declare multiple pools of the same dimension and type.\nDeclarations can also be  aliases .\nThe expression between the brackets specifies the  dimension  of the\npool.  Examples:  code/await Play (...) do ... end\npool[10] Play plays;        //  plays  is a static pool of 10 elements max\npool []  Play a =  plays;   //  a  is an alias to  plays   See also  Code Invocation .  TODO: data", 
            "title": "Pool"
        }, 
        {
            "location": "/statements/declarations/#dimension", 
            "text": "A declaration for  vector  or  pool  requires an expression\nbetween brackets to specify its  dimension  as follows:   constant expression : Maximum number of elements is fixed and space is\n                         statically pre-allocated.  variable expression : Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.  omitted : Maximum number of elements is unbounded and space is dynamically\n             allocated.   The space for dynamic dimensions grow and shrink automatically.", 
            "title": "Dimension"
        }, 
        {
            "location": "/statements/assignments/", 
            "text": "Assignments\n\n\nAn assignment associates the statement or expression at the right side of \n=\n\nwith the name(s) at the left side:\n\n\nSet ::= (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Cons\n\nCons ::= ( Do\n         | Await\n         | Emit_Ext\n         | Watching\n         | Async_Thread\n         | Lua_State\n         | Lua_Stmts\n         | Code_Await\n         | Code_Spawn\n         | Vec_Cons\n         | Data_Cons\n         | `_\u00b4\n         | Exp )\n\n\n\n\nCopy Assignment\n\n\nA \ncopy assignment\n evaluates the statement or expression at the right side and\ncopies the result(s) to the name(s).\n\n\nAlias Assignment\n\n\nAn \nalias assignment\n makes the name at the left side to be a synonym to the\nexpression at the right side.", 
            "title": "Assignments"
        }, 
        {
            "location": "/statements/assignments/#assignments", 
            "text": "An assignment associates the statement or expression at the right side of  = \nwith the name(s) at the left side:  Set ::= (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Cons\n\nCons ::= ( Do\n         | Await\n         | Emit_Ext\n         | Watching\n         | Async_Thread\n         | Lua_State\n         | Lua_Stmts\n         | Code_Await\n         | Code_Spawn\n         | Vec_Cons\n         | Data_Cons\n         | `_\u00b4\n         | Exp )", 
            "title": "Assignments"
        }, 
        {
            "location": "/statements/assignments/#copy-assignment", 
            "text": "A  copy assignment  evaluates the statement or expression at the right side and\ncopies the result(s) to the name(s).", 
            "title": "Copy Assignment"
        }, 
        {
            "location": "/statements/assignments/#alias-assignment", 
            "text": "An  alias assignment  makes the name at the left side to be a synonym to the\nexpression at the right side.", 
            "title": "Alias Assignment"
        }, 
        {
            "location": "/statements/event_handling/", 
            "text": "Event Handling\n\n\nAwait\n\n\nThe \nawait\n statement halts the running trail until the referred\nevent occurs.\nThe event can be an \nexternal input event\n, an \ninternal event\n,\na timer, a \npausing event\n, or forever (i.e., never awake):\n\n\nAwait ::= await (ID_ext | Loc) [until Exp]      /* events */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */\n\n\n\n\nExamples:\n\n\nawait A;                  // awaits the input event `A`\nawait a;                  // awaits the internal event `a`\n\nawait 1min10s30ms100us;   // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable `t` in milliseconds\n\nawait FOREVER;            // awaits forever\n\n\n\n\nAn \nawait\n evaluates to zero or more values which can be captured with an\noptional \nassignment\n.\n\n\nEvent\n\n\nThe \nawait\n statement for events halts the running trail until the referred\n\nexternal input event\n or  \ninternal event\n occurs.\n\n\nThe \nawait\n evaluates to a value of the type of the event.\n\n\nThe optional clause \nuntil\n tests an additional condition required to awake.\nThe condition can use the returned value from the \nawait\n.\nIt expands to a \nloop\n as follows:\n\n\nloop do\n    \nret\n = await \nevt\n;\n    if \nExp\n then   // \nExp\n can use \nret\n\n        break;\n    end\nend\n\n\n\n\nExamples:\n\n\ninput int E;                    // \nE\n is an external input event carrying \nint\n values\nvar int v = await E until v\n10; // assigns occurring \nE\n to \nv\n, awaking when \nv\n10\n\n\nevent (bool,int) e;             // \ne\n is an internal event carrying \n(bool,int)\n pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on \ne\n and assigns its values to \nv1\n and \nv2\n\n\n\n\n\nTimer\n\n\nThe \nawait\n statement for timers halts the running trail until the referred\ntimer expires.\n\n\nWCLOCKK\n specifies a constant time expressed as a sequence of value/unit\npairs.\n\nWCLOCKE\n specifies an \ninteger\n expression in parenthesis followed by a\nsingle unit of time.\n\n\nThe \nawait\n evaluates to a value of type \ns32\n and is the\n\nresidual delta time (\ndt\n)\n measured in microseconds.\nIt is the difference between the actual elapsed time and the requested time.\n\n\nIf a program awaits timers in sequence (or in a \nloop\n), the residual \ndt\n from\nthe preceding timer is reduced from the timer in sequence.\n\n\nExamples:\n\n\nvar int t = \n...\n;\nawait (t)ms;                // awakes after \nt\n milliseconds\n\n\n\n\nvar int dt = await 100us;   // if 1ms elapses,  1000\n100, dt=900us\nawait 100us;                // timer is expired, 900\n100, dt=800us\nawait 1ms;                  // timer only awaits 200us (1000-800)\n\n\n\n\nNote: The residual \ndt\n is always greater than or equal to 0.\n\n\n\n\n\nPausing\n\n\nPausing events are dicussed in \nPausing\n.\n\n\nFOREVER\n\n\nThe \nawait\n statement for \nFOREVER\n halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.\n\n\nif \ncnd\n then\n    await FOREVER;  // this trail never awakes if the condition is true\nend\n\n\n\n\nEmit\n\n\nThe \nemit\n statement broadcasts an event to the whole program.\nThe event can be an \nexternal event\n, an \ninternal event\n, or\na timer:\n\n\nEmit ::= emit (ID_ext | Loc) [`(\u00b4 [LIST(Exp)] `)\u00b4)]\n      |  emit (WCLOCKK|WCLOCKE)\n\n\n\n\nExamples:\n\n\nemit A;         // emits the external event `A` of type \nvoid\n\nemit a(1);      // emits the internal event `a` of type \nint\n\n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds\n\n\n\n\nEvents\n\n\nThe \nemit\n statement for events expects a specific number of arguments matching\nthe event type (unless the event is of type \nvoid\n).\n\n\n\n\nAn \nemit\n to an external input or timer event can only occur inside\n  \nasynchronous blocks\n.\n\n\nAn \nemit\n to an external output event is also an expression that evaluates\n  to a value of type \ns32\n and can be captured with an optional\n  \nassignment\n (its meaning is \nplatform dependent\n).\n\n\nAn \nemit\n to an internal event starts a new \ninternal reaction\n.\n\n\n\n\nExamples:\n\n\ninput int I;\nasync do\n    emit I(10);         // broadcasts \nI\n to the application itself, passing \n10\n\nend\n\noutput void O;\nvar int ret = emit O(); // outputs \nO\n to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts \ne\n passing a pair of \nint\n values\n\n\n\n\nTimer\n\n\nThe \nemit\n statement for timers expects an expression of time as described in\n\nAwait Timer\n.\n\n\nLike input events, time can only be emitted inside \nasynchronous \nblocks\n.\n\n\nExamples:\n\n\nasync do\n    emit 1s;    // broadcasts \n1s\n to the application itself\nend\n\n\n\n\nLock\n\n\nTODO", 
            "title": "Event Handling"
        }, 
        {
            "location": "/statements/event_handling/#event-handling", 
            "text": "", 
            "title": "Event Handling"
        }, 
        {
            "location": "/statements/event_handling/#await", 
            "text": "The  await  statement halts the running trail until the referred\nevent occurs.\nThe event can be an  external input event , an  internal event ,\na timer, a  pausing event , or forever (i.e., never awake):  Await ::= await (ID_ext | Loc) [until Exp]      /* events */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */  Examples:  await A;                  // awaits the input event `A`\nawait a;                  // awaits the internal event `a`\n\nawait 1min10s30ms100us;   // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable `t` in milliseconds\n\nawait FOREVER;            // awaits forever  An  await  evaluates to zero or more values which can be captured with an\noptional  assignment .", 
            "title": "Await"
        }, 
        {
            "location": "/statements/event_handling/#event", 
            "text": "The  await  statement for events halts the running trail until the referred external input event  or   internal event  occurs.  The  await  evaluates to a value of the type of the event.  The optional clause  until  tests an additional condition required to awake.\nThe condition can use the returned value from the  await .\nIt expands to a  loop  as follows:  loop do\n     ret  = await  evt ;\n    if  Exp  then   //  Exp  can use  ret \n        break;\n    end\nend  Examples:  input int E;                    //  E  is an external input event carrying  int  values\nvar int v = await E until v 10; // assigns occurring  E  to  v , awaking when  v 10 \n\nevent (bool,int) e;             //  e  is an internal event carrying  (bool,int)  pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on  e  and assigns its values to  v1  and  v2", 
            "title": "Event"
        }, 
        {
            "location": "/statements/event_handling/#timer", 
            "text": "The  await  statement for timers halts the running trail until the referred\ntimer expires.  WCLOCKK  specifies a constant time expressed as a sequence of value/unit\npairs. WCLOCKE  specifies an  integer  expression in parenthesis followed by a\nsingle unit of time.  The  await  evaluates to a value of type  s32  and is the residual delta time ( dt )  measured in microseconds.\nIt is the difference between the actual elapsed time and the requested time.  If a program awaits timers in sequence (or in a  loop ), the residual  dt  from\nthe preceding timer is reduced from the timer in sequence.  Examples:  var int t =  ... ;\nawait (t)ms;                // awakes after  t  milliseconds  var int dt = await 100us;   // if 1ms elapses,  1000 100, dt=900us\nawait 100us;                // timer is expired, 900 100, dt=800us\nawait 1ms;                  // timer only awaits 200us (1000-800)  Note: The residual  dt  is always greater than or equal to 0.", 
            "title": "Timer"
        }, 
        {
            "location": "/statements/event_handling/#pausing", 
            "text": "Pausing events are dicussed in  Pausing .", 
            "title": "Pausing"
        }, 
        {
            "location": "/statements/event_handling/#forever", 
            "text": "The  await  statement for  FOREVER  halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.  if  cnd  then\n    await FOREVER;  // this trail never awakes if the condition is true\nend", 
            "title": "FOREVER"
        }, 
        {
            "location": "/statements/event_handling/#emit", 
            "text": "The  emit  statement broadcasts an event to the whole program.\nThe event can be an  external event , an  internal event , or\na timer:  Emit ::= emit (ID_ext | Loc) [`(\u00b4 [LIST(Exp)] `)\u00b4)]\n      |  emit (WCLOCKK|WCLOCKE)  Examples:  emit A;         // emits the external event `A` of type  void \nemit a(1);      // emits the internal event `a` of type  int \n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds", 
            "title": "Emit"
        }, 
        {
            "location": "/statements/event_handling/#events", 
            "text": "The  emit  statement for events expects a specific number of arguments matching\nthe event type (unless the event is of type  void ).   An  emit  to an external input or timer event can only occur inside\n   asynchronous blocks .  An  emit  to an external output event is also an expression that evaluates\n  to a value of type  s32  and can be captured with an optional\n   assignment  (its meaning is  platform dependent ).  An  emit  to an internal event starts a new  internal reaction .   Examples:  input int I;\nasync do\n    emit I(10);         // broadcasts  I  to the application itself, passing  10 \nend\n\noutput void O;\nvar int ret = emit O(); // outputs  O  to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts  e  passing a pair of  int  values", 
            "title": "Events"
        }, 
        {
            "location": "/statements/event_handling/#timer_1", 
            "text": "The  emit  statement for timers expects an expression of time as described in Await Timer .  Like input events, time can only be emitted inside  asynchronous \nblocks .  Examples:  async do\n    emit 1s;    // broadcasts  1s  to the application itself\nend", 
            "title": "Timer"
        }, 
        {
            "location": "/statements/event_handling/#lock", 
            "text": "TODO", 
            "title": "Lock"
        }, 
        {
            "location": "/statements/conditional/", 
            "text": "Conditional\n\n\nThe \nif-then-else\n statement provides conditionals in C\u00e9u:\n\n\nIf ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end\n\n\n\n\nEach condition \nExp\n is tested in sequence, first for the \nif\n clause and then\nfor each of the optional \nelse/if\n clauses.\nFor the first condition that evaluates to \ntrue\n, the \nBlock\n following it\nexecutes.\nIf all conditions fail, the optional \nelse\n clause executes.\n\n\nAll conditions must evaluate to a value of type \nbool\n, which is\nchecked at compile time.", 
            "title": "Conditional"
        }, 
        {
            "location": "/statements/conditional/#conditional", 
            "text": "The  if-then-else  statement provides conditionals in C\u00e9u:  If ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end  Each condition  Exp  is tested in sequence, first for the  if  clause and then\nfor each of the optional  else/if  clauses.\nFor the first condition that evaluates to  true , the  Block  following it\nexecutes.\nIf all conditions fail, the optional  else  clause executes.  All conditions must evaluate to a value of type  bool , which is\nchecked at compile time.", 
            "title": "Conditional"
        }, 
        {
            "location": "/statements/loops/", 
            "text": "Loops\n\n\nC\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:\n\n\nLoop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] Numeric do    /* Numeric ::= (see \nNumeric Iterators\n) */\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Loc do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]\n\n\n\n\nThe \nBlock\n body of a loop executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.\n\n\nExcept for the \nevery\n iterator, all loops support an optional\n\n/\nExp\n to limit the maximum number of iterations and\navoid \ninfinite execution\n.\nThe expression must be a constant evaluated at compile time.\n\n\nbreak\n and \ncontinue\n\n\nThe \nbreak\n statement aborts the deepest enclosing loop.\n\n\nThe \ncontinue\n statement aborts the body of the deepest enclosing loop and\nrestarts in the next iteration.\n\n\nThe optional \n/\nID_int\n in both statements only applies\nto \nnumeric iterators\n.\n\n\nSimple Loop\n\n\nA simple loop executes its body continually and forever.\n\n\nExamples:\n\n\n// blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend\n\n\n\n\nloop do\n    loop do\n        if \ncnd-1\n then\n            break;      // aborts the loop at line 2 if \ncnd-1\n is satisfied\n        end\n    end\n    if \ncnd-2\n then\n        continue;       // restarts the loop at line 1 if \ncnd-2\n is satisfied\n    end\nend\n\n\n\n\nNumeric Iterator\n\n\nThe numeric loop modifies the value of a control variable on each iteration\naccording to the specification of an optional interval as follows:\n\n\nNumeric ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                  ( (     Exp `-\n\u00b4 (`_\u00b4|Exp))\n                                  | (`_\u00b4|Exp) `\n-\u00b4 Exp      ) )\n                              (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]\n\n\n\n\nThe control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:\n\n\n\n\ncontrol variable:\n\n    \nID_int\n is a variable of a \nnumeric type\n.\n    Alternatively, the special anonymous identifier \n_\n can be used if the body\n    of the loop does not access the variable.\n    The control variable is marked as \nread-only\n and cannot be changed\n    explicitly.\n\n\ninterval:\n\n    Specifies a direction, endpoints with open or closed modifiers, and a step.\n\n\ndirection\n:\n\n\n-\n: Starts from the endpoint \nExp\n on the left increasing towards \nExp\n on the right.\n\n\n-\n: Starts from the endpoint \nExp\n on the right decreasing towards \nExp\n on the left.\nTypically, the value on the left should always be smaller or equal to\nthe value on the right.\n\n\n\n\n\n\nendpoints\n:\n    \n[Exp\n and \nExp]\n are closed intervals which include \nExp\n as the\n    endpoints;\n    \n]Exp\n and \nExp[\n are open intervals which exclude \nExp\n as the\n    endpoints.\n    Alternatively, the finishing endpoint may be \n_\n which means that the\n    interval goes towards infinite.\n\n\nstep\n:\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value \n1\n.\n    If the direction is \n-\n, the step is added, otherwise it is subtracted.\nIf the interval is not specified, it assumes the default \n[0 -\n _]\n.\n\n\n\n\n\n\n\n\nThe numeric iterator executes as follows:\n\n\n\n\ninitialization:\n\n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step.\n\n\niteration:\n\n\nlimits test:\n\n    If the control variable crossed the finishing endpoint, the loop\n    terminates.\n\n\nbody execution:\n\n    The loop body executes.\n\n\nstep\n\n    Applies a step to the control variable. Goto step \n1\n.\n\n\n\n\n\n\n\n\nThe \nbreak\n and \ncontinue\n statements inside numeric iterators accept an\noptional modifier \n/\nID_int\n to match the control\nvariable of the enclosing loop to affect.\n\n\nExamples:\n\n\n// prints \ni=0\n, \ni=1\n, ...\nvar int i;\nloop i do\n    _printf(\ni=%d\\n\n, i);\nend\n\n\n\n\n// awaits 1s and prints \nHello World!\n 10 times\nloop _ in [0 -\n 10[ do\n    await 1s;\n    _printf(\nHello World!\\n\n);\nend\n\n\n\n\nvar int i;\nloop i do\n    var int j;\n    loop j do\n        if \ncnd-1\n then\n            continue/i;         // continues the loop at line 1\n        else/if \ncnd-2\n then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend\n\n\n\n\nNote : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.\n\n\nEvent Iterator\n\n\nThe \nevery\n statement iterates over an event continuously and executes its\nbody whenever the event occurs.\n\n\nThe event can be an \nexternal or internal event\n or a \ntimer\n.\n\n\nThe optional assignment to a variable (or list of variables) stores the\ncarrying value(s) of the event.\n\n\nAn \nevery\n expands to a \nloop\n as illustrated below:\n\n\nevery \nvars\n in \nevent\n do\n    \nbody\n\nend\n\n\n\n\nis equivalent to\n\n\nloop do\n    \nvars\n = await \nevent\n;\n    \nbody\n\nend\n\n\n\n\nHowever, the body of an \nevery\n cannot contain\n\nsynchronous control statements\n, ensuring that no occurrences of the\nspecified event are ever missed.\n\n\nExamples:\n\n\nevery 1s do\n    _printf(\nHello World!\\n\n);      // prints the \nHello World!\n message on every second\nend\n\n\n\n\nevent (bool,int) e;\nvar bool cnd;\nvar int  v;\nevery (cnd,v) in e do\n    if not cnd then\n        break;                      // terminates when the received \ncnd\n is false\n    else\n        _printf(\nv = %d\\n\n, v);     // prints the received \nv\n otherwise\n    end\nend\n\n\n\n\nPool Iterator\n\n\nPool iterator is discussed in \nCode Pools\n.", 
            "title": "Loops"
        }, 
        {
            "location": "/statements/loops/#loops", 
            "text": "C\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:  Loop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] Numeric do    /* Numeric ::= (see  Numeric Iterators ) */\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Loc do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]  The  Block  body of a loop executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.  Except for the  every  iterator, all loops support an optional / Exp  to limit the maximum number of iterations and\navoid  infinite execution .\nThe expression must be a constant evaluated at compile time.", 
            "title": "Loops"
        }, 
        {
            "location": "/statements/loops/#break-and-continue", 
            "text": "The  break  statement aborts the deepest enclosing loop.  The  continue  statement aborts the body of the deepest enclosing loop and\nrestarts in the next iteration.  The optional  / ID_int  in both statements only applies\nto  numeric iterators .", 
            "title": "break and continue"
        }, 
        {
            "location": "/statements/loops/#simple-loop", 
            "text": "A simple loop executes its body continually and forever.  Examples:  // blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend  loop do\n    loop do\n        if  cnd-1  then\n            break;      // aborts the loop at line 2 if  cnd-1  is satisfied\n        end\n    end\n    if  cnd-2  then\n        continue;       // restarts the loop at line 1 if  cnd-2  is satisfied\n    end\nend", 
            "title": "Simple Loop"
        }, 
        {
            "location": "/statements/loops/#numeric-iterator", 
            "text": "The numeric loop modifies the value of a control variable on each iteration\naccording to the specification of an optional interval as follows:  Numeric ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                  ( (     Exp `- \u00b4 (`_\u00b4|Exp))\n                                  | (`_\u00b4|Exp) ` -\u00b4 Exp      ) )\n                              (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]  The control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:   control variable: \n     ID_int  is a variable of a  numeric type .\n    Alternatively, the special anonymous identifier  _  can be used if the body\n    of the loop does not access the variable.\n    The control variable is marked as  read-only  and cannot be changed\n    explicitly.  interval: \n    Specifies a direction, endpoints with open or closed modifiers, and a step.  direction :  - : Starts from the endpoint  Exp  on the left increasing towards  Exp  on the right.  - : Starts from the endpoint  Exp  on the right decreasing towards  Exp  on the left.\nTypically, the value on the left should always be smaller or equal to\nthe value on the right.    endpoints :\n     [Exp  and  Exp]  are closed intervals which include  Exp  as the\n    endpoints;\n     ]Exp  and  Exp[  are open intervals which exclude  Exp  as the\n    endpoints.\n    Alternatively, the finishing endpoint may be  _  which means that the\n    interval goes towards infinite.  step :\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value  1 .\n    If the direction is  - , the step is added, otherwise it is subtracted.\nIf the interval is not specified, it assumes the default  [0 -  _] .     The numeric iterator executes as follows:   initialization: \n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step.  iteration:  limits test: \n    If the control variable crossed the finishing endpoint, the loop\n    terminates.  body execution: \n    The loop body executes.  step \n    Applies a step to the control variable. Goto step  1 .     The  break  and  continue  statements inside numeric iterators accept an\noptional modifier  / ID_int  to match the control\nvariable of the enclosing loop to affect.  Examples:  // prints  i=0 ,  i=1 , ...\nvar int i;\nloop i do\n    _printf( i=%d\\n , i);\nend  // awaits 1s and prints  Hello World!  10 times\nloop _ in [0 -  10[ do\n    await 1s;\n    _printf( Hello World!\\n );\nend  var int i;\nloop i do\n    var int j;\n    loop j do\n        if  cnd-1  then\n            continue/i;         // continues the loop at line 1\n        else/if  cnd-2  then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend  Note : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.", 
            "title": "Numeric Iterator"
        }, 
        {
            "location": "/statements/loops/#event-iterator", 
            "text": "The  every  statement iterates over an event continuously and executes its\nbody whenever the event occurs.  The event can be an  external or internal event  or a  timer .  The optional assignment to a variable (or list of variables) stores the\ncarrying value(s) of the event.  An  every  expands to a  loop  as illustrated below:  every  vars  in  event  do\n     body \nend  is equivalent to  loop do\n     vars  = await  event ;\n     body \nend  However, the body of an  every  cannot contain synchronous control statements , ensuring that no occurrences of the\nspecified event are ever missed.  Examples:  every 1s do\n    _printf( Hello World!\\n );      // prints the  Hello World!  message on every second\nend  event (bool,int) e;\nvar bool cnd;\nvar int  v;\nevery (cnd,v) in e do\n    if not cnd then\n        break;                      // terminates when the received  cnd  is false\n    else\n        _printf( v = %d\\n , v);     // prints the received  v  otherwise\n    end\nend", 
            "title": "Event Iterator"
        }, 
        {
            "location": "/statements/loops/#pool-iterator", 
            "text": "Pool iterator is discussed in  Code Pools .", 
            "title": "Pool Iterator"
        }, 
        {
            "location": "/statements/parallel_compositions/", 
            "text": "Parallel Compositions\n\n\nThe parallel statements \npar/and\n, \npar/or\n, and \npar\n split the running trail \nin multiple others:\n\n\nPars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nWatching ::= watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n                 Block\n             end\n\n\n\n\n\nThey differ only on how trails rejoin and terminate the composition.\n\n\nThe \nwatching\n statement terminates when one of its listed events occur.\nIt evaluates to what the terminating event evaluates which can be captured with\nan optional \nassignment\n.\n\n\nSee also \nParallel Compositions and Abortion\n.\n\n\npar\n\n\nThe \npar\n statement never rejoins.\n\n\nExamples:\n\n\n// reacts continuously to \n1s\n and \nKEY_PRESSED\n and never terminates\ninput void KEY_PRESSED;\npar do\n    every 1s do\n        \n...\n           // does something every \n1s\n\n    end\nwith\n    every KEY_PRESSED do\n        \n...\n           // does something every \nKEY_PRESSED\n\n    end\nend\n\n\n\n\npar/and\n\n\nThe \npar/and\n statement stands for \nparallel-and\n and rejoins when all trails \nterminate.\n\n\nExamples:\n\n\n// reacts once to \n1s\n and \nKEY_PRESSED\n and terminates\ninput void KEY_PRESSED;\npar/and do\n    await 1s;\n    \n...\n               // does something after \n1s\n\nwith\n    await KEY_PRESSED;\n    \n...\n               // does something after \nKEY_PRESSED\n\nend\n\n\n\n\npar/or\n\n\nThe \npar/or\n statement stands for \nparallel-or\n and rejoins when any of the \ntrails terminate, aborting all other trails.\n\n\nExamples:\n\n\n// reacts once to `1s` or `KEY_PRESSED` and terminates\ninput void KEY_PRESSED;\npar/or do\n    await 1s;\n    \n...\n               // does something after \n1s\n\nwith\n    await KEY_PRESSED;\n    \n...\n               // does something after \nKEY_PRESSED\n\nend\n\n\n\n\nwatching\n\n\nThe \nwatching\n statement accepts a list of events and terminates when any of\nthe events occur.\n\n\nA \nwatching\n expands to a \npar/or\n with \nn+1\n trails:\none to await each of the listed events,\nand one for its body, i.e.:\n\n\nwatching \ne1\n,\ne2\n,... do\n    \nbody\n\nend\n\n\n\n\nexpands to\n\n\npar/or do\n    await \ne1\n;\nwith\n    await \ne2\n;\nwith\n    ...\nwith\n    \nbody\n\nend\n\n\n\n\nExamples:\n\n\n// reacts continuously to \nKEY_PRESSED\n during \n1s\n\ninput void KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n        \n...\n           // does something every \nKEY_PRESSED\n\n    end\nend", 
            "title": "Parallel Compositions"
        }, 
        {
            "location": "/statements/parallel_compositions/#parallel-compositions", 
            "text": "The parallel statements  par/and ,  par/or , and  par  split the running trail \nin multiple others:  Pars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nWatching ::= watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n                 Block\n             end  They differ only on how trails rejoin and terminate the composition.  The  watching  statement terminates when one of its listed events occur.\nIt evaluates to what the terminating event evaluates which can be captured with\nan optional  assignment .  See also  Parallel Compositions and Abortion .", 
            "title": "Parallel Compositions"
        }, 
        {
            "location": "/statements/parallel_compositions/#par", 
            "text": "The  par  statement never rejoins.  Examples:  // reacts continuously to  1s  and  KEY_PRESSED  and never terminates\ninput void KEY_PRESSED;\npar do\n    every 1s do\n         ...            // does something every  1s \n    end\nwith\n    every KEY_PRESSED do\n         ...            // does something every  KEY_PRESSED \n    end\nend", 
            "title": "par"
        }, 
        {
            "location": "/statements/parallel_compositions/#parand", 
            "text": "The  par/and  statement stands for  parallel-and  and rejoins when all trails \nterminate.  Examples:  // reacts once to  1s  and  KEY_PRESSED  and terminates\ninput void KEY_PRESSED;\npar/and do\n    await 1s;\n     ...                // does something after  1s \nwith\n    await KEY_PRESSED;\n     ...                // does something after  KEY_PRESSED \nend", 
            "title": "par/and"
        }, 
        {
            "location": "/statements/parallel_compositions/#paror", 
            "text": "The  par/or  statement stands for  parallel-or  and rejoins when any of the \ntrails terminate, aborting all other trails.  Examples:  // reacts once to `1s` or `KEY_PRESSED` and terminates\ninput void KEY_PRESSED;\npar/or do\n    await 1s;\n     ...                // does something after  1s \nwith\n    await KEY_PRESSED;\n     ...                // does something after  KEY_PRESSED \nend", 
            "title": "par/or"
        }, 
        {
            "location": "/statements/parallel_compositions/#watching", 
            "text": "The  watching  statement accepts a list of events and terminates when any of\nthe events occur.  A  watching  expands to a  par/or  with  n+1  trails:\none to await each of the listed events,\nand one for its body, i.e.:  watching  e1 , e2 ,... do\n     body \nend  expands to  par/or do\n    await  e1 ;\nwith\n    await  e2 ;\nwith\n    ...\nwith\n     body \nend  Examples:  // reacts continuously to  KEY_PRESSED  during  1s \ninput void KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n         ...            // does something every  KEY_PRESSED \n    end\nend", 
            "title": "watching"
        }, 
        {
            "location": "/statements/pausing/", 
            "text": "Pausing\n\n\nThe \npause/if\n statement controls if its body should temporarily stop to react\nto events:\n\n\nPause_If ::= pause/if (Loc|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)\n\n\n\n\nA \npause/if\n determines a pausing event of type \nbool\n which, when emitted,\ntoggles between pausing (\ntrue\n) and resuming (\nfalse\n) reactions for its body.\n\n\nWhen its body terminates, the whole \npause/if\n terminates and proceeds to the\nstatement in sequence.\n\n\nIn transition points, the body can react to the special \npause\n and \nresume\n\nevents before the corresponding state applies.\n\n\nTODO: finalize/pause/resume\n\n\nExamples:\n\n\nevent bool e;\npause/if e do       // pauses/resumes the nested body on each \ne\n\n    every 1s do\n        \n...\n       // does something every \n1s\n\n    end\nend\n\n\n\n\nevent bool e;\npause/if e do               // pauses/resumes the nested body on each \ne\n\n    \n...\n\n        loop do\n            await pause;\n            \n...\n           // does something before pausing\n            await resume;\n            \n...\n           // does something before resuming\n        end\n    \n...\n\nend", 
            "title": "Pausing"
        }, 
        {
            "location": "/statements/pausing/#pausing", 
            "text": "The  pause/if  statement controls if its body should temporarily stop to react\nto events:  Pause_If ::= pause/if (Loc|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)  A  pause/if  determines a pausing event of type  bool  which, when emitted,\ntoggles between pausing ( true ) and resuming ( false ) reactions for its body.  When its body terminates, the whole  pause/if  terminates and proceeds to the\nstatement in sequence.  In transition points, the body can react to the special  pause  and  resume \nevents before the corresponding state applies.  TODO: finalize/pause/resume  Examples:  event bool e;\npause/if e do       // pauses/resumes the nested body on each  e \n    every 1s do\n         ...        // does something every  1s \n    end\nend  event bool e;\npause/if e do               // pauses/resumes the nested body on each  e \n     ... \n        loop do\n            await pause;\n             ...            // does something before pausing\n            await resume;\n             ...            // does something before resuming\n        end\n     ... \nend", 
            "title": "Pausing"
        }, 
        {
            "location": "/statements/asynchronous_execution/", 
            "text": "Asynchronous Execution\n\n\nAsynchronous execution allow programs to execute time consuming computations \nwithout interfering with the responsiveness of the  \nsynchronous side\n of\napplications (i.e., all core language statements):\n\n\nAsync  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\nAtomic ::= atomic do\n               Block\n           end\n\n\n\n\nThe program awaits the termination of the asynchronous body to proceed to the\nstatement in sequence.\n\n\nAsynchronous bodies can contain \ntight loops\n but which keep the\napplication reactive to incoming events.\nHowever, they do not support nesting of asynchronous statements, and do not\nsupport \nsynchronous control statements\n (i.e., parallel compositions,\nevent handling, pausing, etc.).\n\n\nBy default, asynchronous bodies do not shared variables with their enclosing\nscope.\nThe optional list of variables makes them visible to the block.\n\n\nAsynchronous Block\n\n\nThe asynchronous block (\nasync\n) preserves deterministic execution with the\nrules as follows:\n\n\n\n\nResume execution whenever the synchronous side is idle.\n\n\nYield control to the synchronous side on every complete \nloop\n iteration.\n\n\nYield control to the synchronous side on every \nemit\n.\n\n\nExecute atomically and to completion unless rules \n2\n and \n3\n apply.\n\n\n\n\nThis rules imply that \nasync\n blocks and the synchronous side never run at the\nsame time with real parallelism.\n\n\nExamples:\n\n\n// calculates the factorial of some \nv\n if it doesn't take too long\nvar u64  v   = \n...\n;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps \nv\n and \nfat\n visible\n        loop i in [1 -\n v] do   // reads from \nv\n\n            fat = fat * i;      // writes to \nfat\n\n        end\n    end\n    ok = true;                  // completed within \n1s\n\nend\n\n\n\n\nSimulation\n\n\nAn \nasync\n block can emit \ninput events\n and the\n\npassage of time\n towards the synchronous side, providing a way to test\nprograms in the language itself.\nEvery time an \nasync\n emits an event, it suspends until the synchronous side\nreacts to the event (see \nrule 1\n above).\n\n\nExamples:\n\n\ninput int A;\n\n// tests a program with a simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -\n _[ do\n        await 10ms;\n        _printf(\nv = %d\\n\n, v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for \nv\n\n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v = \nv+i\n` exactly 103 times.\n\n\n\n\nAsynchronous Thread\n\n\nAsynchronous threads (\nasync/thread\n) provide real parallelism for applications\nin C\u00e9u.\nOnce an \nasync/thread\n starts, it runs completely detached from the synchronous\nside.\nHowever, they are still ruled by the synchronous side and are also subject to\nabortion.\n\n\nAn \nasync/thread\n evaluates to a boolean value which indicates whether it\nstarted successfully.\nThe value can be captured with an optional \nassignment\n.\n\n\nAsynchronous threads are non deterministic and require explicit synchronization\non accesses to variables to avoid race conditions.\n\n\nExamples:\n\n\n// calculates the factorial of some \nv\n if it doesn't take too long\nvar u64  v   = \n...\n;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps \nv\n and \nfat\n visible\n        loop i in [1 -\n v] do       // reads from \nv\n\n            fat = fat * i;          // writes to \nfat\n\n        end\n    end\n    ok = true;                      // completed within \n1s\n\nend\n\n\n\n\nAtomic Block\n\n\nAtomic blocks provide mutual exclusion among threads and the synchronous\nside of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.\n\n\nExamples:\n\n\n// A \nrace\n between two threads: one incrementing, the other decrementing \ncount\n.\n\nvar s64 count = 0;                              // \ncount\n is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf(\ncount = %d\\n\n, count);     // prints current value of \ncount\n every \n1s\n\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements \ncount\n as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments \ncount\n as fast as possible\n            end\n        end\n    end\nend\n\n\n\n\nTODO: isr\n\n\nAsynchronous Interrupt Service Routine\n\n\nTODO", 
            "title": "Asynchronous Execution"
        }, 
        {
            "location": "/statements/asynchronous_execution/#asynchronous-execution", 
            "text": "Asynchronous execution allow programs to execute time consuming computations \nwithout interfering with the responsiveness of the   synchronous side  of\napplications (i.e., all core language statements):  Async  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\nAtomic ::= atomic do\n               Block\n           end  The program awaits the termination of the asynchronous body to proceed to the\nstatement in sequence.  Asynchronous bodies can contain  tight loops  but which keep the\napplication reactive to incoming events.\nHowever, they do not support nesting of asynchronous statements, and do not\nsupport  synchronous control statements  (i.e., parallel compositions,\nevent handling, pausing, etc.).  By default, asynchronous bodies do not shared variables with their enclosing\nscope.\nThe optional list of variables makes them visible to the block.", 
            "title": "Asynchronous Execution"
        }, 
        {
            "location": "/statements/asynchronous_execution/#asynchronous-block", 
            "text": "The asynchronous block ( async ) preserves deterministic execution with the\nrules as follows:   Resume execution whenever the synchronous side is idle.  Yield control to the synchronous side on every complete  loop  iteration.  Yield control to the synchronous side on every  emit .  Execute atomically and to completion unless rules  2  and  3  apply.   This rules imply that  async  blocks and the synchronous side never run at the\nsame time with real parallelism.  Examples:  // calculates the factorial of some  v  if it doesn't take too long\nvar u64  v   =  ... ;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps  v  and  fat  visible\n        loop i in [1 -  v] do   // reads from  v \n            fat = fat * i;      // writes to  fat \n        end\n    end\n    ok = true;                  // completed within  1s \nend", 
            "title": "Asynchronous Block"
        }, 
        {
            "location": "/statements/asynchronous_execution/#simulation", 
            "text": "An  async  block can emit  input events  and the passage of time  towards the synchronous side, providing a way to test\nprograms in the language itself.\nEvery time an  async  emits an event, it suspends until the synchronous side\nreacts to the event (see  rule 1  above).  Examples:  input int A;\n\n// tests a program with a simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -  _[ do\n        await 10ms;\n        _printf( v = %d\\n , v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for  v \n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v =  v+i ` exactly 103 times.", 
            "title": "Simulation"
        }, 
        {
            "location": "/statements/asynchronous_execution/#asynchronous-thread", 
            "text": "Asynchronous threads ( async/thread ) provide real parallelism for applications\nin C\u00e9u.\nOnce an  async/thread  starts, it runs completely detached from the synchronous\nside.\nHowever, they are still ruled by the synchronous side and are also subject to\nabortion.  An  async/thread  evaluates to a boolean value which indicates whether it\nstarted successfully.\nThe value can be captured with an optional  assignment .  Asynchronous threads are non deterministic and require explicit synchronization\non accesses to variables to avoid race conditions.  Examples:  // calculates the factorial of some  v  if it doesn't take too long\nvar u64  v   =  ... ;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps  v  and  fat  visible\n        loop i in [1 -  v] do       // reads from  v \n            fat = fat * i;          // writes to  fat \n        end\n    end\n    ok = true;                      // completed within  1s \nend", 
            "title": "Asynchronous Thread"
        }, 
        {
            "location": "/statements/asynchronous_execution/#atomic-block", 
            "text": "Atomic blocks provide mutual exclusion among threads and the synchronous\nside of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.  Examples:  // A  race  between two threads: one incrementing, the other decrementing  count .\n\nvar s64 count = 0;                              //  count  is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf( count = %d\\n , count);     // prints current value of  count  every  1s \n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements  count  as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments  count  as fast as possible\n            end\n        end\n    end\nend  TODO: isr", 
            "title": "Atomic Block"
        }, 
        {
            "location": "/statements/asynchronous_execution/#asynchronous-interrupt-service-routine", 
            "text": "TODO", 
            "title": "Asynchronous Interrupt Service Routine"
        }, 
        {
            "location": "/statements/c_integration/", 
            "text": "C Integration\n\n\nC\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers when dealing with\nexternal resources.\n\n\nC\u00e9u provides \nnative declarations\n to import C symbols,\n\nnative blocks\n to define new code in C,\n\nnative statements\n to inline C statements,\n\nnative calls\n to call C functions,\nand \nfinalization\n to deal with C pointers safely:\n\n\nNat_Symbol ::= native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\nNat_Block  ::= native `/\u00b4(pre|pos) do\n                   \ncode definitions in C\n\n               end\nNat_End    ::= native `/\u00b4 end\n\nNat_Stmts  ::= `{\u00b4 {\ncode in C\n | `@\u00b4 Exp} `}\u00b4\n\nNat_Call   ::= [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\nList_Nat ::= LIST(ID_nat)\n\nFinalization ::= do [Stmt] Finalize\n              |  var `\n?\u00b4 Type ID_int `=\u00b4 `\n\u00b4 (Call_Nat | Call_Code) Finalize\nFinalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                 Block\n             [ pause  with Block ]\n             [ resume with Block ]\n             end\n\n\n\n\nNative calls and statements transfer the control of the CPU to inlined code in\nC, losing the guarantees of the \nsynchronous model\n.\nFor this reason, programs should only resort to C for asynchronous\nfunctionality, such as non-blocking I/O, or simple \nstruct\n accessors, but\nnever for control purposes.\n\n\nTODO: Nat_End\n\n\nNative Declaration\n\n\nIn C\u00e9u, an \nidentifier\n prefixed with an underscore is considered a\nnative symbol that is defined externally in C.\nHowever, all external symbols must be declared before their first use.\n\n\nNative declarations support four modifiers as follows:\n\n\n\n\nconst\n: declares the listed symbols as constants.\n    Constants can be used as \nbounded limits\n in \nvectors\n,\n    \npools\n, and \nnumeric loops\n.\n    Also, constants cannot be \nassigned\n.\n\n\nplain\n: declares the listed symbols as \nplain\n types, i.e., types (or\n    composite types) that do not contain pointers.\n    Value of plain types passed as arguments to functions do not require\n    \nfinalization\n.\n\n\nnohold\n: declares the listed symbols as \nnon-holding\n functions, i.e.,\n    a function that does not retain received pointers as arguments after\n    returning.\n    Pointers passed to non-holding functions do not require\n    \nfinalization\n.\n\n\npure\n: declares the listed symbols as pure functions.\n    In addition to the \nnohold\n properties, pure functions never allocate\n    resources that require \nfinalization\n and have no side effects to\n    take into account for the \nsafety checks\n.\n\n\n\n\nExamples:\n\n\n// values\nnative/const  _LOW, _HIGH;      // Arduino's \nLOW\n and \nHIGH\n are constants\nnative        _errno;           // POSIX's \nerrno\n is a global variable\n\n// types\nnative/plain  _char;            // \nchar\n is a \nplain\n type\nnative        _SDL_PixelFormat; // SDL's \nSDL_PixelFormat\n is a type holding a pointer\n\n// functions\nnative        _uv_read_start;   // Libuv's \nuv_read_start\n retains the received pointer\nnative/nohold _free;            // POSIX's \nfree\n receives a pointer but does not retain it\nnative/pure   _strlen;          // POSIX's \nstrlen\n is a \npure\n function\n\n\n\n\nNative Block\n\n\nNative blocks allows programs to define new external symbols in C.\n\n\nThe \ncompiler of C\u00e9u\n generates as output a program in C, which is\nembedded in a host program also in C, which is further compiled to the final\nbinary program.\n\n\nThe contents of native blocks is not parsed by C\u00e9u, but copied unchanged to the\noutput in C depending on the modifier specified:\n\n\n\n\npre\n: code is placed before the declarations for the C\u00e9u program.\n    Symbols defined in \npre\n blocks are visible to C\u00e9u.\n\n\npos\n: code is placed after the declarations for the C\u00e9u program.\n    Symbols defined by C\u00e9u are visible to \npos\n blocks.\n\n\n\n\nNative blocks are copied in the order they appear in the source code.\n\n\nSince C\u00e9u uses the \nC preprocessor\n, \n#\n directives inside native blocks\nmust use \n##\n directives to be considered only in the C compilation phase.\n\n\nSymbols defined in native blocks still need to be \ndeclared\n for use in\nthe program.\n\n\nExamples:\n\n\nnative/plain _t;\nnative/pre do\n    typedef int t;              // definition for \nt\n is placed before C\u00e9u declarations\nend\nvar _t x = 10;                  // requires \nt\n to be already defined\n\n\n\n\ninput void A;                   // declaration for \nA\n is placed before \npos\n blocks\nnative _get_A_id;\nnative/pos do\n    int get_A_id (void) {\n        return CEU_INPUT_A;     // requires \nA\n to be already declared\n    }\nend\n\n\n\n\nnative/nohold _printf;\nnative/pre do\n    ##include \nstdio.h\n         // include the relevant header for \nprintf\n\nend\n\n\n\n\nNative Statement\n\n\nThe contents of native statements in between \n{\n and \n}\n are inlined in the\nprogram.\n\n\nNative statements support interpolation of expressions in C\u00e9u which are\nexpanded when preceded by a \n@\n.\n\n\nExamples:\n\n\nvar int v_ceu = 10;\n{\n    int v_c = @v_ceu * 2;       // yields 20\n}\nv_ceu = { v_c + @v_ceu };       // yields 30\n{\n    printf(\n%d\\n\n, @v_ceu);     // prints 30\n}\n\n\n\n\nNative Call\n\n\nLocations and expressions that evaluate to a \nnative type\n can be called\nfrom C\u00e9u.\n\n\nIf a call passes or returns pointers, it may require an accompanying\n\nfinalization statement\n.\n\n\nExamples:\n\n\n// all expressions evaluate to a native type and can be called\n\n_printf(\nHello World!\\n\n);\n\nvar _t f = \n...\n;\nf();\n\nvar _s s = \n...\n;\ns.f();\n\n\n\n\nTODO: ex. pointer return\n\n\nFinalization\n\n\nThe finalization statement unconditionally executes a series of statements when\nits corresponding enclosing block terminates, even if aborted abruptly.\n\n\nC\u00e9u tracks the interaction of native calls with pointers and requires \n\nfinalize\n clauses to accompany them:\n\n\n\n\nIf C\u00e9u \npasses\n a pointer to a native call, the pointer represents a\n  \nlocal resource\n that requires finalization.\n  Finalization executes when the block of the local resource goes out of scope.\n\n\nIf C\u00e9u \nreceives\n a pointer from a native call return, the pointer\n  represents an \nexternal resource\n that requires finalization.\n  Finalization executes when the block of the receiving pointer goes out of\n  scope.\n\n\n\n\nIn both cases, the program does not compile without the \nfinalize\n statement.\n\n\nA \nfinalize\n cannot contain \nsynchronous control statements\n.\n\n\nExamples:\n\n\n// Local resource finalization\nwatching \n...\n do\n    var _buffer_t msg;\n    \n...\n                       // prepares msg\n    do\n        _send_request(\nmsg);\n    finalize with\n        _send_cancel(\nmsg);\n    end\n    await SEND_ACK;             // transmission is complete\nend\n\n\n\n\nIn the example above, the local variable \nmsg\n is an internal resource passed\nas a pointer to \n_send_request\n, which is an asynchronous call that transmits\nthe buffer in the background.\nIf the enclosing \nwatching\n aborts before awaking from the \nawait SEND_ACK\n,\nthe local \nmsg\n goes out of scope and the external transmission now holds a\n\ndangling pointer\n.\nThe \nfinalize\n ensures that \n_send_cancel\n also aborts the transmission.\n\n\n// External resource finalization\nwatching \n...\n do\n    var\n? _FILE f = _fopen(\n...\n) finalize with\n                        _fclose(f);\n                    end;\n    _fwrite(\n...\n, f);\n    await A;\n    _fwrite(\n...\n, f);\nend\n\n\n\n\nIn the example above, the call to \n_fopen\n returns an external file resource as\na pointer.\nIf the enclosing \nwatching\n aborts before awaking from the \nawait A\n, the file\nwould remain open as a \nmemory leak\n.\nThe \nfinalize\n ensures that \n_fclose\n closes the file properly.\n\n\nTODO\n\nAn external resource requires an \nalias assignment\n to an\n\noption \n?\n variable.\nIf the external call returns \nNULL\n, the alias is not set.\n\n\nNote: the compiler only forces the programmer to write finalization clauses,\n       but cannot check if they handle the resource properly.\n\n\nDeclaration modifiers\n and \ntypecasts\n may suppress the\nrequirement for finalization:\n\n\n\n\nnohold\n modifiers or \n/nohold\n typecasts make passing pointers safe.\n\n\npure\n   modifiers or \n/pure\n   typecasts make passing pointers and returning\n                                  pointers safe\n\n\n/plain\n typecasts make returns safe\n\n\n\n\nExamples:\n\n\n// \n_free\n does not retain \nptr\n\nnative/nohold _free;\n_free(ptr);\n// or\n(_free as /nohold)(ptr);\n\n\n\n\n// \n_strchr\n does retain \nptr\n or allocates resources\nnative/pure _strchr;\nvar _char\n found = _strchr(ptr);\n// or\nvar _char\n found = (_strchr as /pure)(ptr);\n\n\n\n\n// \n_f\n returns a non-pointer type\nvar _tp v = _f() as /plain;", 
            "title": "C Integration"
        }, 
        {
            "location": "/statements/c_integration/#c-integration", 
            "text": "C\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers when dealing with\nexternal resources.  C\u00e9u provides  native declarations  to import C symbols, native blocks  to define new code in C, native statements  to inline C statements, native calls  to call C functions,\nand  finalization  to deal with C pointers safely:  Nat_Symbol ::= native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\nNat_Block  ::= native `/\u00b4(pre|pos) do\n                    code definitions in C \n               end\nNat_End    ::= native `/\u00b4 end\n\nNat_Stmts  ::= `{\u00b4 { code in C  | `@\u00b4 Exp} `}\u00b4\n\nNat_Call   ::= [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\nList_Nat ::= LIST(ID_nat)\n\nFinalization ::= do [Stmt] Finalize\n              |  var ` ?\u00b4 Type ID_int `=\u00b4 ` \u00b4 (Call_Nat | Call_Code) Finalize\nFinalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                 Block\n             [ pause  with Block ]\n             [ resume with Block ]\n             end  Native calls and statements transfer the control of the CPU to inlined code in\nC, losing the guarantees of the  synchronous model .\nFor this reason, programs should only resort to C for asynchronous\nfunctionality, such as non-blocking I/O, or simple  struct  accessors, but\nnever for control purposes.  TODO: Nat_End", 
            "title": "C Integration"
        }, 
        {
            "location": "/statements/c_integration/#native-declaration", 
            "text": "In C\u00e9u, an  identifier  prefixed with an underscore is considered a\nnative symbol that is defined externally in C.\nHowever, all external symbols must be declared before their first use.  Native declarations support four modifiers as follows:   const : declares the listed symbols as constants.\n    Constants can be used as  bounded limits  in  vectors ,\n     pools , and  numeric loops .\n    Also, constants cannot be  assigned .  plain : declares the listed symbols as  plain  types, i.e., types (or\n    composite types) that do not contain pointers.\n    Value of plain types passed as arguments to functions do not require\n     finalization .  nohold : declares the listed symbols as  non-holding  functions, i.e.,\n    a function that does not retain received pointers as arguments after\n    returning.\n    Pointers passed to non-holding functions do not require\n     finalization .  pure : declares the listed symbols as pure functions.\n    In addition to the  nohold  properties, pure functions never allocate\n    resources that require  finalization  and have no side effects to\n    take into account for the  safety checks .   Examples:  // values\nnative/const  _LOW, _HIGH;      // Arduino's  LOW  and  HIGH  are constants\nnative        _errno;           // POSIX's  errno  is a global variable\n\n// types\nnative/plain  _char;            //  char  is a  plain  type\nnative        _SDL_PixelFormat; // SDL's  SDL_PixelFormat  is a type holding a pointer\n\n// functions\nnative        _uv_read_start;   // Libuv's  uv_read_start  retains the received pointer\nnative/nohold _free;            // POSIX's  free  receives a pointer but does not retain it\nnative/pure   _strlen;          // POSIX's  strlen  is a  pure  function", 
            "title": "Native Declaration"
        }, 
        {
            "location": "/statements/c_integration/#native-block", 
            "text": "Native blocks allows programs to define new external symbols in C.  The  compiler of C\u00e9u  generates as output a program in C, which is\nembedded in a host program also in C, which is further compiled to the final\nbinary program.  The contents of native blocks is not parsed by C\u00e9u, but copied unchanged to the\noutput in C depending on the modifier specified:   pre : code is placed before the declarations for the C\u00e9u program.\n    Symbols defined in  pre  blocks are visible to C\u00e9u.  pos : code is placed after the declarations for the C\u00e9u program.\n    Symbols defined by C\u00e9u are visible to  pos  blocks.   Native blocks are copied in the order they appear in the source code.  Since C\u00e9u uses the  C preprocessor ,  #  directives inside native blocks\nmust use  ##  directives to be considered only in the C compilation phase.  Symbols defined in native blocks still need to be  declared  for use in\nthe program.  Examples:  native/plain _t;\nnative/pre do\n    typedef int t;              // definition for  t  is placed before C\u00e9u declarations\nend\nvar _t x = 10;                  // requires  t  to be already defined  input void A;                   // declaration for  A  is placed before  pos  blocks\nnative _get_A_id;\nnative/pos do\n    int get_A_id (void) {\n        return CEU_INPUT_A;     // requires  A  to be already declared\n    }\nend  native/nohold _printf;\nnative/pre do\n    ##include  stdio.h          // include the relevant header for  printf \nend", 
            "title": "Native Block"
        }, 
        {
            "location": "/statements/c_integration/#native-statement", 
            "text": "The contents of native statements in between  {  and  }  are inlined in the\nprogram.  Native statements support interpolation of expressions in C\u00e9u which are\nexpanded when preceded by a  @ .  Examples:  var int v_ceu = 10;\n{\n    int v_c = @v_ceu * 2;       // yields 20\n}\nv_ceu = { v_c + @v_ceu };       // yields 30\n{\n    printf( %d\\n , @v_ceu);     // prints 30\n}", 
            "title": "Native Statement"
        }, 
        {
            "location": "/statements/c_integration/#native-call", 
            "text": "Locations and expressions that evaluate to a  native type  can be called\nfrom C\u00e9u.  If a call passes or returns pointers, it may require an accompanying finalization statement .  Examples:  // all expressions evaluate to a native type and can be called\n\n_printf( Hello World!\\n );\n\nvar _t f =  ... ;\nf();\n\nvar _s s =  ... ;\ns.f();  TODO: ex. pointer return", 
            "title": "Native Call"
        }, 
        {
            "location": "/statements/c_integration/#finalization", 
            "text": "The finalization statement unconditionally executes a series of statements when\nits corresponding enclosing block terminates, even if aborted abruptly.  C\u00e9u tracks the interaction of native calls with pointers and requires  finalize  clauses to accompany them:   If C\u00e9u  passes  a pointer to a native call, the pointer represents a\n   local resource  that requires finalization.\n  Finalization executes when the block of the local resource goes out of scope.  If C\u00e9u  receives  a pointer from a native call return, the pointer\n  represents an  external resource  that requires finalization.\n  Finalization executes when the block of the receiving pointer goes out of\n  scope.   In both cases, the program does not compile without the  finalize  statement.  A  finalize  cannot contain  synchronous control statements .  Examples:  // Local resource finalization\nwatching  ...  do\n    var _buffer_t msg;\n     ...                        // prepares msg\n    do\n        _send_request( msg);\n    finalize with\n        _send_cancel( msg);\n    end\n    await SEND_ACK;             // transmission is complete\nend  In the example above, the local variable  msg  is an internal resource passed\nas a pointer to  _send_request , which is an asynchronous call that transmits\nthe buffer in the background.\nIf the enclosing  watching  aborts before awaking from the  await SEND_ACK ,\nthe local  msg  goes out of scope and the external transmission now holds a dangling pointer .\nThe  finalize  ensures that  _send_cancel  also aborts the transmission.  // External resource finalization\nwatching  ...  do\n    var ? _FILE f = _fopen( ... ) finalize with\n                        _fclose(f);\n                    end;\n    _fwrite( ... , f);\n    await A;\n    _fwrite( ... , f);\nend  In the example above, the call to  _fopen  returns an external file resource as\na pointer.\nIf the enclosing  watching  aborts before awaking from the  await A , the file\nwould remain open as a  memory leak .\nThe  finalize  ensures that  _fclose  closes the file properly.  TODO \nAn external resource requires an  alias assignment  to an option  ?  variable.\nIf the external call returns  NULL , the alias is not set.  Note: the compiler only forces the programmer to write finalization clauses,\n       but cannot check if they handle the resource properly.  Declaration modifiers  and  typecasts  may suppress the\nrequirement for finalization:   nohold  modifiers or  /nohold  typecasts make passing pointers safe.  pure    modifiers or  /pure    typecasts make passing pointers and returning\n                                  pointers safe  /plain  typecasts make returns safe   Examples:  //  _free  does not retain  ptr \nnative/nohold _free;\n_free(ptr);\n// or\n(_free as /nohold)(ptr);  //  _strchr  does retain  ptr  or allocates resources\nnative/pure _strchr;\nvar _char  found = _strchr(ptr);\n// or\nvar _char  found = (_strchr as /pure)(ptr);  //  _f  returns a non-pointer type\nvar _tp v = _f() as /plain;", 
            "title": "Finalization"
        }, 
        {
            "location": "/statements/lua_integration/", 
            "text": "Lua Integration\n\n\nC\u00e9u also integrates with Lua, providing \nLua states\n to delimit the\neffects of \nLua statements\n which can be inlined in programs:\n\n\nLua_State ::= lua `[\u00b4 [Exp] `]\u00b4 do\n                 Block\n              end\nLua_Stmts ::= `[\u00b4 {`=\u00b4} `[\u00b4\n                  { {\ncode in Lua\n | `@\u00b4 Exp} }\n              `]\u00b4 {`=\u00b4} `]\u00b4\n\n\n\n\nLua statements transfer the control of the CPU to Lua, losing the guarantees of\nthe \nsynchronous model\n.\nLike \nnative statements\n, programs should only resort to Lua for\nasynchronous functionality, such as non-blocking I/O, or simple \nstruct\n\naccessors, but never for control purposes.\n\n\nLua Statement\n\n\nThe contents of Lua statements in between \n[[\n and \n]]\n are inlined in the\nprogram.\n\n\nLike \nnative statements\n, Lua statements support interpolation of\nexpressions in C\u00e9u which are expanded when preceded by a \n@\n.\n\n\nLua statements only affect the \nLua state\n in which they are embedded.\n\n\nIf a Lua statement is used in an \nassignment\n, it is evaluated as an\nexpression that either satisfies the destination or generates a runtime error.\nThe list that follows specifies the \nC\u00e9u destination\n and expected\n\nLua source\n:\n\n\n\n\na \nvar\n \nbool\n              expects a \nboolean\n\n\na \nnumeric\n \nvar\n    expects a \nnumber\n\n\na pointer \nvar\n             expects a \nlightuserdata\n\n\na \nvector\n \nbyte\n           expects a \nstring\n\n\n\n\nTODO: lua state captures errors\n\n\nExamples:\n\n\nvar int v_ceu = 10;\n[[\n    v_lua = @v_ceu * 2          -- yields 20\n]]\nv_ceu = [[ v_lua + @v_ceu ]];   // yields 30\n[[\n    print(@v_ceu)               -- prints 30\n]]\n\n\n\n\nLua State\n\n\nA Lua state creates a separate environment for its embedded\n\nLua statements\n.\n\n\nPrograms have an implicit enclosing \nglobal Lua state\n which all orphan\nstatements apply.\n\n\nExamples:\n\n\n// \nv\n is not shared between the two statements\npar do\n    // global Lua state\n    [[ v = 0 ]];\n    var int v = 0;\n    every 1s do\n        [[print('Lua 1', v, @v) ]];\n        v = v + 1;\n        [[ v = v + 1 ]];\n    end\nwith\n    // local Lua state\n    lua[] do\n        [[ v = 0 ]];\n        var int v = 0;\n        every 1s do\n            [[print('Lua 2', v, @v) ]];\n            v = v + 1;\n            [[ v = v + 1 ]];\n        end\n    end\nend\n\n\n\n\nTODO: dynamic scope, assignment/error, [dim]", 
            "title": "Lua Integration"
        }, 
        {
            "location": "/statements/lua_integration/#lua-integration", 
            "text": "C\u00e9u also integrates with Lua, providing  Lua states  to delimit the\neffects of  Lua statements  which can be inlined in programs:  Lua_State ::= lua `[\u00b4 [Exp] `]\u00b4 do\n                 Block\n              end\nLua_Stmts ::= `[\u00b4 {`=\u00b4} `[\u00b4\n                  { { code in Lua  | `@\u00b4 Exp} }\n              `]\u00b4 {`=\u00b4} `]\u00b4  Lua statements transfer the control of the CPU to Lua, losing the guarantees of\nthe  synchronous model .\nLike  native statements , programs should only resort to Lua for\nasynchronous functionality, such as non-blocking I/O, or simple  struct \naccessors, but never for control purposes.", 
            "title": "Lua Integration"
        }, 
        {
            "location": "/statements/lua_integration/#lua-statement", 
            "text": "The contents of Lua statements in between  [[  and  ]]  are inlined in the\nprogram.  Like  native statements , Lua statements support interpolation of\nexpressions in C\u00e9u which are expanded when preceded by a  @ .  Lua statements only affect the  Lua state  in which they are embedded.  If a Lua statement is used in an  assignment , it is evaluated as an\nexpression that either satisfies the destination or generates a runtime error.\nThe list that follows specifies the  C\u00e9u destination  and expected Lua source :   a  var   bool               expects a  boolean  a  numeric   var     expects a  number  a pointer  var              expects a  lightuserdata  a  vector   byte            expects a  string   TODO: lua state captures errors  Examples:  var int v_ceu = 10;\n[[\n    v_lua = @v_ceu * 2          -- yields 20\n]]\nv_ceu = [[ v_lua + @v_ceu ]];   // yields 30\n[[\n    print(@v_ceu)               -- prints 30\n]]", 
            "title": "Lua Statement"
        }, 
        {
            "location": "/statements/lua_integration/#lua-state", 
            "text": "A Lua state creates a separate environment for its embedded Lua statements .  Programs have an implicit enclosing  global Lua state  which all orphan\nstatements apply.  Examples:  //  v  is not shared between the two statements\npar do\n    // global Lua state\n    [[ v = 0 ]];\n    var int v = 0;\n    every 1s do\n        [[print('Lua 1', v, @v) ]];\n        v = v + 1;\n        [[ v = v + 1 ]];\n    end\nwith\n    // local Lua state\n    lua[] do\n        [[ v = 0 ]];\n        var int v = 0;\n        every 1s do\n            [[print('Lua 2', v, @v) ]];\n            v = v + 1;\n            [[ v = v + 1 ]];\n        end\n    end\nend  TODO: dynamic scope, assignment/error, [dim]", 
            "title": "Lua State"
        }, 
        {
            "location": "/statements/abstractions/", 
            "text": "Abstractions\n\n\nC\u00e9u supports reuse with \ndata\n declarations to define new types, and \ncode\n\ndeclarations to define new subprograms.\nDeclarations have \nlexical scope\n.\n\n\nData\n\n\nThe \ndata\n declaration creates a new data type:\n\n\nData ::= data ID_abs [as (nothing|Exp)] [ with\n             { \nvar_set|vector_set|pool_set|event_set\n `;\u00b4 {`;\u00b4} }\n         end ]\n\nData_Cons ::= (val|new) Abs_Cons\nAbs_Cons  ::= ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4\n\n\n\n\nA declaration may include fields with \nstorage declarations\n which\nare included in the \ndata\n type and are publicly accessible.\nField declarations may \nassign\n default values for uninitialized\ninstances.\n\n\nData types can form hierarchies using dots (\n.\n) in identifiers:\n\n\n\n\nAn identifier like \nA\n makes \nA\n a base type.\n\n\nAn identifier like \nA.B\n makes \nA.B\n a subtype of its supertype \nA\n.\n\n\n\n\nA subtype inherits all fields from its supertype.\n\n\nThe optional \nas\n modifier expects \nnothing\n or a constant expression of type\n\nint\n:\n\n\n\n\nnothing\n: the \ndata\n cannot be instantiated.\n\n\nconstant expression\n: typecasting a value of the type to \nint\n evaluates to\n                         the specified expression.\n\n\n\n\nExamples:\n\n\ndata Rect with\n    var int x, y, h, w;\n    var int z = 0;\nend\nvar Rect r = val Rect(10,10, 100,100, _);  // \nr.z\n defaults to 0\n\n\n\n\ndata Dir       as nothing;  // \nDir\n is a base type and cannot be intantiated\ndata Dir.Right as  1;       // \nDir.Right\n is a subtype of \nDir\n\ndata Dir.Left  as -1;       // \nDir.Left\n  is a subtype of \nDir\n\nvar  Dir dir = \n...\n;       // receives one of \nDir.Right\n or \nDir.Left\n\nescape (dir as int);        // returns 1 or -1\n\n\n\n\nTODO: new, pool, recursive types\n\n\nData Constructor\n\n\nA new \nstatic value\n is created with the \ndata\n name followed by a list of\narguments matching its fields in the contexts as follows:\n\n\n\n\nPrefixed by \nval\n in an \nassignment\n to a variable.\n\n\nAs an argument to a \ncode\n instantiation\n.\n\n\nNested as an argument in a \ndata\n creation.\n\n\n\n\nIn all cases, the arguments are copied to an explicit destination with static\nstorage.\nThe destination must be a plain declaration, and not an alias or pointer.\n\n\nVariables of the exact same type can be copied in \nassignments\n.\nThe rules for assignments from a subtype to a supertype are as follows:\n\n\n\n\nCopy assignments\n for plain values is only allowed if the subtype\n                            is the same size as the supertype (i.e., no extra\n                            fields).\n\n\nCopy assignments\n for pointers is allowed.\n\n\nAlias assignment\n is allowed.\n\n\n\n\ndata Object with\n    var Rect rect;\n    var Dir  dir;\nend\nvar Object o1 = val Object(Rect(0,0,10,10,_), Dir.Right());\n\n\n\n\nvar Object o2 = o1;         // makes a deep copy of all fields from \no1\n to \no2\n\n\n\n\n\nCode\n\n\nThe \ncode/tight\n and \ncode/await\n declarations create new subprograms that can\nbe \ninvoked\n from arbitrary points in programs:\n\n\n// prototype declaration\nCode_Tight ::= code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `-\n\u00b4 Type\nCode_Await ::= code/await Mods ID_abs `(\u00b4 Params `)\u00b4 [`-\n\u00b4 `(\u00b4 Inits `)\u00b4] `-\n\u00b4 (Type | FOREVER)\n\n// full declaration\nCode_Impl ::= (Code_Tight | Code_Await) do\n                  Block\n              end\n\nMods ::= [`/\u00b4dynamic] [`/\u00b4recursive]\n\nParams ::= void | LIST(Class [ID_int])\nClass  ::= [dynamic] var   [`\n\u00b4] [`/\u00b4hold] * Type\n        |            vector `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n        |            pool   `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n        |            event  `\n\u00b4 (Type | `(\u00b4 LIST(Type) `)\u00b4)\n\nInits ::= void | LIST(Class [ID_int])\nClass ::= var    (`\n\u00b4|`\n?`) * Type\n       |  vector (`\n\u00b4|`\n?`) `[\u00b4 [Exp] `]\u00b4 Type\n       |  pool   (`\n\u00b4|`\n?`) `[\u00b4 [Exp] `]\u00b4 Type\n       |  event  (`\n\u00b4|`\n?`) (Type | `(\u00b4 LIST(Type) `)\u00b4)\n\n// invocation\nCode_Call  ::= call  Mods Abs_Cons\nCode_Await ::= await Mods Code_Cons_Init\nCode_Spawn ::= spawn Mods Code_Cons_Init [in Loc]\n\nMods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\nCode_Cons_Init ::= Abs_Cons [`-\n\u00b4 `(\u00b4 LIST(`\n\u00b4 Var) `)\u00b4])\n\n\n\n\nA \ncode/tight\n is a subprogram that cannot contain\n\nsynchronous control statements\n and runs to completion in the current\n\ninternal reaction\n.\n\n\nA \ncode/await\n is a subprogram with no restrictions (e.g., it can manipulate\nevents and use parallel compositions) and its execution may outlive multiple\nreactions.\n\n\nA \nprototype declaration\n specifies the interface parameters of the\nabstraction which code invocations must satisfy.\nA \nfull declaration\n (a.k.a. \ndefinition\n) also specifies an implementation\nwith a block of code.\nAn \ninvocation\n specifies the name of the code abstraction and arguments\nmatching its declaration.\n\n\nTo support recursive abstractions, a code invocation can appear before the\nimplementation is known, but after the prototype declaration.\nIn this case, the declaration must use the modifier \nrecursive\n.\n\n\nExamples:\n\n\ncode/tight Absolute (var int v) -\n int do   // declares the prototype for \nAbsolute\n\n    if v \n 0 then                           // implements the behavior\n        escape  v;\n    else\n        escape -v;\n    end\nend\nvar int abs = call Absolute(-10);           // invokes \nAbsolute\n (yields 10)\n\n\n\n\ncode/await Hello_World (void) -\n FOREVER do\n    every 1s do\n        _printf(\nHello World!\\n\n);  // prints \nHello World!\n every second\n    end\nend\nawait Hello_World();                // never awakes\n\n\n\n\ncode/tight/recursive Fat (var int v) -\n int;    // \nFat\n is a recursive code\ncode/tight/recursive Fat (var int v) -\n int do\n    if v \n 1 then\n        escape v * (call/recursive Fat(v-1));   // recursive invocation before full declaration\n    else\n        escape 1;\n    end\nend\nvar int fat = call/recursive Fat(10);           // invokes \nFat\n (yields 3628800)\n\n\n\n\nTODO: hold\n\n\nCode Declaration\n\n\nCode abstractions specify a list of input parameters in between \n(\n and \n)\n.\nEach parameter specifies a \nstorage class\n with modifiers, a type and\nan identifier (optional in declarations).\nA \nvoid\n list specifies that the code has no parameters.\n\n\nCode abstractions also specify an output return type.\nA \ncode/await\n may use \nFOREVER\n to indicate that the code never returns.\n\n\nA \ncode/await\n may also specify an optional \ninitialization return list\n, which\nrepresents local resources created in the outermost scope of its body.\nThese resources are exported and bound to aliases in the invoking context which\nmay access them while the code executes:\n\n\n\n\nThe invoker passes a list of unbound aliases to the code.\n\n\nThe code \nbinds\n the aliases to the local resources before any\n  \nsynchronous control statement\n executes.\n\n\n\n\nIf the code does not terminate (i.e., return type is \nFOREVER\n), the\ninitialization list specifies normal \n aliases.\nOtherwise, since the code may terminate and deallocated the resource, the list\nmust specify option \n?\n aliases.\n\n\nExamples:\n\n\n// \nOpen\n abstracts\ncode/await Open (var _char\n path) -\n (var\n _FILE res) -\n FOREVER do\n    var\n? _FILE res_ = _fopen(path, \n...\n)  // allocates resource\n                       finalize with\n                           _fclose(res_!);  // releases resource\n                       end;\n    res = \nres_!;                           // exports resource to invoker\n    await FOREVER;\nend\n\nvar\n _FILE res;                             // declares resource\nspawn Open(\n...\n) -\n (\nres);                // initiliazes resource\n\n...\n                                       // uses resource\n\n\n\n\nCode Invocation\n\n\nA \ncode/tight\n is invoked with a \ncall\n followed by the abstraction name and\nlist of arguments.\nA \ncode/await\n is invoked with an \nawait\n or \nspawn\n followed by the\nabstraction name and list of arguments.\n\n\nThe list of arguments must satisfy the list of parameters in the\n\ncode declaration\n.\n\n\nThe \ncall\n and \nawait\n invocations suspend the ongoing computation and transfer\nthe execution control to the code abstraction.\nThe invoking point only resumes after the abstraction terminates and evaluates\nto a value of the \nreturn type\n which can be captured with an optional\n\nassignment\n.\n\n\nThe \nspawn\n invocation also suspends and transfers control to the code\nabstraction.\nHowever, when the abstraction becomes idle (or terminates), the invoking point\nresumes.\nThis allows the invocation point and the abstraction to execute concurrently.\n\n\nThe \nspawn\n invocation accepts an optional list of aliases matching the\n\ninitialization list\n in the code abstraction.\nThese aliases are bound to local resources in the code and can be accessed\nfrom the invocation point.\n\n\nThe \nspawn\n invocation also accepts an optional \npool\n which provides\nstorage and scope for invoked abstractions.\nIn this case, the invocation evaluates to a boolean that indicates if the pool\nhas space to execute the code.\nThe result can be captured with an optional \nassignment\n.\nIf the pool goes out of scope, all invoked abstractions invoked at that pool\nare aborted.\nIf the \nspawn\n omits the pool, the invocation always succeed and has the same\nscope as the invoking point: when the enclosing block terminates, the invoked\ncode is aborted.\n\n\nDynamic Dispatching\n\n\nC\u00e9u supports dynamic code dispatching based on multiple parameters.\n\n\nThe \n/dynamic\n modifier in a declaration specifies that the code is dynamically\ndispatched.\nA dynamic code must have at least one \ndynamic\n parameter.\nAlso, all dynamic parameters must be pointers or aliases to a\n\ndata type\n in some hierarchy.\n\n\nA dynamic declaration requires other compatible dynamic declarations with the\nsame name, modifiers, parameters, and return type.\nThe exceptions are the \ndynamic\n parameters, which must be in the same\nhierarchy of their corresponding parameters in other declarations.\n\n\nTo determine which declaration to execute during runtime, the actual argument\nis checked against the first formal \ndynamic\n parameter of each declaration.\nThe declaration with the most specific type matching the argument wins.\nIn the case of a tie, the next dynamic parameter is checked.\n\n\nA \ncatchall\n declaration with the most general dynamic types must always be\nprovided.\n\n\nExamples:\n\n\ndata Media as nothing;\ndata Media.Audio with \n...\n end\ndata Media.Video with \n...\n end\n\ncode/await/dynamic Play (dynamic var\n Media media) -\n void do\n    _assert(0);             // never dispatched\nend\ncode/await/dynamic Play (dynamic var\n Media.Audio media) -\n void do\n    \n...\n                   // plays an audio\nend\ncode/await/dynamic Play (dynamic var\n Media.Video media) -\n void do\n    \n...\n                   // plays a video\nend\n\nvar\n Media m = \n...\n;       // receives one of \nMedia.Audio\n or \nMedia.Video\n\nawait/dynamic Play(\nm);     // dispatches the appropriate subprogram to play the media", 
            "title": "Abstraction"
        }, 
        {
            "location": "/statements/abstractions/#abstractions", 
            "text": "C\u00e9u supports reuse with  data  declarations to define new types, and  code \ndeclarations to define new subprograms.\nDeclarations have  lexical scope .", 
            "title": "Abstractions"
        }, 
        {
            "location": "/statements/abstractions/#data", 
            "text": "The  data  declaration creates a new data type:  Data ::= data ID_abs [as (nothing|Exp)] [ with\n             {  var_set|vector_set|pool_set|event_set  `;\u00b4 {`;\u00b4} }\n         end ]\n\nData_Cons ::= (val|new) Abs_Cons\nAbs_Cons  ::= ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4  A declaration may include fields with  storage declarations  which\nare included in the  data  type and are publicly accessible.\nField declarations may  assign  default values for uninitialized\ninstances.  Data types can form hierarchies using dots ( . ) in identifiers:   An identifier like  A  makes  A  a base type.  An identifier like  A.B  makes  A.B  a subtype of its supertype  A .   A subtype inherits all fields from its supertype.  The optional  as  modifier expects  nothing  or a constant expression of type int :   nothing : the  data  cannot be instantiated.  constant expression : typecasting a value of the type to  int  evaluates to\n                         the specified expression.   Examples:  data Rect with\n    var int x, y, h, w;\n    var int z = 0;\nend\nvar Rect r = val Rect(10,10, 100,100, _);  //  r.z  defaults to 0  data Dir       as nothing;  //  Dir  is a base type and cannot be intantiated\ndata Dir.Right as  1;       //  Dir.Right  is a subtype of  Dir \ndata Dir.Left  as -1;       //  Dir.Left   is a subtype of  Dir \nvar  Dir dir =  ... ;       // receives one of  Dir.Right  or  Dir.Left \nescape (dir as int);        // returns 1 or -1  TODO: new, pool, recursive types", 
            "title": "Data"
        }, 
        {
            "location": "/statements/abstractions/#data-constructor", 
            "text": "A new  static value  is created with the  data  name followed by a list of\narguments matching its fields in the contexts as follows:   Prefixed by  val  in an  assignment  to a variable.  As an argument to a  code  instantiation .  Nested as an argument in a  data  creation.   In all cases, the arguments are copied to an explicit destination with static\nstorage.\nThe destination must be a plain declaration, and not an alias or pointer.  Variables of the exact same type can be copied in  assignments .\nThe rules for assignments from a subtype to a supertype are as follows:   Copy assignments  for plain values is only allowed if the subtype\n                            is the same size as the supertype (i.e., no extra\n                            fields).  Copy assignments  for pointers is allowed.  Alias assignment  is allowed.   data Object with\n    var Rect rect;\n    var Dir  dir;\nend\nvar Object o1 = val Object(Rect(0,0,10,10,_), Dir.Right());  var Object o2 = o1;         // makes a deep copy of all fields from  o1  to  o2", 
            "title": "Data Constructor"
        }, 
        {
            "location": "/statements/abstractions/#code", 
            "text": "The  code/tight  and  code/await  declarations create new subprograms that can\nbe  invoked  from arbitrary points in programs:  // prototype declaration\nCode_Tight ::= code/tight Mods ID_abs `(\u00b4 Params `)\u00b4 `- \u00b4 Type\nCode_Await ::= code/await Mods ID_abs `(\u00b4 Params `)\u00b4 [`- \u00b4 `(\u00b4 Inits `)\u00b4] `- \u00b4 (Type | FOREVER)\n\n// full declaration\nCode_Impl ::= (Code_Tight | Code_Await) do\n                  Block\n              end\n\nMods ::= [`/\u00b4dynamic] [`/\u00b4recursive]\n\nParams ::= void | LIST(Class [ID_int])\nClass  ::= [dynamic] var   [` \u00b4] [`/\u00b4hold] * Type\n        |            vector ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n        |            pool   ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n        |            event  ` \u00b4 (Type | `(\u00b4 LIST(Type) `)\u00b4)\n\nInits ::= void | LIST(Class [ID_int])\nClass ::= var    (` \u00b4|` ?`) * Type\n       |  vector (` \u00b4|` ?`) `[\u00b4 [Exp] `]\u00b4 Type\n       |  pool   (` \u00b4|` ?`) `[\u00b4 [Exp] `]\u00b4 Type\n       |  event  (` \u00b4|` ?`) (Type | `(\u00b4 LIST(Type) `)\u00b4)\n\n// invocation\nCode_Call  ::= call  Mods Abs_Cons\nCode_Await ::= await Mods Code_Cons_Init\nCode_Spawn ::= spawn Mods Code_Cons_Init [in Loc]\n\nMods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\nCode_Cons_Init ::= Abs_Cons [`- \u00b4 `(\u00b4 LIST(` \u00b4 Var) `)\u00b4])  A  code/tight  is a subprogram that cannot contain synchronous control statements  and runs to completion in the current internal reaction .  A  code/await  is a subprogram with no restrictions (e.g., it can manipulate\nevents and use parallel compositions) and its execution may outlive multiple\nreactions.  A  prototype declaration  specifies the interface parameters of the\nabstraction which code invocations must satisfy.\nA  full declaration  (a.k.a.  definition ) also specifies an implementation\nwith a block of code.\nAn  invocation  specifies the name of the code abstraction and arguments\nmatching its declaration.  To support recursive abstractions, a code invocation can appear before the\nimplementation is known, but after the prototype declaration.\nIn this case, the declaration must use the modifier  recursive .  Examples:  code/tight Absolute (var int v) -  int do   // declares the prototype for  Absolute \n    if v   0 then                           // implements the behavior\n        escape  v;\n    else\n        escape -v;\n    end\nend\nvar int abs = call Absolute(-10);           // invokes  Absolute  (yields 10)  code/await Hello_World (void) -  FOREVER do\n    every 1s do\n        _printf( Hello World!\\n );  // prints  Hello World!  every second\n    end\nend\nawait Hello_World();                // never awakes  code/tight/recursive Fat (var int v) -  int;    //  Fat  is a recursive code\ncode/tight/recursive Fat (var int v) -  int do\n    if v   1 then\n        escape v * (call/recursive Fat(v-1));   // recursive invocation before full declaration\n    else\n        escape 1;\n    end\nend\nvar int fat = call/recursive Fat(10);           // invokes  Fat  (yields 3628800)  TODO: hold", 
            "title": "Code"
        }, 
        {
            "location": "/statements/abstractions/#code-declaration", 
            "text": "Code abstractions specify a list of input parameters in between  (  and  ) .\nEach parameter specifies a  storage class  with modifiers, a type and\nan identifier (optional in declarations).\nA  void  list specifies that the code has no parameters.  Code abstractions also specify an output return type.\nA  code/await  may use  FOREVER  to indicate that the code never returns.  A  code/await  may also specify an optional  initialization return list , which\nrepresents local resources created in the outermost scope of its body.\nThese resources are exported and bound to aliases in the invoking context which\nmay access them while the code executes:   The invoker passes a list of unbound aliases to the code.  The code  binds  the aliases to the local resources before any\n   synchronous control statement  executes.   If the code does not terminate (i.e., return type is  FOREVER ), the\ninitialization list specifies normal   aliases.\nOtherwise, since the code may terminate and deallocated the resource, the list\nmust specify option  ?  aliases.  Examples:  //  Open  abstracts\ncode/await Open (var _char  path) -  (var  _FILE res) -  FOREVER do\n    var ? _FILE res_ = _fopen(path,  ... )  // allocates resource\n                       finalize with\n                           _fclose(res_!);  // releases resource\n                       end;\n    res =  res_!;                           // exports resource to invoker\n    await FOREVER;\nend\n\nvar  _FILE res;                             // declares resource\nspawn Open( ... ) -  ( res);                // initiliazes resource ...                                        // uses resource", 
            "title": "Code Declaration"
        }, 
        {
            "location": "/statements/abstractions/#code-invocation", 
            "text": "A  code/tight  is invoked with a  call  followed by the abstraction name and\nlist of arguments.\nA  code/await  is invoked with an  await  or  spawn  followed by the\nabstraction name and list of arguments.  The list of arguments must satisfy the list of parameters in the code declaration .  The  call  and  await  invocations suspend the ongoing computation and transfer\nthe execution control to the code abstraction.\nThe invoking point only resumes after the abstraction terminates and evaluates\nto a value of the  return type  which can be captured with an optional assignment .  The  spawn  invocation also suspends and transfers control to the code\nabstraction.\nHowever, when the abstraction becomes idle (or terminates), the invoking point\nresumes.\nThis allows the invocation point and the abstraction to execute concurrently.  The  spawn  invocation accepts an optional list of aliases matching the initialization list  in the code abstraction.\nThese aliases are bound to local resources in the code and can be accessed\nfrom the invocation point.  The  spawn  invocation also accepts an optional  pool  which provides\nstorage and scope for invoked abstractions.\nIn this case, the invocation evaluates to a boolean that indicates if the pool\nhas space to execute the code.\nThe result can be captured with an optional  assignment .\nIf the pool goes out of scope, all invoked abstractions invoked at that pool\nare aborted.\nIf the  spawn  omits the pool, the invocation always succeed and has the same\nscope as the invoking point: when the enclosing block terminates, the invoked\ncode is aborted.", 
            "title": "Code Invocation"
        }, 
        {
            "location": "/statements/abstractions/#dynamic-dispatching", 
            "text": "C\u00e9u supports dynamic code dispatching based on multiple parameters.  The  /dynamic  modifier in a declaration specifies that the code is dynamically\ndispatched.\nA dynamic code must have at least one  dynamic  parameter.\nAlso, all dynamic parameters must be pointers or aliases to a data type  in some hierarchy.  A dynamic declaration requires other compatible dynamic declarations with the\nsame name, modifiers, parameters, and return type.\nThe exceptions are the  dynamic  parameters, which must be in the same\nhierarchy of their corresponding parameters in other declarations.  To determine which declaration to execute during runtime, the actual argument\nis checked against the first formal  dynamic  parameter of each declaration.\nThe declaration with the most specific type matching the argument wins.\nIn the case of a tie, the next dynamic parameter is checked.  A  catchall  declaration with the most general dynamic types must always be\nprovided.  Examples:  data Media as nothing;\ndata Media.Audio with  ...  end\ndata Media.Video with  ...  end\n\ncode/await/dynamic Play (dynamic var  Media media) -  void do\n    _assert(0);             // never dispatched\nend\ncode/await/dynamic Play (dynamic var  Media.Audio media) -  void do\n     ...                    // plays an audio\nend\ncode/await/dynamic Play (dynamic var  Media.Video media) -  void do\n     ...                    // plays a video\nend\n\nvar  Media m =  ... ;       // receives one of  Media.Audio  or  Media.Video \nawait/dynamic Play( m);     // dispatches the appropriate subprogram to play the media", 
            "title": "Dynamic Dispatching"
        }, 
        {
            "location": "/statements/synchronous_control_statements/", 
            "text": "Synchronous Control Statements\n\n\nThe \nsynchronous control statements\n\n\nawait\n, \nspawn\n, \nemit\n (internal events), \nevery\n, \nfinalize\n, \npause/if\n,\n\npar\n, \npar/and\n, \npar/or\n, and \nwatching\n\ncannot appear in\n\nevent iterators\n,\n\npool iterators\n,\n\nasynchronous execution\n,\n\nfinalization\n,\nand\n\ntight code abstractions\n.\n\n\nAs exceptions, an \nevery\n can \nemit\n internal events, and a \ncode/tight\n can\ncontain empty \nfinalize\n statements.", 
            "title": "Synchronous Control Statements"
        }, 
        {
            "location": "/statements/synchronous_control_statements/#synchronous-control-statements", 
            "text": "The  synchronous control statements  await ,  spawn ,  emit  (internal events),  every ,  finalize ,  pause/if , par ,  par/and ,  par/or , and  watching \ncannot appear in event iterators , pool iterators , asynchronous execution , finalization ,\nand tight code abstractions .  As exceptions, an  every  can  emit  internal events, and a  code/tight  can\ncontain empty  finalize  statements.", 
            "title": "Synchronous Control Statements"
        }, 
        {
            "location": "/expressions/", 
            "text": "TODO", 
            "title": "Expressions"
        }, 
        {
            "location": "/static_checks/", 
            "text": "TODO", 
            "title": "Static Checks"
        }, 
        {
            "location": "/environment/", 
            "text": "TODO", 
            "title": "Environment"
        }, 
        {
            "location": "/errors/", 
            "text": "TODO", 
            "title": "Errors"
        }, 
        {
            "location": "/syntax/", 
            "text": "Syntax\n\n\nFollows the complete syntax of C\u00e9u in a BNF-like syntax:\n\n\n\n\nA\n : non terminal (starting in uppercase)\n\n\na\n : terminal (in bold and lowercase)\n\n\n.\n : terminal (non-alphanumeric characters)\n\n\nA ::= ...\n : defines \nA\n as \n...\n\n\nx y\n : \nx\n in sequence with \ny\n\n\nx|y\n : \nx\n or \ny\n\n\n{x}\n : zero or more xs\n\n\n[x]\n : optional x\n\n\nLIST(x)\n : expands to \nx {\n,\n x} [\n,\n]\n\n\n(...)\n : groups \n...\n\n\n...\n : special informal rule\n\n\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(`_\u00b4|ID_int)]\n            Block\n        end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Classes */\n\n      | var [`\n\u00b4|`\n?\u00b4] Type LIST(ID_int [`=\u00b4 Cons])\n      | vector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\n      | pool [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\n      | event [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Cons])\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      | output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Loc) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\n\n      | lock Loc do\n            Block\n        end\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (`_\u00b4|ID_int) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `-\n\u00b4 (`_\u00b4|Exp))\n                        | ((`_\u00b4|Exp) `\n-\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Loc do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Loc|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      // Async_Thread ::=\n      | await async/thread [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n            \ncode definitions in C\n\n        end\n      | native `/\u00b4 end\n      | `{\u00b4 {\ncode in C\n | `@\u00b4 Exp} `}\u00b4\n\n      // Nat_Call ::=\n      | [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var `\n?\u00b4 Type ID_int `=\u00b4 `\n\u00b4 (Nat_Call | Code_Call) Finalize\n        // where\n            Finalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua_State ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      // Lua_Stmts ::=\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { {\ncode in Lua\n | `@\u00b4 Exp} }\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [as (nothing|Exp)] [ with\n            { \nvar_set|vector_set|pool_set|event_set\n `;\u00b4 {`;\u00b4} }\n        end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `-\n\u00b4 Type\n\n      // Code_Await ::=\n      | code/await [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 [ `-\n\u00b4 `(\u00b4 Inits `)\u00b4 ] `-\n\u00b4 (Type | FOREVER)\n        // where\n            Params ::= void | LIST(Class [ID_int])\n            Class ::= [dynamic] var    [`\n\u00b4] [`/\u00b4hold] * Type\n                   |            vector `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |            pool   `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |            event  `\n\u00b4 (Type | `(\u00b4 LIST(Type) `)\u00b4)\n            Inits ::= void | LIST(Class [ID_int])\n            Class ::= var    (`\n\u00b4|`\n?`) * Type\n                   |  vector (`\n\u00b4|`\n?`) `[\u00b4 [Exp] `]\u00b4 Type\n                   |  pool   (`\n\u00b4|`\n?`) `[\u00b4 [Exp] `]\u00b4 Type\n                   |  event  (`\n\u00b4|`\n?`) (Type | `(\u00b4 LIST(Type) `)\u00b4)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code invocation */\n\n      // Code_Call ::=\n      | call  Mods Abs_Cons\n\n      // Code_Await ::=\n      | await Mods Abs_Cons\n\n      // Code_Spawn ::=\n      | spawn Mods Code_Cons_Init [in Loc]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Abs_Cons ::= ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4\n            Code_Cons_Init ::= Abs_Cons [`-\n\u00b4 `(\u00b4 LIST(`\n\u00b4 Var) `)\u00b4])\n\n  /* Assignments */\n\n      | (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Cons\n        // where\n            Cons ::= ( Do\n                     | Emit_Ext\n                     | Watching\n                     | Async_Thread\n                     | Await\n                     | Lua_State\n                     | Lua_Stmts\n                     | Code_Await\n                     | Code_Spawn\n                     | Vec_Cons\n                     | Data_Cons\n                     | `_\u00b4\n                     | Exp )\n            Vec_Cons  ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4) }\n            Data_Cons ::= (val|new) Abs_Cons\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { `\n\u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Loc */\n\nLoc    ::= [`*\u00b4|`$\u00b4] Loc_01\nLoc_01 ::= Loc_02 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nLoc_02 ::= `(\u00b4 Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4 \ncode in C\n `}\u00b4\n\n/* Expressions */\n\nExp  ::= Prim (combined with the \nOperator Precedence\n below)\nPrim ::= `(\u00b4 Exp `)\u00b4\n      |  `\n\u00b4 Loc\n      |  Loc [`?\u00b4]\n      |  `\n\u00b4 (Nat_Call | Loc)\n      |  Nat_Call | Code_Call\n      |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n      |  NUM | STR | null | true | false\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::= \n [^\\\n\\n]* \n                        // regex\n\n/* Operator precedence */\n\n    /* lowest priority */\n    is    as\n    or\n    and\n    !=    ==    \n=    \n=    \n     \n\n    |\n    ^\n    \n\n    \n    \n\n    +     -\n    *     /     %\n    not   +    -    ~    $$\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive\n\n\n\n\n\nTODO: statements that do not require ;", 
            "title": "Syntax"
        }, 
        {
            "location": "/syntax/#syntax", 
            "text": "Follows the complete syntax of C\u00e9u in a BNF-like syntax:   A  : non terminal (starting in uppercase)  a  : terminal (in bold and lowercase)  .  : terminal (non-alphanumeric characters)  A ::= ...  : defines  A  as  ...  x y  :  x  in sequence with  y  x|y  :  x  or  y  {x}  : zero or more xs  [x]  : optional x  LIST(x)  : expands to  x { ,  x} [ , ]  (...)  : groups  ...  ...  : special informal rule   Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(`_\u00b4|ID_int)]\n            Block\n        end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Classes */\n\n      | var [` \u00b4|` ?\u00b4] Type LIST(ID_int [`=\u00b4 Cons])\n      | vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\n      | pool [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Cons])\n      | event [` \u00b4|` ?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Cons])\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      | output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Loc) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Loc [`(\u00b4 [LIST(Exp)] `)\u00b4]\n\n      | lock Loc do\n            Block\n        end\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (`_\u00b4|ID_int) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `- \u00b4 (`_\u00b4|Exp))\n                        | ((`_\u00b4|Exp) ` -\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Loc do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) in] (ID_ext|Loc|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Loc|WCLOCKK|WCLOCKE|Code_Cons_Init) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Loc|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      // Async_Thread ::=\n      | await async/thread [ `(\u00b4 LIST(Var) `)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n             code definitions in C \n        end\n      | native `/\u00b4 end\n      | `{\u00b4 { code in C  | `@\u00b4 Exp} `}\u00b4\n\n      // Nat_Call ::=\n      | [call] (Loc | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var ` ?\u00b4 Type ID_int `=\u00b4 ` \u00b4 (Nat_Call | Code_Call) Finalize\n        // where\n            Finalize ::= finalize `(\u00b4 LIST(Loc) `)\u00b4 with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua_State ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      // Lua_Stmts ::=\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { { code in Lua  | `@\u00b4 Exp} }\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [as (nothing|Exp)] [ with\n            {  var_set|vector_set|pool_set|event_set  `;\u00b4 {`;\u00b4} }\n        end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `- \u00b4 Type\n\n      // Code_Await ::=\n      | code/await [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 [ `- \u00b4 `(\u00b4 Inits `)\u00b4 ] `- \u00b4 (Type | FOREVER)\n        // where\n            Params ::= void | LIST(Class [ID_int])\n            Class ::= [dynamic] var    [` \u00b4] [`/\u00b4hold] * Type\n                   |            vector ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |            pool   ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |            event  ` \u00b4 (Type | `(\u00b4 LIST(Type) `)\u00b4)\n            Inits ::= void | LIST(Class [ID_int])\n            Class ::= var    (` \u00b4|` ?`) * Type\n                   |  vector (` \u00b4|` ?`) `[\u00b4 [Exp] `]\u00b4 Type\n                   |  pool   (` \u00b4|` ?`) `[\u00b4 [Exp] `]\u00b4 Type\n                   |  event  (` \u00b4|` ?`) (Type | `(\u00b4 LIST(Type) `)\u00b4)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code invocation */\n\n      // Code_Call ::=\n      | call  Mods Abs_Cons\n\n      // Code_Await ::=\n      | await Mods Abs_Cons\n\n      // Code_Spawn ::=\n      | spawn Mods Code_Cons_Init [in Loc]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Abs_Cons ::= ID_abs `(\u00b4 LIST(Data_Cons|Vec_Cons|Exp|`_\u00b4) `)\u00b4\n            Code_Cons_Init ::= Abs_Cons [`- \u00b4 `(\u00b4 LIST(` \u00b4 Var) `)\u00b4])\n\n  /* Assignments */\n\n      | (Loc | `(\u00b4 LIST(Loc|`_\u00b4) `)\u00b4) `=\u00b4 Cons\n        // where\n            Cons ::= ( Do\n                     | Emit_Ext\n                     | Watching\n                     | Async_Thread\n                     | Await\n                     | Lua_State\n                     | Lua_Stmts\n                     | Code_Await\n                     | Code_Spawn\n                     | Vec_Cons\n                     | Data_Cons\n                     | `_\u00b4\n                     | Exp )\n            Vec_Cons  ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua_Stmts | `[\u00b4 [LIST(Exp)] `]\u00b4) }\n            Data_Cons ::= (val|new) Abs_Cons\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID             // ID beginning with lowercase\nID_ext   ::= ID             // ID all in uppercase, not beginning with digit\nID_abs   ::= ID {`.\u00b4 ID}    // IDs beginning with uppercase, containining at least one lowercase)\nID_field ::= ID             // ID not beginning with digit\nID_nat   ::= ID             // ID beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { ` \u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Loc */\n\nLoc    ::= [`*\u00b4|`$\u00b4] Loc_01\nLoc_01 ::= Loc_02 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nLoc_02 ::= `(\u00b4 Loc [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4  code in C  `}\u00b4\n\n/* Expressions */\n\nExp  ::= Prim (combined with the  Operator Precedence  below)\nPrim ::= `(\u00b4 Exp `)\u00b4\n      |  ` \u00b4 Loc\n      |  Loc [`?\u00b4]\n      |  ` \u00b4 (Nat_Call | Loc)\n      |  Nat_Call | Code_Call\n      |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n      |  NUM | STR | null | true | false\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::=   [^\\ \\n]*                          // regex\n\n/* Operator precedence */\n\n    /* lowest priority */\n    is    as\n    or\n    and\n    !=    ==     =     =           \n    |\n    ^\n     \n          \n    +     -\n    *     /     %\n    not   +    -    ~    $$\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive  TODO: statements that do not require ;", 
            "title": "Syntax"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nC\u00e9u is distributed under the MIT license reproduced below:\n\n\n Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \nSoftware\n), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "C\u00e9u is distributed under the MIT license reproduced below:   Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the  Software ), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }
    ]
}