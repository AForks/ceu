<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  
  <title>Statements - Céu v0.20 - Reference Manual</title>
  

  <link rel="shortcut icon" href="../img/favicon.ico">

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../css/highlight.css">

  
  <script>
    // Current page data
    var mkdocs_page_name = "Statements";
    var mkdocs_page_input_path = "050-statements.md";
    var mkdocs_page_url = "/050-statements/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js"></script>
  <script src="../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../js/highlight.pack.js"></script>
  <script src="../js/theme.js"></script> 

  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Céu v0.20 - Reference Manual</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        <ul class="current">
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="..">Home</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../010-introduction/">Introduction</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../020-lexical_rules/">Lexical Rules</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../030-types/">Types</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../040-storage_classes/">Storage Classes</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 current">
        <a class="current" href="./">Statements</a>
        
            <ul>
            
                <li class="toctree-l3"><a href="#statements">Statements</a></li>
                
                    <li><a class="toctree-l4" href="#blocks">Blocks</a></li>
                
                    <li><a class="toctree-l4" href="#declarations">Declarations</a></li>
                
                    <li><a class="toctree-l4" href="#event-handling">Event Handling</a></li>
                
                    <li><a class="toctree-l4" href="#conditional">Conditional</a></li>
                
                    <li><a class="toctree-l4" href="#loops">Loops</a></li>
                
                    <li><a class="toctree-l4" href="#parallel-compositions">Parallel Compositions</a></li>
                
                    <li><a class="toctree-l4" href="#pausing_1">Pausing</a></li>
                
                    <li><a class="toctree-l4" href="#asynchronous-execution">Asynchronous Execution</a></li>
                
                    <li><a class="toctree-l4" href="#c-integration">C Integration</a></li>
                
                    <li><a class="toctree-l4" href="#lua-integration">Lua Integration</a></li>
                
                    <li><a class="toctree-l4" href="#abstractions">Abstractions</a></li>
                
            
            </ul>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../060-expressions/">Expressions</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../070-static_analysis/">Static Analysis</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../080-environment/">Environment</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../090-errors/">Errors</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../syntax/">Syntax</a>
        
    </li>
<li>
          
            <li>
    <li class="toctree-l1 ">
        <a class="" href="../license/">License</a>
        
    </li>
<li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Céu v0.20 - Reference Manual</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Statements</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="statements">Statements</h1>
<p>A program in Céu is a sequence of statements delimited by an enclosing block as
follows:</p>
<pre><code class="ceu">Program ::= Block
Block   ::= {Stmt `;´} {`;´}
</code></pre>

<p><em>Note: statements terminated with the <code>end</code> keyword do not require a
terminating semicolon.</em></p>
<h2 id="blocks">Blocks</h2>
<p>A <code>Block</code> creates a new scope for <a href="#TODO">storage entities</a> which are visible
only for statements inside the block.</p>
<p>Compound statements (e.g. <em>do-end</em>, <em>if-then-else</em>, <em>loops</em>, etc.) create new
blocks and can be nested to an arbitrary level.</p>
<h3 id="do-end-and-escape"><code>do-end</code> and <code>escape</code></h3>
<p>The <code>do-end</code> statement creates an explicit block with an optional identifier.
The <code>escape</code> statement aborts the deepest enclosing <code>do-end</code> matching its
identifier:</p>
<pre><code class="ceu">Do ::= do [`/´ (`_´|ID_int)]
           Block
       end

Escape ::= escape [`/´ID_int] [Exp]
</code></pre>

<p>A <code>do-end</code> supports the identifier <code>_</code> which is guaranteed not to match any
<code>escape</code> statement.</p>
<p>Example:</p>
<pre><code class="ceu">do/a
    do/_
        do
            escape;     // matches line 3
        end
        escape/a;       // matches line 1
    end
end
</code></pre>

<h3 id="pre-do-end"><code>pre-do-end</code></h3>
<p>The <code>pre-do-end</code> statement prepends its statements in the beginning of the
program:</p>
<pre><code class="ceu">Pre_Do ::= pre do
               Block
           end
</code></pre>

<p>All <code>pre-do-end</code> statements are concatenated together in the order they appear
and moved to the beginning of the top-level block, before all other statements.</p>
<hr />
<h2 id="declarations">Declarations</h2>
<p>A declaration exposes a <a href="#TODO">storage entity</a> to the program.
Its <a href="#TODO">scope</a> begins after the declaration and goes until the end of the
enclosing <a href="#TODO">block</a>.</p>
<p>Céu supports variables, vectors, external events, internal events, and pools:</p>
<pre><code class="ceu">Var    ::= var [`&amp;´|`&amp;?´] Type LIST(ID_int [`=´ Set])
Vector ::= vector [`&amp;´] `[´ [Exp] `]´ Type LIST(ID_int [`=´ Set])
Ext    ::= input  (Type | `(´ LIST(Type) `)´) LIST(ID_ext)
        |  output (Type | `(´ LIST(Type) `)´) LIST(ID_ext)
Int    ::= event [`&amp;´|`&amp;?´] (Type | `(´ LIST(Type) `)´) LIST(ID_int [`=´ Set])
Pool   ::= pool [`&amp;´] `[´ [Exp] `]´ Type LIST(ID_int [`=´ Set])
</code></pre>

<p>See also <a href="#TODO">Storage Classes</a> for an overview of storage entities.</p>
<h3 id="variables">Variables</h3>
<p>A variable has an associated <a href="#TODO">type</a> and can be optionally
<a href="#TODO">initialized</a>.
A single statement can declare multiple variables of the same type.
Declarations can also be <a href="#TODO">aliases</a> or <a href="#TODO">option aliases</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">var  int v = 10;    // &quot;v&quot; is an integer variable initialized to 10
var  int a=0, b=3;  // &quot;a&quot; and &quot;b&quot; are integer variables initialized to 0 and 3
var&amp; int z = &amp;v;    // &quot;z&quot; is an alias to &quot;v&quot;
</code></pre>

<h3 id="vectors">Vectors</h3>
<p>A vector has a dimension, an associated <a href="#TODO">type</a> and can be optionally
<a href="#TODO">initialized</a>.
A single statement can declare multiple vectors of the same dimension and type.
Declarations can also be <a href="#TODO">aliases</a>.</p>
<p>The expression between the brackets specifies the dimension of the vector with
the options that follow:</p>
<ul>
<li><em>constant expression</em>: Maximum number of elements is fixed and space is
                         statically pre-allocated.</li>
<li><em>variable expression</em>: Maximum number of elements is fixed but space is
                         dynamically allocated.
                         The expression is evaulated once at declaration time.</li>
<li><em>omitted</em>: Maximum number of elements is unbounded and space is dynamically
             allocated.</li>
</ul>
<p>The space for dynamic vectors grow and shrink automatically.</p>
<p>Examples:</p>
<pre><code class="ceu">var int n = 10;
vector[10] int vs1 = [];    // &quot;vs1&quot; is a static vector of 10 elements max
vector[n]  int vs2 = [];    // &quot;vs2&quot; is a dynamic vector of 10 elements max
vector[]   int vs3 = [];    // &quot;vs3&quot; is an unbounded vector
vector&amp;[]  int vs4 = &amp;vs1;  // &quot;vs4&quot; is an alias to &quot;vs1&quot;
</code></pre>

<h3 id="events">Events</h3>
<p>An event has a <a href="#TODO">type</a> for the value it carries when occurring.
It can be also a list of types if the event communicates multiple values.
A single statement can declare multiple events of the same type.</p>
<p>See also <a href="#TODO">Introduction</a> for a general overview of events.</p>
<h4 id="external-events">External events</h4>
<p>Examples:</p>
<pre><code class="ceu">input  void A,B;        // &quot;A&quot; and &quot;B&quot; are input events carrying no values
output int  MY_EVT;     // &quot;MY_EVT&quot; is an output event carrying integer values
input (int,byte&amp;&amp;) BUF; // &quot;BUF&quot; is an input event carrying an &quot;(int,byte&amp;&amp;)&quot; pair
</code></pre>

<h3 id="internal-events">Internal events</h3>
<p>Declarations for internal events can also be <a href="#TODO">aliases</a> or
<a href="#TODO">option aliases</a>.
Only in this case they can contain an <a href="#TODO">initialization</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">event  void a,b;        // &quot;a&quot; and &quot;b&quot; are internal events carrying no values
event&amp; void z = &amp;a;     // &quot;z&quot; is an alias to event &quot;a&quot;
event (int,int) c;      // &quot;c&quot; is a internal event carrying an &quot;(int,int)&quot; pair
</code></pre>

<h3 id="pools">Pools</h3>
<p><code>TODO</code></p>
<p>See also <a href="#TODO">Code Pools</a> and <a href="#TODO">Data Pools</a>.</p>
<hr />
<h2 id="event-handling">Event Handling</h2>
<h3 id="await">Await</h3>
<p>The <code>await</code> statement halts the running trail until the referred
event occurs.
The event can be an <a href="#TODO">external input event</a>, an <a href="#TODO">internal event</a>,
a timer, a <a href="#TODO">pausing event</a>, or forever (i.e., never awake):</p>
<pre><code class="ceu">Await ::= await (ID_ext | Name) [until Exp]     /* events */
       |  await (WCLOCKK|WCLOCKE)               /* timers */
       |  await (pause|resume)                  /* pausing events */
       |  await FOREVER                         /* forever */
</code></pre>

<p>Examples:</p>
<pre><code class="ceu">await A;                  // awaits the input event `A`
await a;                  // awaits the internal event `a`

await 1min10s30ms100us;   // awaits the specified time
await (t)ms;              // awaits the current value of the variable `t` in milliseconds

await FOREVER;            // awaits forever
</code></pre>

<p>An <code>await</code> evaluates to zero or more values which can be captured with an
optional <a href="#TODO">assignment</a>.</p>
<h4 id="events_1">Events</h4>
<p>The <code>await</code> statement for events halts the running trail until the referred
<a href="#TODO">external input event</a> or  <a href="#TODO">internal event</a> occurs.</p>
<p>The <code>await</code> evaluates to a value of the type of the event.</p>
<p>The optional clause <code>until</code> tests an additional condition required to awake.
The condition can use the returned value from the <code>await</code>.
It expands to a <a href="#TODO"><code>loop</code></a> as follows:</p>
<pre><code class="ceu">loop do
    &lt;ret&gt; = await &lt;evt&gt;;
    if &lt;Exp&gt; then   // &lt;Exp&gt; can use &lt;ret&gt;
        break;
    end
end
</code></pre>

<p>Examples:</p>
<pre><code class="ceu">input int E;                    // &quot;E&quot; is an external input event carrying &quot;int&quot; values
var int v = await E until v&gt;10; // assigns occurring &quot;E&quot; to &quot;v&quot;, awaking when &quot;v&gt;10&quot;

event (bool,int) e;             // &quot;e&quot; is an internal event carrying &quot;(bool,int)&quot; pairs
var bool v1;
var int  v2;
(v1,v2) = await e;              // awakes on &quot;e&quot; and assigns its values to &quot;v1&quot; and &quot;v2&quot;
</code></pre>

<h4 id="timers">Timers</h4>
<p>The <code>await</code> statement for timers halts the running trail until the referred
timer expires.</p>
<p><code>WCLOCKK</code> specifies a constant time expressed as a sequence of value/unit
pairs.
<code>WCLOCKE</code> specifies an expression in parenthesis followed by a single unit of
time.</p>
<p>The <code>await</code> evaluates to a value of type <code>s32</code> and is the
<em>residual delta time (<code>dt</code>)</em> measured in microseconds.
It is the difference between the actual elapsed time and the requested time.</p>
<p>If a program awaits timers in sequence (or in a <code>loop</code>), the residual <code>dt</code> from
the preceding timer is reduced from the timer in sequence.</p>
<p>Examples:</p>
<pre><code class="ceu">var int t = &lt;...&gt;;
await (t)ms;                // awakes after &quot;t&quot; milliseconds
</code></pre>

<pre><code class="ceu">var int dt = await 100us;   // if 1ms elapses,  1000&gt;100, dt=900us
await 100us;                // timer is expired, 900&gt;100, dt=800us
await 1ms;                  // timer only awaits 200us (1000-800)
</code></pre>

<p><em>Note: The residual <code>dt</code> is always greater than or equal to 0.</em></p>
<!--
Refer to [[#Environment]] for information about storage types for *wall-clock*
time.
-->

<h4 id="pausing">Pausing</h4>
<p>Pausing events are dicussed in <a href="#TODO">Pausing</a>.</p>
<h4 id="forever"><code>FOREVER</code></h4>
<p>The <code>await</code> statement for <code>FOREVER</code> halts the running trail forever.
It cannot be used in assignments because it never evaluates to anything.</p>
<pre><code class="ceu">if &lt;cnd&gt; then
    await FOREVER;  // this trail never awakes if the condition is true
end
</code></pre>

<h3 id="emit">Emit</h3>
<p>The <code>emit</code> statement broadcasts an event to the whole program.
The event can be an <a href="#TODO">external event</a>, an <a href="#TODO">internal event</a>, or
a timer:</p>
<pre><code class="ceu">Emit ::= emit (ID_ext | Name) [`(´ [LIST(Exp)] `)´)]
      |  emit (WCLOCKK|WCLOCKE)
</code></pre>

<p>Examples:</p>
<pre><code class="ceu">emit A;         // emits the external event `A` of type &quot;void&quot;
emit a(1);      // emits the internal event `a` of type &quot;int&quot;

emit 1s;        // emits the specified time
emit (t)ms;     // emits the current value of the variable `t` in milliseconds
</code></pre>

<h4 id="events_2">Events</h4>
<p>The <code>emit</code> statement for events expects a specific number of arguments matching
the event type (unless the event is of type <code>void</code>).</p>
<ul>
<li>An <code>emit</code> to an external input or timer event can only occur inside
  <a href="#TODO">asynchronous blocks</a>.</li>
<li>An <code>emit</code> to an external output event is also an expression that evaluates
  to a value of type <code>s32</code> (its meaning is <a href="#TODO">platform dependent</a>).</li>
<li>An <code>emit</code> to an internal event starts a new <a href="#TODO">internal reaction</a>.</li>
</ul>
<p>Examples:</p>
<pre><code class="ceu">input int I;
async do
    emit I(10);         // broadcasts &quot;I&quot; to the application itself, passing &quot;10&quot;
end

output void O;
var int ret = emit O(); // outputs &quot;O&quot; to the environment and captures the result

event (int,int) e;
emit e(1,2);            // broadcasts &quot;e&quot; passing a pair of &quot;int&quot; values
</code></pre>

<h4 id="timers_1">Timers</h4>
<p>The <code>emit</code> statement for timers expects an expression of time as described in
<a href="#TODO">Await Timer</a>.</p>
<p>Like input events, time can only be emitted inside <a href="#asynchronous-blocks">asynchronous 
blocks</a>.</p>
<p>Examples:</p>
<pre><code class="ceu">async do
    emit 1s;    // broadcasts &quot;1s&quot; to the application itself
end
</code></pre>

<hr />
<h2 id="conditional">Conditional</h2>
<p>The <code>if-then-else</code> statement provides conditionals in Céu:</p>
<pre><code class="ceu">If ::= if Exp then
           Block
       { else/if Exp then
           Block }
       [ else
           Block ]
       end
</code></pre>

<p>Each condition <code>Exp</code> is tested in sequence, first for the <code>if</code> clause and then
for each of the optional <code>else/if</code> clauses.
For the first condition that evaluates to <code>true</code>, the <code>Block</code> following it
executes.
If all conditions fail, the optional <code>else</code> clause executes.</p>
<p>All conditions must evaluate to a value of type <a href="#TODO"><code>bool</code></a>, which is
checked at compile time.</p>
<h2 id="loops">Loops</h2>
<p>Céu supports simple loops, numeric iterators, event iterators, and pool
iterators:</p>
<pre><code class="ceu">Loop ::=
      /* simple loop */
        loop [`/´Exp] do
            Block
        end

      /* numeric iterator */
      | loop [`/´Exp] Numeric do    /* Numeric ::= (see &quot;Numeric Iterators&quot;) */
            Block
        end

      /* event iterator */
      | every [(Name | `(´ LIST(Name|`_´) `)´) in] (ID_ext|Name|WCLOCKK|WCLOCKE) do
            Block
        end

      /* pool iterator */
      | loop [`/´Exp] [ `(´ LIST(Var) `)´ ] in Name do
            Block
        end

Break    ::= break [`/´ID_int]
Continue ::= continue [`/´ID_int]
</code></pre>

<p>The <code>Block</code> body of a loop executes an arbitrary number of times, depending on
the conditions imposed by each kind of loop.</p>
<p>Except for the <code>every</code> iterator, all loops support an optional
<code>&grave;/&acute;Exp</code> to limit the maximum number of iterations and
avoid <a href="#TODO">infinite execution</a>.
The expression must be a constant evaluated at compile time.</p>
<h3 id="break-and-continue"><code>break</code> and <code>continue</code></h3>
<p>The <code>break</code> statement aborts the deepest enclosing loop.</p>
<p>The <code>continue</code> statement aborts the body of the deepest enclosing loop and
restarts in the next iteration.</p>
<p>The optional <code>&grave;/&acute;ID_int</code> in both statements only applies
to <a href="#TODO">numeric iterators</a>.</p>
<h3 id="simple-loops">Simple Loops</h3>
<p>A simple loop executes its body continually and forever.</p>
<p>Examples:</p>
<pre><code class="ceu">// blinks a LED with a frequency of 1s forever
loop do
    emit LED(1);
    await 1s;
    emit LED(0);
    await 1s;
end
</code></pre>

<pre><code class="ceu">loop do
    loop do
        if &lt;cnd-1&gt; then
            break;      // aborts the loop at line 2 if &lt;cnd-1&gt; is satisfied
        end
    end
    if &lt;cnd-2&gt; then
        continue;       // restarts the loop at line 1 if &lt;cnd-2&gt; is satisfied
    end
end
</code></pre>

<h3 id="numeric-iterators">Numeric Iterators</h3>
<p>The numeric loop modifies the value of a control variable on each iteration
according to the specification of an optional interval as follows:</p>
<pre><code class="ceu">Numeric ::= (`_´|ID_int) in [ (`[´ | `]´)
                                  ( (     Exp `-&gt;´ (`_´|Exp))
                                  | (`_´|Exp) `&lt;-´ Exp      ) )
                              (`[´ | `]´) [`,´ Exp] ]
</code></pre>

<p>The control variable assumes the values specified in the interval, one by one,
for each iteration of the loop body:</p>
<ul>
<li><strong>control variable:</strong>
    <code>ID_int</code> is a variable of a <a href="#TODO">numeric type</a>.
    Alternatively, the special anonymous identifier <code>_</code> can be used if the body
    of the loop does not access the variable.
    The control variable is marked as <code>read-only</code> and cannot be changed
    explicitly.</li>
<li><strong>interval:</strong>
    Specifies a direction, endpoints with open or closed modifiers, and a step.<ul>
<li><strong>direction</strong>:<ul>
<li><code>-&gt;</code>: Starts from the endpoint <code>Exp</code> on the left increasing towards <code>Exp</code> on the right.</li>
<li><code>&lt;-</code>: Starts from the endpoint <code>Exp</code> on the right decreasing towards <code>Exp</code> on the left.
Typically, the value on the left should always be smaller or equal to
the value on the right.</li>
</ul>
</li>
<li><strong>endpoints</strong>:
    <code>[Exp</code> and <code>Exp]</code> are closed intervals which include <code>Exp</code> as the
    endpoints;
    <code>]Exp</code> and <code>Exp[</code> are open intervals which exclude <code>Exp</code> as the
    endpoints.
    Alternatively, the finishing endpoint may be <code>_</code> which means that the
    interval goes towards infinite.</li>
<li><strong>step</strong>:
    An optional positive number added or subtracted towards the limit.
    If the step is omitted, it assumes the value <code>1</code>.
    If the direction is <code>-&gt;</code>, the step is added, otherwise it is subtracted.
If the interval is not specified, it assumes the default <code>[0 -&gt; _]</code>.</li>
</ul>
</li>
</ul>
<p>The numeric iterator executes as follows:</p>
<ul>
<li><strong>initialization:</strong>
    The starting endpoint is assigned to the control variable.
    If the starting enpoint is open, the control variable accumulates a step.</li>
<li><strong>iteration:</strong><ol>
<li><strong>limits test:</strong>
    If the control variable crossed the finishing endpoint, the loop
    terminates.</li>
<li><strong>body execution:</strong>
    The loop body executes.</li>
<li><strong>step</strong>
    Applies a step to the control variable. Goto step <code>1</code>.</li>
</ol>
</li>
</ul>
<p>The <code>break</code> and <code>continue</code> statements inside numeric iterators accept an
optional modifier <code>&grave;/&acute;ID_int</code> to match the control
variable of the enclosing loop to affect.</p>
<p>Examples:</p>
<pre><code class="ceu">// prints &quot;i=0&quot;, &quot;i=1&quot;, ...
var int i;
loop i do
    _printf(&quot;i=%d\n&quot;, i);
end
</code></pre>

<pre><code class="ceu">// awaits 1s and prints &quot;Hello World!&quot; 10 times
loop _ in [0 -&gt; 10[ do
    await 1s;
    _printf(&quot;Hello World!\n&quot;);
end
</code></pre>

<pre><code class="ceu">var int i;
loop i do
    var int j;
    loop j do
        if &lt;cnd-1&gt; then
            continue/i;         // continues the loop at line 1
        else/if &lt;cnd-2&gt; then
            break/j;            // breaks the loop at line 4
        end
    end
end
</code></pre>

<p><em>Note : the runtime asserts that the step is a positive number and that the
        control variable does not overflow.</em></p>
<h3 id="pool-iterators">Pool Iterators</h3>
<p>Pool iterators are dicussed in <a href="#TODO">Code Pools</a>.</p>
<hr />
<h2 id="parallel-compositions">Parallel Compositions</h2>
<p>The parallel statements <code>par/and</code>, <code>par/or</code>, and <code>par</code> split the running trail 
in multiple others:</p>
<pre><code class="ceu">Pars ::= (par | par/and | par/or) do
             Block
         with
             Block
         { with
             Block }
         end

Watching ::= watching LIST(ID_ext|Name|WCLOCKK|WCLOCKE|Code2) do
                 Block
             end

</code></pre>

<p>They differ only on how trails rejoin and terminate the composition.</p>
<p>The <code>watching</code> statement terminates when one of its listed events occur.</p>
<p>See also <a href="#TODO">Parallel Compositions and Abortion</a>.</p>
<h3 id="par">par</h3>
<p>The <code>par</code> statement never rejoins.</p>
<p>Examples:</p>
<pre><code class="ceu">// reacts continuously to &quot;1s&quot; and &quot;KEY_PRESSED&quot; and never terminates
input void KEY_PRESSED;
par do
    every 1s do
        &lt;...&gt;           // does something every &quot;1s&quot;
    end
with
    every KEY_PRESSED do
        &lt;...&gt;           // does something every &quot;KEY_PRESSED&quot;
    end
end
</code></pre>

<h3 id="parand">par/and</h3>
<p>The <code>par/and</code> statement stands for <em>parallel-and</em> and rejoins when all trails 
terminate.</p>
<p>Examples:</p>
<pre><code class="ceu">// reacts once to &quot;1s&quot; and &quot;KEY_PRESSED&quot; and terminates
input void KEY_PRESSED;
par/and do
    await 1s;
    &lt;...&gt;               // does something after &quot;1s&quot;
with
    await KEY_PRESSED;
    &lt;...&gt;               // does something after &quot;KEY_PRESSED&quot;
end
</code></pre>

<h3 id="paror">par/or</h3>
<p>The <code>par/or</code> statement stands for <em>parallel-or</em> and rejoins when any of the 
trails terminate, aborting all other trails.</p>
<p>Examples:</p>
<pre><code class="ceu">// reacts once to `1s` or `KEY_PRESSED` and terminates
input void KEY_PRESSED;
par/or do
    await 1s;
    &lt;...&gt;               // does something after &quot;1s&quot;
with
    await KEY_PRESSED;
    &lt;...&gt;               // does something after &quot;KEY_PRESSED&quot;
end
</code></pre>

<h3 id="watching">watching</h3>
<p>The <code>watching</code> statement accepts a list of events and terminates when any of
the events occur.</p>
<p>A <code>watching</code> expands to a <code>par/or</code> with <em>n+1</em> trails:
one to await each of the listed events,
and one for its body, i.e.:</p>
<pre><code class="ceu">watching &lt;e1&gt;,&lt;e2&gt;,... do
    &lt;body&gt;
end
</code></pre>

<p>expands to</p>
<pre><code class="ceu">par/or do
    await &lt;e1&gt;;
with
    await &lt;e2&gt;;
with
    ...
with
    &lt;body&gt;
end
</code></pre>

<p>Examples:</p>
<pre><code class="ceu">// reacts continuously to &quot;KEY_PRESSED&quot; during &quot;1s&quot;
input void KEY_PRESSED;
watching 1s do
    every KEY_PRESSED do
        &lt;...&gt;           // does something every &quot;KEY_PRESSED&quot;
    end
end
</code></pre>

<hr />
<h2 id="pausing_1">Pausing</h2>
<p>The <code>pause/if</code> statement controls if its body should temporarily stop to react
to events:</p>
<pre><code class="ceu">Pause_If ::= pause/if (Name|ID_ext) do
                 Block
             end

Pause_Await ::= await (pause|resume)
</code></pre>

<p>A <code>pause/if</code> determines a pausing event of type <code>bool</code> which, when emitted,
toggles between pausing (<code>true</code>) and resuming (<code>false</code>) reactions for its body.</p>
<p>When its body terminates, the whole <code>pause/if</code> terminates and proceeds to the
statement in sequence.</p>
<p>In transition points, the body can react to the special <code>pause</code> and <code>resume</code>
events before the corresponding state applies.</p>
<p><code>TODO: finalize/pause/resume</code></p>
<p>Examples:</p>
<pre><code class="ceu">event bool e;
pause/if e do       // pauses/resumes the nested body on each &quot;e&quot;
    every 1s do
        &lt;...&gt;       // does something every &quot;1s&quot;
    end
end
</code></pre>

<pre><code class="ceu">event bool e;
pause/if e do               // pauses/resumes the nested body on each &quot;e&quot;
    &lt;...&gt;
        loop do
            await pause;
            &lt;...&gt;           // does something before pausing
            await resume;
            &lt;...&gt;           // does something before resuming
        end
    &lt;...&gt;
end
</code></pre>

<!--
*Note: The timeouts for timers remain frozen while paused.*
-->

<hr />
<h2 id="asynchronous-execution">Asynchronous Execution</h2>
<p>Asynchronous execution allow programs to execute time consuming computations 
without interfering with the responsiveness of the  <em>synchronous side</em> of
applications (i.e., all core language statements):</p>
<pre><code class="ceu">Async  ::= await async [ `(´LIST(Var)`)´ ] do
               Block
           end

Thread ::= await async/thread [ `(´LIST(Var)`)´ ] do
               Block
           end
Atomic ::= atomic do
               Block
           end
</code></pre>

<p>The program awaits the termination of the asynchronous body to proceed to the
statement in sequence.</p>
<p>Asynchronous blocks can contain <a href="#TODO">tight loops</a> but which keep the
application reactive to incoming events.
However, they do not support nesting of asynchronous statements, and do not
support synchronous control statements (i.e., parallel compositions, event
handling, pausing, etc.).</p>
<p>By default, asynchronous blocks do not shared variables with their enclosing
scope.
The optional list of variables makes them visible to the block.</p>
<h3 id="asynchronous-blocks">Asynchronous Blocks</h3>
<p>Asynchronous blocks (<code>async</code>) preserve deterministic execution with the rules
as follows:</p>
<ol>
<li>Resume execution whenever the synchronous side is idle.</li>
<li>Yield control to the synchronous side on every complete <code>loop</code> iteration.</li>
<li>Yield control to the synchronous side on every <code>emit</code>.</li>
<li>Execute atomically and to completion unless rules <code>2</code> and <code>3</code> apply.</li>
</ol>
<p>This rules imply that <code>async</code> blocks and the synchronous side never run at the
same time with real parallelism.</p>
<p>Examples:</p>
<pre><code class="ceu">// calculates the factorial of some &quot;v&quot; if it doesn't take too long
var u64  v   = &lt;...&gt;;
var u64  fat = 1;
var bool ok  = false;
watching 1s do
    await async (v,fat) do      // keeps &quot;v&quot; and &quot;fat&quot; visible
        loop i in [1 -&gt; v] do   // reads from &quot;v&quot;
            fat = fat * i;      // writes to &quot;fat&quot;
        end
    end
    ok = true;                  // completed within &quot;1s&quot;
end
</code></pre>

<h4 id="simulation">Simulation</h4>
<p>An <code>async</code> block can emit <a href="#TODO">input events</a> and the
<a href="#TODO">passage of time</a> towards the synchronous side, providing a way to test
programs in the language itself.
Every time an <code>async</code> emits an event, it suspends until the synchronous side
reacts to the event (see <a href="#TODO"><code>rule 1</code></a> above).</p>
<p>Examples:</p>
<pre><code class="ceu">input int A;

// tests a program with a simulation in parallel
par do

    // original program
    var int v = await A;
    loop i in [0 -&gt; _[ do
        await 10ms;
        _printf(&quot;v = %d\n&quot;, v+i);
    end

with

    // input simulation
    async do
        emit A(0);      // initial value for &quot;v&quot;
        emit 1s35ms;    // the loop in the original program executes 103 times
    end
    escape 0;

end

// The example prints the message `v = &lt;v+i&gt;` exactly 103 times.
</code></pre>

<h3 id="asynchronous-threads">Asynchronous Threads</h3>
<p>Asynchronous threads (<code>async/thread</code>) provide real parallelism for applications
in Céu.
Once an <code>async/thread</code> starts, it runs completely detached from the synchronous
side.
However, they are still ruled by the synchronous side and are also subject to
abortion.</p>
<p>Examples:</p>
<pre><code class="ceu">// calculates the factorial of some &quot;v&quot; if it doesn't take too long
var u64  v   = &lt;...&gt;;
var u64  fat = 1;
var bool ok  = false;
watching 1s do
    await async/thread (v,fat) do   // keeps &quot;v&quot; and &quot;fat&quot; visible
        loop i in [1 -&gt; v] do       // reads from &quot;v&quot;
            fat = fat * i;          // writes to &quot;fat&quot;
        end
    end
    ok = true;                      // completed within &quot;1s&quot;
end
</code></pre>

<p>Asynchronous threads are non deterministic and require explicit synchronization
on accesses to variables to avoid race conditions.</p>
<h4 id="atomic-blocks">Atomic Blocks</h4>
<p>Atomic blocks provide mutual exclusion among threads and the synchronous
side of application.
Once an atomic block starts to execute, no other atomic block in the program
starts.</p>
<p>Examples:</p>
<pre><code class="ceu">// A &quot;race&quot; between two threads: one incrementing, the other decrementing &quot;count&quot;.

var s64 count = 0;                              // &quot;count&quot; is a shared variable
par do
    every 1s do
        atomic do
            _printf(&quot;count = %d\n&quot;, count);     // prints current value of &quot;count&quot; every &quot;1s&quot;
        end
    end
with
    await async/thread (count) do
        loop do
            atomic do
                count = count - 1;              // decrements &quot;count&quot; as fast as possible
            end
        end
    end
with
    await async/thread (count) do
        loop do
            atomic do
                count = count + 1;              // increments &quot;count&quot; as fast as possible
            end
        end
    end
end
</code></pre>

<hr />
<h2 id="c-integration">C Integration</h2>
<p>The <a href="#TODO">compiler of Céu</a> generates as output a program in C, which is
embedded in a host program also in C, which is further compiled to the final
binary program.</p>
<p>Céu integrates safely with C, and programs can define and make native calls
seamlessly while avoiding memory leaks and dangling pointers when dealing with
external resources.</p>
<p>Céu provides <a href="#TODO">native declarations</a> to import C symbols,
<a href="#TODO">native blocks</a> to define new code in C,
<a href="#TODO">native statements</a> to inline C statements,
<a href="#TODO">native calls</a> to call C functions,
and <a href="#TODO">finalization</a> to deal with C pointers safely:</p>
<pre><code class="ceu">Nat_Symbol ::= native [`/´(pure|const|nohold|plain)] `(´ List_Nat `)´
Nat_Block  ::= native `/´(pre|pos) do
                   &lt;code definitions in C&gt;
               end
Nat_End    ::= native `/´ end

Nat_Stmts  ::= `{´ {&lt;code in C&gt; | `@´ Exp} `}´

Nat_Call   ::= [call] (Name | `(´ Exp `)´)  `(´ [ LIST(Exp)] `)´

List_Nat ::= LIST(ID_nat)

Finalization ::= do [Stmt] Finalize
              |  var `&amp;?´ Type ID_int `=´ `&amp;´ (Call_Nat | Call_Code) Finalize
Finalize ::= finalize `(´ LIST(Name) `)´ with
                 Block
             [ pause  with Block ]
             [ resume with Block ]
             end
</code></pre>

<p>Native calls and statements transfer the control of the CPU to inlined code in
C, losing the guarantees of the <a href="#TODO">synchronous model</a>.
For this reason, programs should only resort to C for asynchronous
functionality, such as non-blocking I/O, or simple <code>struct</code> accessors, but
never for control purposes.</p>
<h3 id="native-declarations">Native Declarations</h3>
<p>In Céu, an <a href="#TODO">identifier</a> prefixed with an underscore is considered a
native symbol that is defined externally in C.
However, all external symbols must be declared before their first use.</p>
<p>Native declarations support four modifiers as follows:</p>
<ul>
<li><code>const</code>: declares the listed symbols as constants.
    Constants can be used as <a href="#TODO">bounded limits</a> in <a href="#TODO">vectors</a>,
    <a href="#TODO">pools</a>, and <a href="#TODO">numeric loops</a>.
    Also, constants cannot be <a href="#TODO">assigned</a>.</li>
<li><code>plain</code>: declares the listed symbols as <em>plain</em> types, i.e., types (or
    composite types) that do not contain pointers.
    Value of plain types passed as arguments to functions do not require
    <a href="#TODO">finalization</a>.</li>
<li><code>nohold</code>: declares the listed symbols as <em>non-holding</em> functions, i.e.,
    a function that does not retain received pointers as arguments after
    returning.
    Pointers passed to non-holding functions do not require
    <a href="#TODO">finalization</a>.</li>
<li><code>pure</code>: declares the listed symbols as pure functions.
    In addition to the <code>nohold</code> properties, pure functions have no side
    effects to take into account for the <a href="#TODO">safety checks</a>.</li>
</ul>
<p>Examples:</p>
<pre><code class="ceu">// values
native/const  _LOW, _HIGH;      // Arduino's &quot;LOW&quot; and &quot;HIGH&quot; are constants
native        _errno;           // POSIX's &quot;errno&quot; is a global variable

// types
native/plain  _char;            // &quot;char&quot; is a &quot;plain&quot; type
native        _SDL_PixelFormat; // SDL's &quot;SDL_PixelFormat&quot; is a type holding a pointer

// functions
native        _uv_read_start;   // Libuv's &quot;uv_read_start&quot; retains the received pointer
native/nohold _free;            // POSIX's &quot;free&quot; receives a pointer but does not retain it
native/pure   _strlen;          // POSIX's &quot;strlen&quot; is a &quot;pure&quot; function
</code></pre>

<h3 id="native-blocks">Native Blocks</h3>
<p>Native blocks allows programs to define new external symbols in C.</p>
<p>The contents of native blocks is not parsed by Céu, but copied unchanged to the
output in C depending on the modifier specified:</p>
<ul>
<li><code>pre</code>: code is placed before the declarations for the Céu program.
    Symbols defined in <code>pre</code> blocks are visible to Céu.</li>
<li><code>pos</code>: code is placed after the declarations for the Céu program.
    Symbols defined by Céu are visible to <code>pos</code> blocks.</li>
</ul>
<p>Native blocks are copied in the order they appear in the source code.</p>
<p>Since Céu uses the <a href="#TODO">C preprocessor</a>, <code>#</code> directives inside native blocks
must use <code>##</code> directives to be considered only in the C compilation phase.</p>
<p>Symbols defined in native blocks still need to be <a href="#TODO">declared</a> for use in
the program.</p>
<p>Examples:</p>
<pre><code class="ceu">native/plain _t;
native/pre do
    typedef int t;              // definition for &quot;t&quot; is placed before Céu declarations
end
var _t x = 10;                  // requires &quot;t&quot; to be already defined
</code></pre>

<pre><code class="ceu">input void A;                   // declaration for &quot;A&quot; is placed before &quot;pos&quot; blocks
native _get_A_id;
native/pos do
    int get_A_id (void) {
        return CEU_INPUT_A;     // requires &quot;A&quot; to be already declared
    }
end
</code></pre>

<pre><code class="ceu">native/nohold _printf;
native/pre do
    ##include &lt;stdio.h&gt;         // include the relevant header for &quot;printf&quot;
end
</code></pre>

<h3 id="native-statements">Native Statements</h3>
<p>The contents of native statements in between <code>{</code> and <code>}</code> are inlined in the
output in C.</p>
<p>Native statements support interpolation of expressions in Céu which are
expanded in the generated output in C when preceded by a <code>@</code>.</p>
<p>Examples:</p>
<pre><code class="ceu">var int v = 10;
{
    printf(&quot;v = %d\n&quot;, @v);     // prints &quot;v = 10&quot;
};
</code></pre>

<h3 id="native-calls">Native Calls</h3>
<p>Names and expressions that evaluate to a <a href="#TODO">native type</a> can be called
from Céu.</p>
<p>Examples:</p>
<pre><code class="ceu">// all expressions evaluate to a native type and can be called

_printf(&quot;Hello World!\n&quot;);

var _t f = &lt;...&gt;;
f();

var _s s = &lt;...&gt;;
s.f();
</code></pre>

<p><code>TODO: pointer return</code></p>
<h3 id="finalization">Finalization</h3>
<p>The finalization statement unconditionally executes a series of
<a href="#TODO">non-yielding statements</a> when its corresponding enclosing block
terminates, even if aborted abruptly.</p>
<p>Céu tracks the interaction of native calls with pointers and requires 
finalization clauses to accompany them:</p>
<ul>
<li>If Céu <strong>passes</strong> a pointer to a native call, the pointer represents a
  <strong>local</strong> resource that requires finalization.
  Finalization executes when the block of the local resource goes out of scope.</li>
<li>If Céu <strong>receives</strong> a pointer from a native call return, the pointer
  represents an <strong>external</strong> resource that requires finalization.
  Finalization executes when the block of the receiving pointer goes out of
  scope.</li>
</ul>
<p>Examples:</p>
<pre><code class="ceu">// Local resource finalization
watching &lt;...&gt; do
    var _buffer_t msg;
    &lt;...&gt;                       // prepares msg
    do
        _send_request(&amp;msg);
    finalize with
        _send_cancel(&amp;msg);
    end
    await SEND_ACK;             // transmission is complete
end
</code></pre>

<p>In the example above, the local variable <code>msg</code> is an internal resource passed
as a pointer to <code>_send_request</code>, which is an asynchronous call that transmits
the buffer in the background.
If the enclosing <code>watching</code> aborts before awaking from the <code>await SEND_ACK</code>,
the local <code>msg</code> goes out of scope and the external transmission now holds a
<em>dangling pointer</em>.
The finalization ensures that <code>_send_cancel</code> also aborts the transmission.</p>
<pre><code class="ceu">// External resource finalization
watching &lt;...&gt; do
    var&amp;? _FILE f = _fopen(&lt;...&gt;) finalize with
                        _fclose(f);
                    end;
    _fwrite(..., f);
    await A;
    _fwrite(..., f);
end
</code></pre>

<p>In the example above, the call to <code>_fopen</code> returns an external file resource as
a pointer.
If the enclosing <code>watching</code> aborts before awaking from the <code>await A</code>, the file
remains open as a <em>memory leak</em>.
The finalization ensures that <code>_fclose</code> closes the file properly.</p>
<!--
%
In both cases, the code does not compile without the \code{finalize}
construct.%
\footnote{
The compiler only forces the programmer to write the finalization clause, but
cannot check if it actually handles the resource properly.
}

\caption{
\CEU enforces the use of finalization to prevent \emph{dangling pointers} for 
local resources and \emph{memory leaks} for external resources.
\label{lst.fin.ceu}
}
\end{figure}
-->

<hr />
<h2 id="lua-integration">Lua Integration</h2>
<p><code>TODO</code></p>
<hr />
<h2 id="abstractions">Abstractions</h2>
<p><code>TODO</code></p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../060-expressions/" class="btn btn-neutral float-right" title="Expressions">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../040-storage_classes/" class="btn btn-neutral" title="Storage Classes"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>

  </div>

<div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../040-storage_classes/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../060-expressions/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>

</body>
</html>
