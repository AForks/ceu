{
    "docs": [
        {
            "location": "/", 
            "text": "C\u00e9u v0.20 - Reference Manual\n\n\n\n\nIntroduction\n\n\nLexical Rules\n\n\nTypes\n\n\nStorage Classes\n\n\nStatements\n\n\nExpressions\n\n\nStatic Analsysis\n\n\nEnvironment\n\n\nErrors\n\n\nSyntax\n\n\nLicense", 
            "title": "Home"
        }, 
        {
            "location": "/#ceu-v020-reference-manual", 
            "text": "Introduction  Lexical Rules  Types  Storage Classes  Statements  Expressions  Static Analsysis  Environment  Errors  Syntax  License", 
            "title": "C\u00e9u v0.20 - Reference Manual"
        }, 
        {
            "location": "/010-introduction/", 
            "text": "Introduction\n\n\nC\u00e9u provides \nStructured Synchronous Reactive Programming\n which supports\nsafe and deterministic concurrency with side effects.\nThe lines of execution in C\u00e9u, known as \ntrails\n, react together continuously\nand in synchronous steps to external input events from the environment.\nWaiting for an event halts the running trail until that event occurs.\nThe environment broadcasts an occurring event to all active trails, which share \na single global time reference.\n\n\nThe synchronous concurrency model of C\u00e9u diverges from multithreading and also\nfrom actor-based models (e.g. \npthreads\n and \nerlang\n).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, trails can share variables deterministically without\nsynchronization primitives (i.e., no \nlocks\n, \nsemaphores\n, or \nqueues\n).\n\n\nC\u00e9u provides automatic memory management based on static lexical scopes (i.e.,\nno \nfree\n or \ndelete\n) and does not require runtime garbage collection.\n\n\nC\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers.\n\n\nC\u00e9u is \nfree software\n.\n\n\nSynchronous Execution Model\n\n\nC\u00e9u is grounded on a precise definition of \nlogical time\n (as opposed to\n\nphysical\n or \nwall-clock time\n) as a discrete sequence of external input\nevents:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see \nBounded Execution\n).\n\n\nThe execution model for C\u00e9u programs is as follows:\n\n\n\n\nThe program initiates the \nboot reaction\n from the first line of code in a\n      single trail.\n\n\nActive trails\n1\n, one after another, execute until they await or \n      terminate.\n      This step is named a \nreaction chain\n, and always runs in bounded time.\n\n\nThe program goes idle and the environment takes control.\n\n\nOn the occurrence of a new external input event, the environment awakes \n      \nall\n trails awaiting that event.\n      It then goes to step 2.\n\n\n\n\n(\n1\n\n\nTrails can be created with \nparallel \ncompositions\n.\n)\n\n\nThe synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run \ninfinitely faster\n in comparison to the rate of external events.\nA reaction chain is the set of computations that execute when an external \nevent occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new external input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is somewhat arbitrary, but provides a priority scheme for trails, \nand also ensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.\n\n\nThe program and diagram below illustrate the behavior of the scheduler of C\u00e9u:\n\n\n 1:  input void A, B, C;\n 2:  par/and do           // A, B, and C are external input events\n 3:      // trail 1\n 4:      \n...\n            // \n...\n represents non-awaiting statements\n 5:      await A;\n 6:      \n...\n\n 7:  with\n 8:      // trail 2\n 9:      \n...\n\n10:      await B;\n11:      \n...\n\n12:  with\n13:      // trail 3\n14:      \n...\n\n15:      await A;\n16:      \n...\n\n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:          \n...\n\n21:      with\n22:          // trail 4\n23:          \n...\n\n24:      end\n25:  end\n\n\n\n\n\n\nThe program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows (\nt0\n in the diagram):\n\n\n\n\ntrail-1\n executes up to the \nawait A\n (line 5);\n\n\ntrail-2\n, up to the \nawait B\n (line 10);\n\n\ntrail-3\n, up to \nawait A\n (line 15).\n\n\n\n\nAs no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event \nA\n occurs (\nt1\n in the diagram):\n\n\n\n\ntrail-1\n awakes, executes and terminates (line 6);\n\n\ntrail-2\n remains suspended, as it is not awaiting \nA\n.\n\n\ntrail-3\n executes up to \nawait B\n (line 17).\n\n\n\n\nDuring the reaction \nt1\n, new instances of events \nA\n, \nB\n, and \nC\n occur and\nare enqueued to be handled in the reactions in sequence.\nAs \nA\n happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n(\nt2\n in the diagram).\nThe next reaction dequeues the event \nB\n (\nt3\n in the diagram):\n\n\n\n\ntrail-2\n awakes, executes and terminates;\n\n\ntrail-3\n splits in two and they both terminate immediately.\n\n\n\n\nA \npar/and\n rejoins after all trails terminate.\nWith all trails terminated, the program also terminates and does not react to \nthe pending event \nC\n.\n\n\nNote that each step in the logical time line (\nt0\n, \nt1\n, etc.) is identified \nby the unique event it handles.\nInside a reaction, trails only react to that identifying event (or remain \nsuspended).\n\n\n\n\n\nParallel Compositions and Abortion\n\n\nThe use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:\n\n\n\n\na \npar/and\n rejoins after all trails in parallel terminate;\n\n\na \npar/or\n rejoins after any trail in parallel terminates, aborting all\n   other trails;\n\n\na \npar\n never rejoins, even if all trails terminate.\n\n\n\n\nThe termination of a trail inside a \npar/or\n aborts the other trails in \nparallel which are necessarily idle\n(see \nrule 2\n for external reactions\n).\nBefore being aborted, a trail has a last opportunity to execute active \n\nfinalization statements\n.\n\n\nAs mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions should read as \nawaiting in parallel\n, rather\nthan \nexecuting in parallel\n.\n\n\nBounded Execution\n\n\nReaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle upcoming input events from the environment.\nFor this reason, C\u00e9u requires every path inside the body of a \nloop\n statement\nto contain at least one \nawait\n or \nbreak\n statement.\nThis prevents \ntight loops\n, i.e., unbounded loops that do not await.\n\n\nIn the example below, the true branch of the \nif\n may never execute, resulting\nin a tight loop when the condition is false:\n\n\nloop do\n    if \ncond\n then\n        break;\n    end\nend\n\n\n\n\nC\u00e9u complains about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides \nAsynchronous \nExecution\n.\n\n\nDeterministic Execution\n\n\nTODO (shared memory + deterministic scheduler + optional static analysis)\n\n\nInternal Reactions\n\n\nC\u00e9u supports inter-trail communication through \nawait\n and \nemit\n statements\nfor \ninternal events\n.\nA trail can \nemit\n an event which is broadcast to the program to awake trails\nin parallel that are blocked in an \nawait\n statement for that same event.\n\n\nAn \nemit\n starts a new \ninternal reaction\n in the program relying on a\nruntime stack:\n\n\n\n\nAn \nemit\n suspends the current trail and its continuation is pushed into the\n    stack (i.e., the statement in sequence with the \nemit\n).\n\n\nAll trails awaiting the emitted event awake and execute\n    (see \nrule 2\n for external reactions\n).\n\n\nThe top of stack is popped and the last emitting trail resumes execution\n    from its continuation.\n\n\n\n\nNote that if an awaking trail emits another internal event (in \nrule 2\n), a\nnested internal reaction starts (in \nrule 1\n).\nExample:\n\n\n1:  par/and do\n2:      await e;\n3:      emit f;\n4:  with\n5:      await f;\n6:  with\n7:      ...\n8:      emit e;\n9:  end\n\n\n\n\nThe \nemit e\n in \ntrail-3\n (line 8) starts an internal reaction that awakes the \n\nawait e\n in \ntrail-1\n (line 2).\nThen, the \nemit f\n (line 3) starts another internal reaction that awakes the \n\nawait f\n in \ntrail-2\n (line 5).\n\nTrail-2\n terminates and the \nemit f\n resumes in \ntrail-1\n.\n\nTrail-1\n terminates and the \nemit e\n resumes in \ntrail-3\n.\n\nTrail-3\n terminates.\nFinally, the \npar/and\n rejoins and the program terminates.", 
            "title": "Introduction"
        }, 
        {
            "location": "/010-introduction/#introduction", 
            "text": "C\u00e9u provides  Structured Synchronous Reactive Programming  which supports\nsafe and deterministic concurrency with side effects.\nThe lines of execution in C\u00e9u, known as  trails , react together continuously\nand in synchronous steps to external input events from the environment.\nWaiting for an event halts the running trail until that event occurs.\nThe environment broadcasts an occurring event to all active trails, which share \na single global time reference.  The synchronous concurrency model of C\u00e9u diverges from multithreading and also\nfrom actor-based models (e.g.  pthreads  and  erlang ).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, trails can share variables deterministically without\nsynchronization primitives (i.e., no  locks ,  semaphores , or  queues ).  C\u00e9u provides automatic memory management based on static lexical scopes (i.e.,\nno  free  or  delete ) and does not require runtime garbage collection.  C\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers.  C\u00e9u is  free software .", 
            "title": "Introduction"
        }, 
        {
            "location": "/010-introduction/#synchronous-execution-model", 
            "text": "C\u00e9u is grounded on a precise definition of  logical time  (as opposed to physical  or  wall-clock time ) as a discrete sequence of external input\nevents:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see  Bounded Execution ).  The execution model for C\u00e9u programs is as follows:   The program initiates the  boot reaction  from the first line of code in a\n      single trail.  Active trails 1 , one after another, execute until they await or \n      terminate.\n      This step is named a  reaction chain , and always runs in bounded time.  The program goes idle and the environment takes control.  On the occurrence of a new external input event, the environment awakes \n       all  trails awaiting that event.\n      It then goes to step 2.   ( 1  Trails can be created with  parallel \ncompositions . )  The synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run  infinitely faster  in comparison to the rate of external events.\nA reaction chain is the set of computations that execute when an external \nevent occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new external input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is somewhat arbitrary, but provides a priority scheme for trails, \nand also ensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.  The program and diagram below illustrate the behavior of the scheduler of C\u00e9u:   1:  input void A, B, C;\n 2:  par/and do           // A, B, and C are external input events\n 3:      // trail 1\n 4:       ...             //  ...  represents non-awaiting statements\n 5:      await A;\n 6:       ... \n 7:  with\n 8:      // trail 2\n 9:       ... \n10:      await B;\n11:       ... \n12:  with\n13:      // trail 3\n14:       ... \n15:      await A;\n16:       ... \n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:           ... \n21:      with\n22:          // trail 4\n23:           ... \n24:      end\n25:  end   The program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows ( t0  in the diagram):   trail-1  executes up to the  await A  (line 5);  trail-2 , up to the  await B  (line 10);  trail-3 , up to  await A  (line 15).   As no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event  A  occurs ( t1  in the diagram):   trail-1  awakes, executes and terminates (line 6);  trail-2  remains suspended, as it is not awaiting  A .  trail-3  executes up to  await B  (line 17).   During the reaction  t1 , new instances of events  A ,  B , and  C  occur and\nare enqueued to be handled in the reactions in sequence.\nAs  A  happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n( t2  in the diagram).\nThe next reaction dequeues the event  B  ( t3  in the diagram):   trail-2  awakes, executes and terminates;  trail-3  splits in two and they both terminate immediately.   A  par/and  rejoins after all trails terminate.\nWith all trails terminated, the program also terminates and does not react to \nthe pending event  C .  Note that each step in the logical time line ( t0 ,  t1 , etc.) is identified \nby the unique event it handles.\nInside a reaction, trails only react to that identifying event (or remain \nsuspended).", 
            "title": "Synchronous Execution Model"
        }, 
        {
            "location": "/010-introduction/#parallel-compositions-and-abortion", 
            "text": "The use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:   a  par/and  rejoins after all trails in parallel terminate;  a  par/or  rejoins after any trail in parallel terminates, aborting all\n   other trails;  a  par  never rejoins, even if all trails terminate.   The termination of a trail inside a  par/or  aborts the other trails in \nparallel which are necessarily idle\n(see  rule 2  for external reactions ).\nBefore being aborted, a trail has a last opportunity to execute active  finalization statements .  As mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions should read as  awaiting in parallel , rather\nthan  executing in parallel .", 
            "title": "Parallel Compositions and Abortion"
        }, 
        {
            "location": "/010-introduction/#bounded-execution", 
            "text": "Reaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle upcoming input events from the environment.\nFor this reason, C\u00e9u requires every path inside the body of a  loop  statement\nto contain at least one  await  or  break  statement.\nThis prevents  tight loops , i.e., unbounded loops that do not await.  In the example below, the true branch of the  if  may never execute, resulting\nin a tight loop when the condition is false:  loop do\n    if  cond  then\n        break;\n    end\nend  C\u00e9u complains about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides  Asynchronous \nExecution .", 
            "title": "Bounded Execution"
        }, 
        {
            "location": "/010-introduction/#deterministic-execution", 
            "text": "TODO (shared memory + deterministic scheduler + optional static analysis)", 
            "title": "Deterministic Execution"
        }, 
        {
            "location": "/010-introduction/#internal-reactions", 
            "text": "C\u00e9u supports inter-trail communication through  await  and  emit  statements\nfor  internal events .\nA trail can  emit  an event which is broadcast to the program to awake trails\nin parallel that are blocked in an  await  statement for that same event.  An  emit  starts a new  internal reaction  in the program relying on a\nruntime stack:   An  emit  suspends the current trail and its continuation is pushed into the\n    stack (i.e., the statement in sequence with the  emit ).  All trails awaiting the emitted event awake and execute\n    (see  rule 2  for external reactions ).  The top of stack is popped and the last emitting trail resumes execution\n    from its continuation.   Note that if an awaking trail emits another internal event (in  rule 2 ), a\nnested internal reaction starts (in  rule 1 ).\nExample:  1:  par/and do\n2:      await e;\n3:      emit f;\n4:  with\n5:      await f;\n6:  with\n7:      ...\n8:      emit e;\n9:  end  The  emit e  in  trail-3  (line 8) starts an internal reaction that awakes the  await e  in  trail-1  (line 2).\nThen, the  emit f  (line 3) starts another internal reaction that awakes the  await f  in  trail-2  (line 5). Trail-2  terminates and the  emit f  resumes in  trail-1 . Trail-1  terminates and the  emit e  resumes in  trail-3 . Trail-3  terminates.\nFinally, the  par/and  rejoins and the program terminates.", 
            "title": "Internal Reactions"
        }, 
        {
            "location": "/020-lexical_rules/", 
            "text": "Lexical Rules\n\n\nKeywords\n\n\nKeywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):\n\n\n    and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    loop            lua             native          new             nohold          \n\n    not             nothing         null            or              outer           \n\n    output          par             pause           plain           pool            \n\n    pos             pre             pure            recursive       request         \n\n    resume          sizeof          spawn           then            thread\n\n    tight           traverse        true            until           val\n\n    var             vector          watching        with            bool\n\n    byte            f32             f64             float           int\n\n    s16             s32             s64             s8              ssize\n\n    u16             u32             u64             u8              uint\n\n    usize           void\n\n\n\n\nIdentifiers\n\n\nC\u00e9u uses identifiers to refer to \ntypes\n, \nvariables\n, \nvectors\n, \npools\n,\n\ninternal events\n, \nexternal events\n, \ncode abstractions\n, \ndata abstractions\n,\n\nfields\n, \nnative symbols\n, and \nblock labels\n.\n\n\nID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID (first is lowercase)                        // variables, vectors, pools, internal events, and block labels\nID_ext   ::= ID (all in uppercase, first is not digit)      // external events\nID_abs   ::= ID (first is uppercase, contains lowercase)    // data and code abstractions\nID_field ::= ID (first is not digit)                        // fields\nID_nat   ::= ID (first is underscore)                       // native symbols\nID_type  ::= ( ID_nat | ID_abs                              // types\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n\n\n\nDeclarations for \ncode\n and \ndata\n [TODO-abstractions] create new [types] which can\nbe used as type identifiers.\n\n\nExamples:\n\n\nvar int a;                    // \na\n is a variable, \nint\n is a type\nemit e;                       // \ne\n is an internal event\nawait E;                      // \nE\n is an external input event\nspawn Move();                 // \nMove\n is a code abstraction and a type\nvar Rect r;                   // \nRect\n is a data abstraction and a type\nreturn r.width;               // \nwidth\n is a field\n_printf(\nhello world!\\n\n);    // \n_printf\n is a native symbol\n\n\n\n\nLiterals\n\n\nBooleans\n\n\nThe boolean type has two values, \ntrue\n and \nfalse\n.\n\n\nIntegers\n\n\nInteger values can be written in decimal and hexadecimal bases:\n\n\n\n\nDecimals are written \nas is\n.\n\n\nHexadecimals are prefixed with \n0x\n.\n\n\nTODO: \"0b---\", \"0o---\"\n\n\n\n\nExamples:\n\n\n// both are equal to the decimal 127\nv = 127;\nv = 0x7F;\n\n\n\n\nFloats\n\n\nTODO (like C)\n\n\nNull pointer\n\n\nThe \nnull\n literal represents null \npointers\n.\n\n\nStrings\n\n\nA sequence of characters surrounded by \n\"\n is converted into a \nnull-terminated \nstring\n, just like in C:\n\n\nExample:\n\n\n_printf(\nHello World!\\n\n);\n\n\n\n\nComments\n\n\nC\u00e9u provides C-style comments.\n\n\nSingle-line comments begin with \n//\n and run to end of the line.\n\n\nMulti-line comments use \n/*\n and \n*/\n as delimiters.\nMulti-line comments can be nested by using a different number of \n*\n as\ndelimiters.\n\n\nExamples:\n\n\nvar int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/020-lexical_rules/#lexical-rules", 
            "text": "", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/020-lexical_rules/#keywords", 
            "text": "Keywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):      and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    loop            lua             native          new             nohold          \n\n    not             nothing         null            or              outer           \n\n    output          par             pause           plain           pool            \n\n    pos             pre             pure            recursive       request         \n\n    resume          sizeof          spawn           then            thread\n\n    tight           traverse        true            until           val\n\n    var             vector          watching        with            bool\n\n    byte            f32             f64             float           int\n\n    s16             s32             s64             s8              ssize\n\n    u16             u32             u64             u8              uint\n\n    usize           void", 
            "title": "Keywords"
        }, 
        {
            "location": "/020-lexical_rules/#identifiers", 
            "text": "C\u00e9u uses identifiers to refer to  types ,  variables ,  vectors ,  pools , internal events ,  external events ,  code abstractions ,  data abstractions , fields ,  native symbols , and  block labels .  ID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID (first is lowercase)                        // variables, vectors, pools, internal events, and block labels\nID_ext   ::= ID (all in uppercase, first is not digit)      // external events\nID_abs   ::= ID (first is uppercase, contains lowercase)    // data and code abstractions\nID_field ::= ID (first is not digit)                        // fields\nID_nat   ::= ID (first is underscore)                       // native symbols\nID_type  ::= ( ID_nat | ID_abs                              // types\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )  Declarations for  code  and  data  [TODO-abstractions] create new [types] which can\nbe used as type identifiers.  Examples:  var int a;                    //  a  is a variable,  int  is a type\nemit e;                       //  e  is an internal event\nawait E;                      //  E  is an external input event\nspawn Move();                 //  Move  is a code abstraction and a type\nvar Rect r;                   //  Rect  is a data abstraction and a type\nreturn r.width;               //  width  is a field\n_printf( hello world!\\n );    //  _printf  is a native symbol", 
            "title": "Identifiers"
        }, 
        {
            "location": "/020-lexical_rules/#literals", 
            "text": "", 
            "title": "Literals"
        }, 
        {
            "location": "/020-lexical_rules/#booleans", 
            "text": "The boolean type has two values,  true  and  false .", 
            "title": "Booleans"
        }, 
        {
            "location": "/020-lexical_rules/#integers", 
            "text": "Integer values can be written in decimal and hexadecimal bases:   Decimals are written  as is .  Hexadecimals are prefixed with  0x .  TODO: \"0b---\", \"0o---\"   Examples:  // both are equal to the decimal 127\nv = 127;\nv = 0x7F;", 
            "title": "Integers"
        }, 
        {
            "location": "/020-lexical_rules/#floats", 
            "text": "TODO (like C)", 
            "title": "Floats"
        }, 
        {
            "location": "/020-lexical_rules/#null-pointer", 
            "text": "The  null  literal represents null  pointers .", 
            "title": "Null pointer"
        }, 
        {
            "location": "/020-lexical_rules/#strings", 
            "text": "A sequence of characters surrounded by  \"  is converted into a  null-terminated \nstring , just like in C:  Example:  _printf( Hello World!\\n );", 
            "title": "Strings"
        }, 
        {
            "location": "/020-lexical_rules/#comments", 
            "text": "C\u00e9u provides C-style comments.  Single-line comments begin with  //  and run to end of the line.  Multi-line comments use  /*  and  */  as delimiters.\nMulti-line comments can be nested by using a different number of  *  as\ndelimiters.  Examples:  var int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Comments"
        }, 
        {
            "location": "/030-types/", 
            "text": "Types\n\n\nC\u00e9u is statically typed, requiring all variables and events to be declared\nbefore they are used.\n\n\nA type is composed of a \ntype identifier\n, followed by a sequence\nof optional \npointer\n modifiers \n, and an optional \noption\n modifier \n?\n:\n\n\nType ::= ID_type {`\n\u00b4} [`?\u00b4]\n\n\n\n\nExamples:\n\n\nvar u8     v;   // \nv\n is of 8-bit unsigned integer type\nvar _rect  r;   // \nr\n is of external native type \nrect\n\nvar byte\n buf; // \nbuf\n is a pointer to a \nbyte\n\nvar Tree   t;   // \nt\n is a data of type \nTree\n\n\n\n\n\nPrimitive Types\n\n\nC\u00e9u has the following primitive types:\n\n\nvoid               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integer\ns16      u16       // signed and unsigned 16-bit integer\ns32      u32       // signed and unsigned 32-bit integer\ns64      u64       // signed and unsigned 64-bit integer\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types\n\n\n\n\nSee also the \nliterals\n for these types.\n\n\nNative Types\n\n\nTypes defined externally in C can be prefixed by \n_\n to be used in C\u00e9u programs.\n\n\nExample:\n\n\nvar _message_t msg;      // \nmessage_t\n is a C type defined in an external library\n\n\n\n\nNative types support [TODO-annotations] to provide additional information to\nthe compiler.\n\n\nAbstraction Types\n\n\nTODO (brief description)\n\n\nSee also \nAbstractions\n.\n\n\nType Modifiers\n\n\nTypes can be suffixed with the following modifiers: \n, \n?\n.\n\n\nPointer\n\n\nTODO (like C)\n\n\nTODO: restrictions\n    - cannot cross yielding statements\n\n\nOption\n\n\nTODO (like Maybe)", 
            "title": "Types"
        }, 
        {
            "location": "/030-types/#types", 
            "text": "C\u00e9u is statically typed, requiring all variables and events to be declared\nbefore they are used.  A type is composed of a  type identifier , followed by a sequence\nof optional  pointer  modifiers  , and an optional  option  modifier  ? :  Type ::= ID_type {` \u00b4} [`?\u00b4]  Examples:  var u8     v;   //  v  is of 8-bit unsigned integer type\nvar _rect  r;   //  r  is of external native type  rect \nvar byte  buf; //  buf  is a pointer to a  byte \nvar Tree   t;   //  t  is a data of type  Tree", 
            "title": "Types"
        }, 
        {
            "location": "/030-types/#primitive-types", 
            "text": "C\u00e9u has the following primitive types:  void               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integer\ns16      u16       // signed and unsigned 16-bit integer\ns32      u32       // signed and unsigned 32-bit integer\ns64      u64       // signed and unsigned 64-bit integer\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types  See also the  literals  for these types.", 
            "title": "Primitive Types"
        }, 
        {
            "location": "/030-types/#native-types", 
            "text": "Types defined externally in C can be prefixed by  _  to be used in C\u00e9u programs.  Example:  var _message_t msg;      //  message_t  is a C type defined in an external library  Native types support [TODO-annotations] to provide additional information to\nthe compiler.", 
            "title": "Native Types"
        }, 
        {
            "location": "/030-types/#abstraction-types", 
            "text": "TODO (brief description)  See also  Abstractions .", 
            "title": "Abstraction Types"
        }, 
        {
            "location": "/030-types/#type-modifiers", 
            "text": "Types can be suffixed with the following modifiers:  ,  ? .", 
            "title": "Type Modifiers"
        }, 
        {
            "location": "/030-types/#pointer", 
            "text": "TODO (like C)  TODO: restrictions\n    - cannot cross yielding statements", 
            "title": "Pointer"
        }, 
        {
            "location": "/030-types/#option", 
            "text": "TODO (like Maybe)", 
            "title": "Option"
        }, 
        {
            "location": "/040-storage_classes/", 
            "text": "Storage Classes\n\n\nStorage classes represent all entities that are stored in memory at runtime.\nC\u00e9u supports \nvariables\n, \nvectors\n, \nevents\n (external and internal), and\n\npools\n as storage classes.\nAn entity \ndeclaration\n consists of a storage class,\na \ntype\n, and an \nidentifier\n.\n\n\nExamples:\n\n\nvar       int    v;     // \nv\n is a variable of type \nint\n\nvector[9] byte   buf;   // \nbuf\n is a vector with at most 9 values of type \nbyte\n\ninput     void\n A;     // \nA\n is an external event that carries values of type \nvoid\n\npool[]    Anim   anims; // \nanims\n is a dynamic \npool\n for instances of type \nAnim\n\n\n\n\n\nA declaration binds the identifier with a memory location to hold values of the\nassociated type.\n\n\nLexical Scope\n\n\nStorage entities have lexical scope, i.e., they are visible only in the\n\nblock\n in which they are declared.\nThe lifetime of entities, (i.e., the period between allocation and deallocation\nin memory) is also limited to the scope of the enclosing block.\nHowever, individual elements inside \nvector\n and \npool\n entities have dynamic\nlifetime, but which never outlive the scope of the declaration.\n\n\nVariables\n\n\nAs in typical imperative languages, a variable in C\u00e9u holds a value of a\n\ndeclared\n \ntype\n that may vary during program execution.\nThe value of a variable can be read in \nexpressions\n or written in\n\nassignments\n.\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.\n\n\n\n\n\nNote: since blocks can contain parallel compositions, variables can be read\n       and written in trails in parallel.\n\n\nExample:\n\n\nvar int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)\n\n\n\n\nVectors\n\n\nIn C\u00e9u, a vector is a dynamic and contiguous collection of elements of the same\ntype.\nA vector \ndeclaration\n specifies its type and maximum number of\nelements (possibly unlimited).\nThe current size of a vector is dynamic and can be accessed through the\n\noperator \n$\n.\nIndividual elements of a vector can be accessed through a\n\nnumeric index\n starting from \n0\n.\n\n\nExample:\n\n\nvector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)\n\n\n\n\nEvents\n\n\nEvents are the most fundamental concept of C\u00e9u, accounting for its reactive \nnature.\nPrograms manipulate events through the \nawait\n and \nemit\n \nstatements\n.\nAn \nawait\n halts the running trail until that event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.\n\n\nAs described in the \nIntroduction\n, C\u00e9u supports external and internal events\nwith different behaviors.\n\n\nUnlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through \nemit\n and \nawait\n statements.\nA \ndeclaration\n includes the type of value the occurring event carries.\n\n\nNote: \nvoid\n is a valid type for signal-only internal events.\n\n\nExample:\n\n\ninput  void I;           // \nI\n is an external input event that carries no valuess\noutput int  O;           // \nO\n is an external output event that values of type \nint\n\nevent  int  e;           // \ne\n is an internal event that carries values of type \nint\n\npar/and do\n    await I;             // awakes when \nI\n occurs\n    emit e(10);          // broadcasts \ne\n passing 10, awakes the \nawait\n below\nwith\n    var int v = await e; // awaits \ne\n assigning the received value to \nv\n\n    emit O(v);           // emits \nO\n back to the environment passing \nv\n\nend\n\n\n\n\nExternal Events\n\n\nExternal events are used as interfaces between programs and devices from the \nreal world:\n\n\n\n\ninput\n events represent input devices, such as sensors, switches, etc.\n\n\noutput\n events represent output devices, such as LEDs, motors, etc.\n\n\n\n\nThe availability of external events depends on the platform in use.\nTherefore, external declarations only make pre-existing events visible to a \nprogram.\nRefer to \nEnvironment\n for information about interfacing with \nexternal events at the platform level.\n\n\nExternal Input Events\n\n\nAs a reactive language, programs in C\u00e9u have input events as entry points in\nthe code through \nawait statements\n.\nInput events represent the notion of \nlogical time\n in C\u00e9u.\n\n\nOnly the \nenvironment\n can emit inputs to the application.\nPrograms can only \nawait\n input events.\n\n\nExternal Output Events\n\n\nOutput events communicate values from the program back to the\n\nenvironment\n.\n\n\nPrograms can only \nemit\n output events.\n\n\nInternal Events\n\n\nInternal events serve as signalling and communication mechanisms between\ntrails in a program.\n\n\nPrograms can \nemit\n and \nawait\n internal events.\n\n\nPools\n\n\nA pool is a dynamic container to hold running \ncode abstractions\n.\nA pool \ndeclaration\n specifies the type of the abstraction and maximum\nnumber of concurrent instances (possibly unlimited).\nIndividual elements of a pool can only be accessed through \niterators\n.\nNew elements are created with \nspawn\n and are removed automatically when and\nonly the code execution terminates.\n\n\nExample:\n\n\ncode/await Anim (void) =\n void do       // defines a code abstraction\n    ...\nend\npool[] Anim ms;                         // declares an unlimited container for \nMove\n instances\nloop i in [0-\n10[ do\n    spawn Anim() in ms;                 // creates 10 instances of \nAnim\n into \nms\n\nend\n\n\n\n\nWhen a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.\n\n\nReferences\n\n\nC\u00e9u supports \naliases\n and \npointers\n as references to entities\n(a.k.a. as \nstrong\n and \nweak\n references, respectively).\n\n\nAn alias is an alternate view for an entity---after the entity and alias are\nbounded, they are indistinguishable.\nA pointer is the address of an entity and provides indirect access to it.\n\n\nAs an analogy with a person's identity,\na family nickname used by her family to refer to her is an alias;\na job position used by her company to refer to her is a pointer.\n\n\nAliases\n\n\nAn alias is \ndeclared\n by suffixing the storage class with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\n\n\nExample:\n\n\nvar  int v = 0;\nvar\n int a = \nv;        // \na\n is an alias to \nv\n\n...\na = 1;                  // \na\n and \nv\n are indistinguishable\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nAn alias must have a narrower scope than the entity it refers to.\nThe \nbinding\n to the alias is immutable and must occur between its\ndeclaration and first access or next \nyielding statement\n.\nIt is not possible to acquire aliases to external events or to pointer types.\n\n\nTODO: \n?\n\n\nPointers\n\n\nA pointer is \ndeclared\n by suffixing the type with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\nApplying the operator \n*\n to a pointer provides indirect access to its\nreferenced entity.\n\n\nExample:\n\n\nvar int   v = 0;\nvar int\n p = \nv;      // \np\n holds a pointer to \nv\n\n...\n*p = 1;                 // \np\n provides indirect access to \nv\n\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nC\u00e9u only supports pointers to \nprimitive\n and\n\ndata abstraction\n types.\nAlso, it is only possible to acquire pointers to variables (not to events,\nvectors, or pools).\nHowever, a variable of a pointer type is only visible between its declaration\nand the next \nyielding statement\n.", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/040-storage_classes/#storage-classes", 
            "text": "Storage classes represent all entities that are stored in memory at runtime.\nC\u00e9u supports  variables ,  vectors ,  events  (external and internal), and pools  as storage classes.\nAn entity  declaration  consists of a storage class,\na  type , and an  identifier .  Examples:  var       int    v;     //  v  is a variable of type  int \nvector[9] byte   buf;   //  buf  is a vector with at most 9 values of type  byte \ninput     void  A;     //  A  is an external event that carries values of type  void \npool[]    Anim   anims; //  anims  is a dynamic  pool  for instances of type  Anim   A declaration binds the identifier with a memory location to hold values of the\nassociated type.", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/040-storage_classes/#lexical-scope", 
            "text": "Storage entities have lexical scope, i.e., they are visible only in the block  in which they are declared.\nThe lifetime of entities, (i.e., the period between allocation and deallocation\nin memory) is also limited to the scope of the enclosing block.\nHowever, individual elements inside  vector  and  pool  entities have dynamic\nlifetime, but which never outlive the scope of the declaration.", 
            "title": "Lexical Scope"
        }, 
        {
            "location": "/040-storage_classes/#variables", 
            "text": "As in typical imperative languages, a variable in C\u00e9u holds a value of a declared   type  that may vary during program execution.\nThe value of a variable can be read in  expressions  or written in assignments .\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.   Note: since blocks can contain parallel compositions, variables can be read\n       and written in trails in parallel.  Example:  var int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)", 
            "title": "Variables"
        }, 
        {
            "location": "/040-storage_classes/#vectors", 
            "text": "In C\u00e9u, a vector is a dynamic and contiguous collection of elements of the same\ntype.\nA vector  declaration  specifies its type and maximum number of\nelements (possibly unlimited).\nThe current size of a vector is dynamic and can be accessed through the operator  $ .\nIndividual elements of a vector can be accessed through a numeric index  starting from  0 .  Example:  vector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)", 
            "title": "Vectors"
        }, 
        {
            "location": "/040-storage_classes/#events", 
            "text": "Events are the most fundamental concept of C\u00e9u, accounting for its reactive \nnature.\nPrograms manipulate events through the  await  and  emit   statements .\nAn  await  halts the running trail until that event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.  As described in the  Introduction , C\u00e9u supports external and internal events\nwith different behaviors.  Unlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through  emit  and  await  statements.\nA  declaration  includes the type of value the occurring event carries.  Note:  void  is a valid type for signal-only internal events.  Example:  input  void I;           //  I  is an external input event that carries no valuess\noutput int  O;           //  O  is an external output event that values of type  int \nevent  int  e;           //  e  is an internal event that carries values of type  int \npar/and do\n    await I;             // awakes when  I  occurs\n    emit e(10);          // broadcasts  e  passing 10, awakes the  await  below\nwith\n    var int v = await e; // awaits  e  assigning the received value to  v \n    emit O(v);           // emits  O  back to the environment passing  v \nend", 
            "title": "Events"
        }, 
        {
            "location": "/040-storage_classes/#external-events", 
            "text": "External events are used as interfaces between programs and devices from the \nreal world:   input  events represent input devices, such as sensors, switches, etc.  output  events represent output devices, such as LEDs, motors, etc.   The availability of external events depends on the platform in use.\nTherefore, external declarations only make pre-existing events visible to a \nprogram.\nRefer to  Environment  for information about interfacing with \nexternal events at the platform level.", 
            "title": "External Events"
        }, 
        {
            "location": "/040-storage_classes/#external-input-events", 
            "text": "As a reactive language, programs in C\u00e9u have input events as entry points in\nthe code through  await statements .\nInput events represent the notion of  logical time  in C\u00e9u.  Only the  environment  can emit inputs to the application.\nPrograms can only  await  input events.", 
            "title": "External Input Events"
        }, 
        {
            "location": "/040-storage_classes/#external-output-events", 
            "text": "Output events communicate values from the program back to the environment .  Programs can only  emit  output events.", 
            "title": "External Output Events"
        }, 
        {
            "location": "/040-storage_classes/#internal-events", 
            "text": "Internal events serve as signalling and communication mechanisms between\ntrails in a program.  Programs can  emit  and  await  internal events.", 
            "title": "Internal Events"
        }, 
        {
            "location": "/040-storage_classes/#pools", 
            "text": "A pool is a dynamic container to hold running  code abstractions .\nA pool  declaration  specifies the type of the abstraction and maximum\nnumber of concurrent instances (possibly unlimited).\nIndividual elements of a pool can only be accessed through  iterators .\nNew elements are created with  spawn  and are removed automatically when and\nonly the code execution terminates.  Example:  code/await Anim (void) =  void do       // defines a code abstraction\n    ...\nend\npool[] Anim ms;                         // declares an unlimited container for  Move  instances\nloop i in [0- 10[ do\n    spawn Anim() in ms;                 // creates 10 instances of  Anim  into  ms \nend  When a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.", 
            "title": "Pools"
        }, 
        {
            "location": "/040-storage_classes/#references", 
            "text": "C\u00e9u supports  aliases  and  pointers  as references to entities\n(a.k.a. as  strong  and  weak  references, respectively).  An alias is an alternate view for an entity---after the entity and alias are\nbounded, they are indistinguishable.\nA pointer is the address of an entity and provides indirect access to it.  As an analogy with a person's identity,\na family nickname used by her family to refer to her is an alias;\na job position used by her company to refer to her is a pointer.", 
            "title": "References"
        }, 
        {
            "location": "/040-storage_classes/#aliases", 
            "text": "An alias is  declared  by suffixing the storage class with the modifier  and is acquired by prefixing an entity with the operator  .  Example:  var  int v = 0;\nvar  int a =  v;        //  a  is an alias to  v \n...\na = 1;                  //  a  and  v  are indistinguishable\n_printf( %d\\n , v);     // prints 1  An alias must have a narrower scope than the entity it refers to.\nThe  binding  to the alias is immutable and must occur between its\ndeclaration and first access or next  yielding statement .\nIt is not possible to acquire aliases to external events or to pointer types.  TODO:  ?", 
            "title": "Aliases"
        }, 
        {
            "location": "/040-storage_classes/#pointers", 
            "text": "A pointer is  declared  by suffixing the type with the modifier  and is acquired by prefixing an entity with the operator  .\nApplying the operator  *  to a pointer provides indirect access to its\nreferenced entity.  Example:  var int   v = 0;\nvar int  p =  v;      //  p  holds a pointer to  v \n...\n*p = 1;                 //  p  provides indirect access to  v \n_printf( %d\\n , v);     // prints 1  C\u00e9u only supports pointers to  primitive  and data abstraction  types.\nAlso, it is only possible to acquire pointers to variables (not to events,\nvectors, or pools).\nHowever, a variable of a pointer type is only visible between its declaration\nand the next  yielding statement .", 
            "title": "Pointers"
        }, 
        {
            "location": "/050-statements/", 
            "text": "Statements\n\n\nA program in C\u00e9u is a sequence of statements delimited by an enclosing block as\nfollows:\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\n\n\n\nNote: statements terminated with the \nend\n keyword do not require a\nterminating semicolon.\n\n\nBlocks\n\n\nA \nBlock\n creates a new scope for \nstorage entities\n which are visible\nonly for statements inside the block.\n\n\nCompound statements (e.g. \ndo-end\n, \nif-then-else\n, \nloops\n, etc.) create new\nblocks and can be nested to an arbitrary level.\n\n\ndo-end\n and \nescape\n\n\nThe \ndo-end\n statement creates an explicit block with an optional identifier.\nThe \nescape\n statement aborts the deepest enclosing \ndo-end\n matching its\nidentifier:\n\n\nDo ::= do [`/\u00b4 (`_\u00b4|ID_int)]\n           Block\n       end\n\nEscape ::= escape [`/\u00b4ID_int] [Exp]\n\n\n\n\nA \ndo-end\n supports the identifier \n_\n which is guaranteed not to match any\n\nescape\n statement.\n\n\nExample:\n\n\ndo/a\n    do/_\n        do\n            escape;     // matches line 3\n        end\n        escape/a;       // matches line 1\n    end\nend\n\n\n\n\npre-do-end\n\n\nThe \npre-do-end\n statement prepends its statements in the beginning of the\nprogram:\n\n\nPre_Do ::= pre do\n               Block\n           end\n\n\n\n\nAll \npre-do-end\n statements are concatenated together in the order they appear\nand moved to the beginning of the top-level block, before all other statements.\n\n\n\n\nDeclarations\n\n\nA declaration exposes a \nstorage entity\n to the program.\nIts \nscope\n begins after the declaration and goes until the end of the\nenclosing \nblock\n.\n\n\nC\u00e9u supports variables, vectors, external events, internal events, and pools:\n\n\nVar    ::= var [`\n\u00b4|`\n?\u00b4] Type LIST(ID_int [`=\u00b4 Set])\nVector ::= vector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\nExt    ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n        |  output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\nInt    ::= event [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])\nPool   ::= pool [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n\n\n\n\nSee also \nStorage Classes\n for an overview of storage entities.\n\n\nVariables\n\n\nA variable has an associated \ntype\n and can be optionally\n\ninitialized\n.\nA single statement can declare multiple variables of the same type.\nDeclarations can also be \naliases\n or \noption aliases\n.\n\n\nExamples:\n\n\nvar  int v = 10;    // \nv\n is an integer variable initialized to 10\nvar  int a=0, b=3;  // \na\n and \nb\n are integer variables initialized to 0 and 3\nvar\n int z = \nv;    // \nz\n is an alias to \nv\n\n\n\n\n\nVectors\n\n\nA vector has a dimension, an associated \ntype\n and can be optionally\n\ninitialized\n.\nA single statement can declare multiple vectors of the same dimension and type.\nDeclarations can also be \naliases\n.\n\n\nThe expression between the brackets specifies the dimension of the vector with\nthe options that follow:\n\n\n\n\nconstant expression\n: Maximum number of elements is fixed and space is\n                         statically pre-allocated.\n\n\nvariable expression\n: Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.\n\n\nomitted\n: Maximum number of elements is unbounded and space is dynamically\n             allocated.\n\n\n\n\nThe space for dynamic vectors grow and shrink automatically.\n\n\nExamples:\n\n\nvar int n = 10;\nvector[10] int vs1 = [];    // \nvs1\n is a static vector of 10 elements max\nvector[n]  int vs2 = [];    // \nvs2\n is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    // \nvs3\n is an unbounded vector\nvector\n[]  int vs4 = \nvs1;  // \nvs4\n is an alias to \nvs1\n\n\n\n\n\nEvents\n\n\nAn event has a \ntype\n for the value it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.\n\n\nSee also \nIntroduction\n for a general overview of events.\n\n\nExternal events\n\n\nExamples:\n\n\ninput  void A,B;        // \nA\n and \nB\n are input events carrying no values\noutput int  MY_EVT;     // \nMY_EVT\n is an output event carrying integer values\ninput (int,byte\n) BUF; // \nBUF\n is an input event carrying an \n(int,byte\n)\n pair\n\n\n\n\nInternal events\n\n\nDeclarations for internal events can also be \naliases\n or\n\noption aliases\n.\nOnly in this case they can contain an \ninitialization\n.\n\n\nExamples:\n\n\nevent  void a,b;        // \na\n and \nb\n are internal events carrying no values\nevent\n void z = \na;     // \nz\n is an alias to event \na\n\nevent (int,int) c;      // \nc\n is a internal event carrying an \n(int,int)\n pair\n\n\n\n\nPools\n\n\nTODO\n\n\nSee also \nCode Pools\n and \nData Pools\n.\n\n\n\n\nEvent Handling\n\n\nAwait\n\n\nThe \nawait\n statement halts the running trail until the referred\nevent occurs.\nThe event can be an \nexternal input event\n, an \ninternal event\n,\na timer, a \npausing event\n, or forever (i.e., never awake):\n\n\nAwait ::= await (ID_ext | Name) [until Exp]     /* events */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */\n\n\n\n\nExamples:\n\n\nawait A;                  // awaits the input event `A`\nawait a;                  // awaits the internal event `a`\n\nawait 10min3s5ms100us;    // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable `t` in milliseconds\n\nawait FOREVER;            // awaits forever\n\n\n\n\nAn \nawait\n evaluates to zero or more values which can be captured with an\noptional \nassignment\n.\n\n\nEvents\n\n\nThe \nawait\n statement for events halts the running trail until the referred\n\nexternal input event\n or  \ninternal event\n occurs.\n\n\nThe \nawait\n evaluates to a value of the type of the event.\n\n\nThe optional clause \nuntil\n tests an additional condition required to awake.\nThe condition can use the returned value from the \nawait\n.\nIt expands to a \nloop\n as follows:\n\n\nloop do\n    \nret\n = await \nevt\n;\n    if \nExp\n then   // \nExp\n can use \nret\n\n        break;\n    end\nend\n\n\n\n\nExamples:\n\n\ninput int E;                    // \nE\n is an external input event carrying \nint\n values\nvar int v = await E until v\n10; // assigns occurring \nE\n to \nv\n, awaking when \nv\n10\n\n\nevent (bool,int) e;             // \ne\n is an internal event carrying \n(bool,int)\n pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on \ne\n and assigns its values to \nv1\n and \nv2\n\n\n\n\n\nTimers\n\n\nThe \nawait\n statement for timers halts the running trail until the referred\ntimer expires.\n\n\nWCLOCKK\n specifies a constant time expressed as a sequence of value/unit\npairs.\n\nWCLOCKE\n specifies an expression in parenthesis followed by a single unit of\ntime.\n\n\nThe \nawait\n evaluates to a value of type \ns32\n and is the\n\nresidual delta time (dt)\n measured in microseconds.\nIs is the difference between the actual elapsed time and the requested time.\n\n\nExamples:\n\n\nvar int t = \n...\n;\nawait (t)ms;                            // awakes after \nt\n milliseconds\n\nvar int dt = await 1min10s30ms100us;    // if 1min10s31ms000us elapses, then dt=900\n\n\n\n\nNote: The residual \ndt\n is always greater than or equal to 0.\n\n\n\n\n\nPausing\n\n\nPausing events are dicussed in \nPausing\n.\n\n\nFOREVER\n\n\nThe \nawait\n statement for \nFOREVER\n halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.\n\n\nif \ncnd\n then\n    await FOREVER;  // this trail never awakes if the condition is true\nend\n\n\n\n\nEmit\n\n\nThe \nemit\n statement broadcasts an event to the whole program.\nThe event can be an \nexternal event\n, an \ninternal event\n, or\na timer:\n\n\nEmit ::= emit (ID_ext | Name) [`(\u00b4 [LIST(Exp)] `)\u00b4)]\n      |  emit (WCLOCKK|WCLOCKE)\n\n\n\n\nExamples:\n\n\nemit A;         // emits the external event `A` of type \nvoid\n\nemit a(1);      // emits the internal event `a` of type \nint\n\n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds\n\n\n\n\nEvents\n\n\nThe \nemit\n statement for events expects a specific number of arguments matching\nthe event type (unless the event is of type \nvoid\n).\n\n\n\n\nAn \nemit\n to an external input or timer event can only occur inside\n  \nasynchronous blocks\n.\n\n\nAn \nemit\n to an external output event is also an expression that evaluates\n  to a value of type \ns32\n (its meaning is \nplatform dependent\n).\n\n\nAn \nemit\n to an internal event starts a new \ninternal reaction\n.\n\n\n\n\nExamples:\n\n\ninput int I;\nasync do\n    emit I(10);         // broadcasts \nI\n to the application itself, passing \n10\n\nend\n\noutput void O;\nvar int ret = emit O(); // outputs \nO\n to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts \ne\n passing a pair of \nint\n values\n\n\n\n\nTimers\n\n\nThe \nemit\n statement for timers expects an expression of time as described in\n\nAwait Timer\n.\n\n\nLike input events, time can only be emitted inside \nasynchronous \nblocks\n.\n\n\nExamples:\n\n\nasync do\n    emit 1s;    // broadcasts \n1s\n to the application itself\nend\n\n\n\n\n\n\nConditional\n\n\nThe \nif-then-else\n statement provides conditionals in C\u00e9u:\n\n\nIf ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end\n\n\n\n\nEach condition \nExp\n is tested in sequence, first for the \nif\n clause and then\nfor each of the optional \nelse/if\n clauses.\nFor the first condition that evaluates to \ntrue\n, the \nBlock\n following it\nexecutes.\nIf all conditions fail, the optional \nelse\n clause executes.\n\n\nAll conditions must evaluate to a value of type \nbool\n, which is\nchecked at compile time.\n\n\nLoops\n\n\nC\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:\n\n\nLoop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] Numeric do    /* Numeric ::= (see \nNumeric Iterators\n) */\n            Block\n        end\n\n      /* event iterator */\n      | every [(Name | `(\u00b4 LIST(Name|`_\u00b4) `)\u00b4) in] (ID_ext|Name|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Name do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]\n\n\n\n\nThe \nBlock\n body of a loop executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.\n\n\nExcept for the \nevery\n iterator, all loops support an optional\n\n/\nExp\n to limit the maximum number of iterations and\navoid \ninfinite execution\n.\nThe expression must be a constant evaluated at compile time.\n\n\nbreak\n and \ncontinue\n\n\nThe \nbreak\n statement aborts the deepest enclosing loop.\n\n\nThe \ncontinue\n statement aborts the body of the deepest enclosing loop and\nrestarts in the next iteration.\n\n\nThe optional \n/\nID_int\n in both statements only applies\nto \nnumeric iterators\n.\n\n\nSimple Loops\n\n\nA simple loop executes its body continually and forever.\n\n\nExamples:\n\n\n// blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend\n\n\n\n\nloop do\n    loop do\n        if \ncnd-1\n then\n            break;      // aborts the loop at line 2 if \ncnd-1\n is satisfied\n        end\n    end\n    if \ncnd-2\n then\n        continue;       // restarts the loop at line 1 if \ncnd-2\n is satisfied\n    end\nend\n\n\n\n\nNumeric Iterators\n\n\nThe numeric loop modifies the value of a control variable on each iteration\naccording to the specification of an optional interval as follows:\n\n\nNumeric ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                  ( (     Exp `-\n\u00b4 (`_\u00b4|Exp))\n                                  | (`_\u00b4|Exp) `\n-\u00b4 Exp      ) )\n                              (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]\n\n\n\n\nThe control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:\n\n\n\n\ncontrol variable:\n\n    \nID_int\n is a variable of a \nnumeric type\n.\n    Alternatively, the special anonymous identifier \n_\n can be used if the body\n    of the loop does not access the variable.\n    The control variable is marked as \nread-only\n and cannot be changed\n    explicitly.\n\n\ninterval:\n\n    Specifies a direction, endpoints with open or closed modifiers, and a step.\n\n\ndirection\n:\n\n\n-\n: Starts from the endpoint \nExp\n on the left increasing towards \nExp\n on the right.\n\n\n-\n: Starts from the endpoint \nExp\n on the right decreasing towards \nExp\n on the left.\nTypically, the value on the left should always be smaller or equal to\nthe value on the right.\n\n\n\n\n\n\nendpoints\n:\n    \n[Exp\n and \nExp]\n are closed intervals which include \nExp\n as the\n    endpoints;\n    \n]Exp\n and \nExp[\n are open intervals which exclude \nExp\n as the\n    endpoints.\n    Alternatively, the finishing endpoint may be \n_\n which means that the\n    interval goes towards infinite.\n\n\nstep\n:\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value \n1\n.\n    If the direction is \n-\n, the step is added, otherwise it is subtracted.\nIf the interval is not specified, it assumes the default \n[0 -\n _]\n.\n\n\n\n\n\n\n\n\nThe numeric iterator executes as follows:\n\n\n\n\ninitialization:\n\n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step.\n\n\niteration:\n\n\nlimits test:\n\n    If the control variable crossed the finishing endpoint, the loop\n    terminates.\n\n\nbody execution:\n\n    The loop body executes.\n\n\nstep\n\n    Applies a step to the control variable. Goto step \n1\n.\n\n\n\n\n\n\n\n\nThe \nbreak\n and \ncontinue\n statements inside numeric iterators accept an\noptional modifier \n/\nID_int\n to match the control\nvariable of the enclosing loop to affect.\n\n\nExamples:\n\n\n// prints \ni=0\n, \ni=1\n, ...\nvar int i;\nloop i do\n    _printf(\ni=%d\\n\n, i);\nend\n\n\n\n\n// awaits 1s and prints \nHello World!\n 10 times\nloop _ in [0 -\n 10[ do\n    await 1s;\n    _printf(\nHello World!\\n\n);\nend\n\n\n\n\nvar int i;\nloop i do\n    var int j;\n    loop j do\n        if \ncnd-1\n then\n            continue/i;         // continues the loop at line 1\n        else/if \ncnd-2\n then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend\n\n\n\n\nNote : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.\n\n\nPool Iterators\n\n\nPool iterators are dicussed in \nCode Pools\n.\n\n\n\n\nParallel Compositions\n\n\nThe parallel statements \npar/and\n, \npar/or\n, and \npar\n split the running trail \nin multiple others:\n\n\nPars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nWatching ::= watching LIST(ID_ext|Name|WCLOCKK|WCLOCKE|Code2) do\n                 Block\n             end\n\n\n\n\n\nThey differ only on how trails rejoin and terminate the composition.\n\n\nThe \nwatching\n statement terminates when one of its listed events occur.\n\n\nSee also \nParallel Compositions and Abortion\n.\n\n\npar\n\n\nThe \npar\n statement never rejoins.\n\n\nExamples:\n\n\n// reacts continuously to \n1s\n and \nKEY_PRESSED\n and never terminates\ninput void KEY_PRESSED;\npar do\n    every 1s do\n        \n...\n           // does something every \n1s\n\n    end\nwith\n    every KEY_PRESSED do\n        \n...\n           // does something every \nKEY_PRESSED\n\n    end\nend\n\n\n\n\npar/and\n\n\nThe \npar/and\n statement stands for \nparallel-and\n and rejoins when all trails \nterminate.\n\n\nExamples:\n\n\n// reacts once to \n1s\n and \nKEY_PRESSED\n and terminates\ninput void KEY_PRESSED;\npar/and do\n    await 1s;\n    \n...\n               // does something after \n1s\n\nwith\n    await KEY_PRESSED;\n    \n...\n               // does something after \nKEY_PRESSED\n\nend\n\n\n\n\npar/or\n\n\nThe \npar/or\n statement stands for \nparallel-or\n and rejoins when any of the \ntrails terminate, aborting all other trails.\n\n\nExamples:\n\n\n// reacts once to `1s` or `KEY_PRESSED` and terminates\ninput void KEY_PRESSED;\npar/or do\n    await 1s;\n    \n...\n               // does something after \n1s\n\nwith\n    await KEY_PRESSED;\n    \n...\n               // does something after \nKEY_PRESSED\n\nend\n\n\n\n\nwatching\n\n\nThe \nwatching\n statement accepts a list of events and terminates when any of\nthe events occur.\n\n\nA \nwatching\n expands to a \npar/or\n with \nn+1\n trails:\none to await each of the listed events,\nand one for its body, i.e.:\n\n\nwatching \ne1\n,\ne2\n,... do\n    \nbody\n\nend\n\n\n\n\nexpands to\n\n\npar/or do\n    await \ne1\n;\nwith\n    await \ne2\n;\nwith\n    ...\nwith\n    \nbody\n\nend\n\n\n\n\nExamples:\n\n\n// reacts continuously to \nKEY_PRESSED\n during \n1s\n\ninput void KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n        \n...\n           // does something every \nKEY_PRESSED\n\n    end\nend\n\n\n\n\n\n\nPausing\n\n\nThe \npause/if\n statement controls if its body should temporarily stop to react\nto events:\n\n\nPause_If ::= pause/if (Name|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)\n\n\n\n\nA \npause/if\n determines a pausing event of type \nbool\n which, when emitted,\ntoggles between pausing (\ntrue\n) and resuming (\nfalse\n) reactions for its body.\n\n\nWhen its body terminates, the whole \npause/if\n terminates and proceeds to the\nstatement in sequence.\n\n\nIn transition points, the body can react to the special \npause\n and \nresume\n\nevents before the corresponding state applies.\n\n\nTODO: finalize/pause/resume\n\n\nExamples:\n\n\nevent bool e;\npause/if e do       // pauses/resumes the nested body on each \ne\n\n    every 1s do\n        \n...\n       // does something every \n1s\n\n    end\nend\n\n\n\n\nevent bool e;\npause/if e do               // pauses/resumes the nested body on each \ne\n\n    \n...\n\n        loop do\n            await pause;\n            \n...\n           // does something before pausing\n            await resume;\n            \n...\n           // does something before resuming\n        end\n    \n...\n\nend\n\n\n\n\n\n\n\nAsynchronous Execution\n\n\nAsynchronous execution allow programs to execute time consuming computations \nwithout interfering with the responsiveness of the  \nsynchronous side\n of\napplications (i.e., all core language statements):\n\n\nAsync  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\nAtomic ::= atomic do\n               Block\n           end\n\n\n\n\nThe program awaits the termination of the asynchronous body to proceed to the\nstatement in sequence.\n\n\nAsynchronous blocks can contain \ntight loops\n but which keep the\napplication reactive to incoming events.\nHowever, they do not support nesting of asynchronous statements, and do not\nsupport synchronous control statements (i.e., parallel compositions, event\nhandling, pausing, etc.).\n\n\nBy default, asynchronous blocks do not shared variables with their enclosing\nscope.\nThe optional list of variables makes them visible to the block.\n\n\nAsynchronous Blocks\n\n\nAsynchronous blocks (\nasync\n) preserve deterministic execution with the rules\nas follows:\n\n\n\n\nResume execution whenever the synchronous side is idle.\n\n\nYield control to the synchronous side on every complete \nloop\n iteration.\n\n\nYield control to the synchronous side on every \nemit\n.\n\n\nExecute atomically and to completion unless rules \n2\n and \n3\n apply.\n\n\n\n\nThis rules imply that \nasync\n blocks and the synchronous side never run at the\nsame time with real parallelism.\n\n\nExamples:\n\n\n// calculates the factorial of some \nv\n if it doesn't take too long\nvar u64  v   = \n...\n;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps \nv\n and \nfat\n visible\n        loop i in [1 -\n v] do   // reads from \nv\n\n            fat = fat * i;      // writes to \nfat\n\n        end\n    end\n    ok = true;                  // completed within \n1s\n\nend\n\n\n\n\nSimulation\n\n\nAn \nasync\n block can emit \ninput events\n and the\n\npassage of time\n towards the synchronous side, providing a way to test\nprograms in the language itself.\nEvery time an \nasync\n emits an event, it suspends until the synchronous side\nreacts to the event (see \nrule 1\n above).\n\n\nExamples:\n\n\ninput int A;\n\n// tests a program with a simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -\n _[ do\n        await 10ms;\n        _printf(\nv = %d\\n\n, v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for \nv\n\n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v = \nv+i\n` exactly 103 times.\n\n\n\n\nAsynchronous Threads\n\n\nAsynchronous threads (\nasync/thread\n) provide real parallelism for applications\nin C\u00e9u.\nOnce an \nasync/thread\n starts, it runs completely detached from the synchronous\nside.\nHowever, they are still ruled by the synchronous side and are also subject to\nabortion.\n\n\nExamples:\n\n\n// calculates the factorial of some \nv\n if it doesn't take too long\nvar u64  v   = \n...\n;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps \nv\n and \nfat\n visible\n        loop i in [1 -\n v] do       // reads from \nv\n\n            fat = fat * i;          // writes to \nfat\n\n        end\n    end\n    ok = true;                      // completed within \n1s\n\nend\n\n\n\n\nAtomic Blocks\n\n\nAtomic blocks provide mutual exclusion among threads and the synchronous\nside of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.\n\n\nExamples:\n\n\n// A \nrace\n between two threads: one incrementing, the other decrementing \ncount\n.\n\nvar s64 count = 0;                              // \ncount\n is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf(\ncount = %d\\n\n, count);     // prints current value of \ncount\n every \n1s\n\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements \ncount\n as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments \ncount\n as fast as possible\n            end\n        end\n    end\nend", 
            "title": "Statements"
        }, 
        {
            "location": "/050-statements/#statements", 
            "text": "A program in C\u00e9u is a sequence of statements delimited by an enclosing block as\nfollows:  Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}  Note: statements terminated with the  end  keyword do not require a\nterminating semicolon.", 
            "title": "Statements"
        }, 
        {
            "location": "/050-statements/#blocks", 
            "text": "A  Block  creates a new scope for  storage entities  which are visible\nonly for statements inside the block.  Compound statements (e.g.  do-end ,  if-then-else ,  loops , etc.) create new\nblocks and can be nested to an arbitrary level.", 
            "title": "Blocks"
        }, 
        {
            "location": "/050-statements/#do-end-and-escape", 
            "text": "The  do-end  statement creates an explicit block with an optional identifier.\nThe  escape  statement aborts the deepest enclosing  do-end  matching its\nidentifier:  Do ::= do [`/\u00b4 (`_\u00b4|ID_int)]\n           Block\n       end\n\nEscape ::= escape [`/\u00b4ID_int] [Exp]  A  do-end  supports the identifier  _  which is guaranteed not to match any escape  statement.  Example:  do/a\n    do/_\n        do\n            escape;     // matches line 3\n        end\n        escape/a;       // matches line 1\n    end\nend", 
            "title": "do-end and escape"
        }, 
        {
            "location": "/050-statements/#pre-do-end", 
            "text": "The  pre-do-end  statement prepends its statements in the beginning of the\nprogram:  Pre_Do ::= pre do\n               Block\n           end  All  pre-do-end  statements are concatenated together in the order they appear\nand moved to the beginning of the top-level block, before all other statements.", 
            "title": "pre-do-end"
        }, 
        {
            "location": "/050-statements/#declarations", 
            "text": "A declaration exposes a  storage entity  to the program.\nIts  scope  begins after the declaration and goes until the end of the\nenclosing  block .  C\u00e9u supports variables, vectors, external events, internal events, and pools:  Var    ::= var [` \u00b4|` ?\u00b4] Type LIST(ID_int [`=\u00b4 Set])\nVector ::= vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\nExt    ::= input  (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n        |  output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\nInt    ::= event [` \u00b4|` ?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])\nPool   ::= pool [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])  See also  Storage Classes  for an overview of storage entities.", 
            "title": "Declarations"
        }, 
        {
            "location": "/050-statements/#variables", 
            "text": "A variable has an associated  type  and can be optionally initialized .\nA single statement can declare multiple variables of the same type.\nDeclarations can also be  aliases  or  option aliases .  Examples:  var  int v = 10;    //  v  is an integer variable initialized to 10\nvar  int a=0, b=3;  //  a  and  b  are integer variables initialized to 0 and 3\nvar  int z =  v;    //  z  is an alias to  v", 
            "title": "Variables"
        }, 
        {
            "location": "/050-statements/#vectors", 
            "text": "A vector has a dimension, an associated  type  and can be optionally initialized .\nA single statement can declare multiple vectors of the same dimension and type.\nDeclarations can also be  aliases .  The expression between the brackets specifies the dimension of the vector with\nthe options that follow:   constant expression : Maximum number of elements is fixed and space is\n                         statically pre-allocated.  variable expression : Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.  omitted : Maximum number of elements is unbounded and space is dynamically\n             allocated.   The space for dynamic vectors grow and shrink automatically.  Examples:  var int n = 10;\nvector[10] int vs1 = [];    //  vs1  is a static vector of 10 elements max\nvector[n]  int vs2 = [];    //  vs2  is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    //  vs3  is an unbounded vector\nvector []  int vs4 =  vs1;  //  vs4  is an alias to  vs1", 
            "title": "Vectors"
        }, 
        {
            "location": "/050-statements/#events", 
            "text": "An event has a  type  for the value it carries when occurring.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.  See also  Introduction  for a general overview of events.", 
            "title": "Events"
        }, 
        {
            "location": "/050-statements/#external-events", 
            "text": "Examples:  input  void A,B;        //  A  and  B  are input events carrying no values\noutput int  MY_EVT;     //  MY_EVT  is an output event carrying integer values\ninput (int,byte ) BUF; //  BUF  is an input event carrying an  (int,byte )  pair", 
            "title": "External events"
        }, 
        {
            "location": "/050-statements/#internal-events", 
            "text": "Declarations for internal events can also be  aliases  or option aliases .\nOnly in this case they can contain an  initialization .  Examples:  event  void a,b;        //  a  and  b  are internal events carrying no values\nevent  void z =  a;     //  z  is an alias to event  a \nevent (int,int) c;      //  c  is a internal event carrying an  (int,int)  pair", 
            "title": "Internal events"
        }, 
        {
            "location": "/050-statements/#pools", 
            "text": "TODO  See also  Code Pools  and  Data Pools .", 
            "title": "Pools"
        }, 
        {
            "location": "/050-statements/#event-handling", 
            "text": "", 
            "title": "Event Handling"
        }, 
        {
            "location": "/050-statements/#await", 
            "text": "The  await  statement halts the running trail until the referred\nevent occurs.\nThe event can be an  external input event , an  internal event ,\na timer, a  pausing event , or forever (i.e., never awake):  Await ::= await (ID_ext | Name) [until Exp]     /* events */\n       |  await (WCLOCKK|WCLOCKE)               /* timers */\n       |  await (pause|resume)                  /* pausing events */\n       |  await FOREVER                         /* forever */  Examples:  await A;                  // awaits the input event `A`\nawait a;                  // awaits the internal event `a`\n\nawait 10min3s5ms100us;    // awaits the specified time\nawait (t)ms;              // awaits the current value of the variable `t` in milliseconds\n\nawait FOREVER;            // awaits forever  An  await  evaluates to zero or more values which can be captured with an\noptional  assignment .", 
            "title": "Await"
        }, 
        {
            "location": "/050-statements/#events_1", 
            "text": "The  await  statement for events halts the running trail until the referred external input event  or   internal event  occurs.  The  await  evaluates to a value of the type of the event.  The optional clause  until  tests an additional condition required to awake.\nThe condition can use the returned value from the  await .\nIt expands to a  loop  as follows:  loop do\n     ret  = await  evt ;\n    if  Exp  then   //  Exp  can use  ret \n        break;\n    end\nend  Examples:  input int E;                    //  E  is an external input event carrying  int  values\nvar int v = await E until v 10; // assigns occurring  E  to  v , awaking when  v 10 \n\nevent (bool,int) e;             //  e  is an internal event carrying  (bool,int)  pairs\nvar bool v1;\nvar int  v2;\n(v1,v2) = await e;              // awakes on  e  and assigns its values to  v1  and  v2", 
            "title": "Events"
        }, 
        {
            "location": "/050-statements/#timers", 
            "text": "The  await  statement for timers halts the running trail until the referred\ntimer expires.  WCLOCKK  specifies a constant time expressed as a sequence of value/unit\npairs. WCLOCKE  specifies an expression in parenthesis followed by a single unit of\ntime.  The  await  evaluates to a value of type  s32  and is the residual delta time (dt)  measured in microseconds.\nIs is the difference between the actual elapsed time and the requested time.  Examples:  var int t =  ... ;\nawait (t)ms;                            // awakes after  t  milliseconds\n\nvar int dt = await 1min10s30ms100us;    // if 1min10s31ms000us elapses, then dt=900  Note: The residual  dt  is always greater than or equal to 0.", 
            "title": "Timers"
        }, 
        {
            "location": "/050-statements/#pausing", 
            "text": "Pausing events are dicussed in  Pausing .", 
            "title": "Pausing"
        }, 
        {
            "location": "/050-statements/#forever", 
            "text": "The  await  statement for  FOREVER  halts the running trail forever.\nIt cannot be used in assignments because it never evaluates to anything.  if  cnd  then\n    await FOREVER;  // this trail never awakes if the condition is true\nend", 
            "title": "FOREVER"
        }, 
        {
            "location": "/050-statements/#emit", 
            "text": "The  emit  statement broadcasts an event to the whole program.\nThe event can be an  external event , an  internal event , or\na timer:  Emit ::= emit (ID_ext | Name) [`(\u00b4 [LIST(Exp)] `)\u00b4)]\n      |  emit (WCLOCKK|WCLOCKE)  Examples:  emit A;         // emits the external event `A` of type  void \nemit a(1);      // emits the internal event `a` of type  int \n\nemit 1s;        // emits the specified time\nemit (t)ms;     // emits the current value of the variable `t` in milliseconds", 
            "title": "Emit"
        }, 
        {
            "location": "/050-statements/#events_2", 
            "text": "The  emit  statement for events expects a specific number of arguments matching\nthe event type (unless the event is of type  void ).   An  emit  to an external input or timer event can only occur inside\n   asynchronous blocks .  An  emit  to an external output event is also an expression that evaluates\n  to a value of type  s32  (its meaning is  platform dependent ).  An  emit  to an internal event starts a new  internal reaction .   Examples:  input int I;\nasync do\n    emit I(10);         // broadcasts  I  to the application itself, passing  10 \nend\n\noutput void O;\nvar int ret = emit O(); // outputs  O  to the environment and captures the result\n\nevent (int,int) e;\nemit e(1,2);            // broadcasts  e  passing a pair of  int  values", 
            "title": "Events"
        }, 
        {
            "location": "/050-statements/#timers_1", 
            "text": "The  emit  statement for timers expects an expression of time as described in Await Timer .  Like input events, time can only be emitted inside  asynchronous \nblocks .  Examples:  async do\n    emit 1s;    // broadcasts  1s  to the application itself\nend", 
            "title": "Timers"
        }, 
        {
            "location": "/050-statements/#conditional", 
            "text": "The  if-then-else  statement provides conditionals in C\u00e9u:  If ::= if Exp then\n           Block\n       { else/if Exp then\n           Block }\n       [ else\n           Block ]\n       end  Each condition  Exp  is tested in sequence, first for the  if  clause and then\nfor each of the optional  else/if  clauses.\nFor the first condition that evaluates to  true , the  Block  following it\nexecutes.\nIf all conditions fail, the optional  else  clause executes.  All conditions must evaluate to a value of type  bool , which is\nchecked at compile time.", 
            "title": "Conditional"
        }, 
        {
            "location": "/050-statements/#loops", 
            "text": "C\u00e9u supports simple loops, numeric iterators, event iterators, and pool\niterators:  Loop ::=\n      /* simple loop */\n        loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] Numeric do    /* Numeric ::= (see  Numeric Iterators ) */\n            Block\n        end\n\n      /* event iterator */\n      | every [(Name | `(\u00b4 LIST(Name|`_\u00b4) `)\u00b4) in] (ID_ext|Name|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Name do\n            Block\n        end\n\nBreak    ::= break [`/\u00b4ID_int]\nContinue ::= continue [`/\u00b4ID_int]  The  Block  body of a loop executes an arbitrary number of times, depending on\nthe conditions imposed by each kind of loop.  Except for the  every  iterator, all loops support an optional / Exp  to limit the maximum number of iterations and\navoid  infinite execution .\nThe expression must be a constant evaluated at compile time.", 
            "title": "Loops"
        }, 
        {
            "location": "/050-statements/#break-and-continue", 
            "text": "The  break  statement aborts the deepest enclosing loop.  The  continue  statement aborts the body of the deepest enclosing loop and\nrestarts in the next iteration.  The optional  / ID_int  in both statements only applies\nto  numeric iterators .", 
            "title": "break and continue"
        }, 
        {
            "location": "/050-statements/#simple-loops", 
            "text": "A simple loop executes its body continually and forever.  Examples:  // blinks a LED with a frequency of 1s forever\nloop do\n    emit LED(1);\n    await 1s;\n    emit LED(0);\n    await 1s;\nend  loop do\n    loop do\n        if  cnd-1  then\n            break;      // aborts the loop at line 2 if  cnd-1  is satisfied\n        end\n    end\n    if  cnd-2  then\n        continue;       // restarts the loop at line 1 if  cnd-2  is satisfied\n    end\nend", 
            "title": "Simple Loops"
        }, 
        {
            "location": "/050-statements/#numeric-iterators", 
            "text": "The numeric loop modifies the value of a control variable on each iteration\naccording to the specification of an optional interval as follows:  Numeric ::= (`_\u00b4|ID_int) in [ (`[\u00b4 | `]\u00b4)\n                                  ( (     Exp `- \u00b4 (`_\u00b4|Exp))\n                                  | (`_\u00b4|Exp) ` -\u00b4 Exp      ) )\n                              (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp] ]  The control variable assumes the values specified in the interval, one by one,\nfor each iteration of the loop body:   control variable: \n     ID_int  is a variable of a  numeric type .\n    Alternatively, the special anonymous identifier  _  can be used if the body\n    of the loop does not access the variable.\n    The control variable is marked as  read-only  and cannot be changed\n    explicitly.  interval: \n    Specifies a direction, endpoints with open or closed modifiers, and a step.  direction :  - : Starts from the endpoint  Exp  on the left increasing towards  Exp  on the right.  - : Starts from the endpoint  Exp  on the right decreasing towards  Exp  on the left.\nTypically, the value on the left should always be smaller or equal to\nthe value on the right.    endpoints :\n     [Exp  and  Exp]  are closed intervals which include  Exp  as the\n    endpoints;\n     ]Exp  and  Exp[  are open intervals which exclude  Exp  as the\n    endpoints.\n    Alternatively, the finishing endpoint may be  _  which means that the\n    interval goes towards infinite.  step :\n    An optional positive number added or subtracted towards the limit.\n    If the step is omitted, it assumes the value  1 .\n    If the direction is  - , the step is added, otherwise it is subtracted.\nIf the interval is not specified, it assumes the default  [0 -  _] .     The numeric iterator executes as follows:   initialization: \n    The starting endpoint is assigned to the control variable.\n    If the starting enpoint is open, the control variable accumulates a step.  iteration:  limits test: \n    If the control variable crossed the finishing endpoint, the loop\n    terminates.  body execution: \n    The loop body executes.  step \n    Applies a step to the control variable. Goto step  1 .     The  break  and  continue  statements inside numeric iterators accept an\noptional modifier  / ID_int  to match the control\nvariable of the enclosing loop to affect.  Examples:  // prints  i=0 ,  i=1 , ...\nvar int i;\nloop i do\n    _printf( i=%d\\n , i);\nend  // awaits 1s and prints  Hello World!  10 times\nloop _ in [0 -  10[ do\n    await 1s;\n    _printf( Hello World!\\n );\nend  var int i;\nloop i do\n    var int j;\n    loop j do\n        if  cnd-1  then\n            continue/i;         // continues the loop at line 1\n        else/if  cnd-2  then\n            break/j;            // breaks the loop at line 4\n        end\n    end\nend  Note : the runtime asserts that the step is a positive number and that the\n        control variable does not overflow.", 
            "title": "Numeric Iterators"
        }, 
        {
            "location": "/050-statements/#pool-iterators", 
            "text": "Pool iterators are dicussed in  Code Pools .", 
            "title": "Pool Iterators"
        }, 
        {
            "location": "/050-statements/#parallel-compositions", 
            "text": "The parallel statements  par/and ,  par/or , and  par  split the running trail \nin multiple others:  Pars ::= (par | par/and | par/or) do\n             Block\n         with\n             Block\n         { with\n             Block }\n         end\n\nWatching ::= watching LIST(ID_ext|Name|WCLOCKK|WCLOCKE|Code2) do\n                 Block\n             end  They differ only on how trails rejoin and terminate the composition.  The  watching  statement terminates when one of its listed events occur.  See also  Parallel Compositions and Abortion .", 
            "title": "Parallel Compositions"
        }, 
        {
            "location": "/050-statements/#par", 
            "text": "The  par  statement never rejoins.  Examples:  // reacts continuously to  1s  and  KEY_PRESSED  and never terminates\ninput void KEY_PRESSED;\npar do\n    every 1s do\n         ...            // does something every  1s \n    end\nwith\n    every KEY_PRESSED do\n         ...            // does something every  KEY_PRESSED \n    end\nend", 
            "title": "par"
        }, 
        {
            "location": "/050-statements/#parand", 
            "text": "The  par/and  statement stands for  parallel-and  and rejoins when all trails \nterminate.  Examples:  // reacts once to  1s  and  KEY_PRESSED  and terminates\ninput void KEY_PRESSED;\npar/and do\n    await 1s;\n     ...                // does something after  1s \nwith\n    await KEY_PRESSED;\n     ...                // does something after  KEY_PRESSED \nend", 
            "title": "par/and"
        }, 
        {
            "location": "/050-statements/#paror", 
            "text": "The  par/or  statement stands for  parallel-or  and rejoins when any of the \ntrails terminate, aborting all other trails.  Examples:  // reacts once to `1s` or `KEY_PRESSED` and terminates\ninput void KEY_PRESSED;\npar/or do\n    await 1s;\n     ...                // does something after  1s \nwith\n    await KEY_PRESSED;\n     ...                // does something after  KEY_PRESSED \nend", 
            "title": "par/or"
        }, 
        {
            "location": "/050-statements/#watching", 
            "text": "The  watching  statement accepts a list of events and terminates when any of\nthe events occur.  A  watching  expands to a  par/or  with  n+1  trails:\none to await each of the listed events,\nand one for its body, i.e.:  watching  e1 , e2 ,... do\n     body \nend  expands to  par/or do\n    await  e1 ;\nwith\n    await  e2 ;\nwith\n    ...\nwith\n     body \nend  Examples:  // reacts continuously to  KEY_PRESSED  during  1s \ninput void KEY_PRESSED;\nwatching 1s do\n    every KEY_PRESSED do\n         ...            // does something every  KEY_PRESSED \n    end\nend", 
            "title": "watching"
        }, 
        {
            "location": "/050-statements/#pausing_1", 
            "text": "The  pause/if  statement controls if its body should temporarily stop to react\nto events:  Pause_If ::= pause/if (Name|ID_ext) do\n                 Block\n             end\n\nPause_Await ::= await (pause|resume)  A  pause/if  determines a pausing event of type  bool  which, when emitted,\ntoggles between pausing ( true ) and resuming ( false ) reactions for its body.  When its body terminates, the whole  pause/if  terminates and proceeds to the\nstatement in sequence.  In transition points, the body can react to the special  pause  and  resume \nevents before the corresponding state applies.  TODO: finalize/pause/resume  Examples:  event bool e;\npause/if e do       // pauses/resumes the nested body on each  e \n    every 1s do\n         ...        // does something every  1s \n    end\nend  event bool e;\npause/if e do               // pauses/resumes the nested body on each  e \n     ... \n        loop do\n            await pause;\n             ...            // does something before pausing\n            await resume;\n             ...            // does something before resuming\n        end\n     ... \nend", 
            "title": "Pausing"
        }, 
        {
            "location": "/050-statements/#asynchronous-execution", 
            "text": "Asynchronous execution allow programs to execute time consuming computations \nwithout interfering with the responsiveness of the   synchronous side  of\napplications (i.e., all core language statements):  Async  ::= await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\n\nThread ::= await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n               Block\n           end\nAtomic ::= atomic do\n               Block\n           end  The program awaits the termination of the asynchronous body to proceed to the\nstatement in sequence.  Asynchronous blocks can contain  tight loops  but which keep the\napplication reactive to incoming events.\nHowever, they do not support nesting of asynchronous statements, and do not\nsupport synchronous control statements (i.e., parallel compositions, event\nhandling, pausing, etc.).  By default, asynchronous blocks do not shared variables with their enclosing\nscope.\nThe optional list of variables makes them visible to the block.", 
            "title": "Asynchronous Execution"
        }, 
        {
            "location": "/050-statements/#asynchronous-blocks", 
            "text": "Asynchronous blocks ( async ) preserve deterministic execution with the rules\nas follows:   Resume execution whenever the synchronous side is idle.  Yield control to the synchronous side on every complete  loop  iteration.  Yield control to the synchronous side on every  emit .  Execute atomically and to completion unless rules  2  and  3  apply.   This rules imply that  async  blocks and the synchronous side never run at the\nsame time with real parallelism.  Examples:  // calculates the factorial of some  v  if it doesn't take too long\nvar u64  v   =  ... ;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async (v,fat) do      // keeps  v  and  fat  visible\n        loop i in [1 -  v] do   // reads from  v \n            fat = fat * i;      // writes to  fat \n        end\n    end\n    ok = true;                  // completed within  1s \nend", 
            "title": "Asynchronous Blocks"
        }, 
        {
            "location": "/050-statements/#simulation", 
            "text": "An  async  block can emit  input events  and the passage of time  towards the synchronous side, providing a way to test\nprograms in the language itself.\nEvery time an  async  emits an event, it suspends until the synchronous side\nreacts to the event (see  rule 1  above).  Examples:  input int A;\n\n// tests a program with a simulation in parallel\npar do\n\n    // original program\n    var int v = await A;\n    loop i in [0 -  _[ do\n        await 10ms;\n        _printf( v = %d\\n , v+i);\n    end\n\nwith\n\n    // input simulation\n    async do\n        emit A(0);      // initial value for  v \n        emit 1s35ms;    // the loop in the original program executes 103 times\n    end\n    escape 0;\n\nend\n\n// The example prints the message `v =  v+i ` exactly 103 times.", 
            "title": "Simulation"
        }, 
        {
            "location": "/050-statements/#asynchronous-threads", 
            "text": "Asynchronous threads ( async/thread ) provide real parallelism for applications\nin C\u00e9u.\nOnce an  async/thread  starts, it runs completely detached from the synchronous\nside.\nHowever, they are still ruled by the synchronous side and are also subject to\nabortion.  Examples:  // calculates the factorial of some  v  if it doesn't take too long\nvar u64  v   =  ... ;\nvar u64  fat = 1;\nvar bool ok  = false;\nwatching 1s do\n    await async/thread (v,fat) do   // keeps  v  and  fat  visible\n        loop i in [1 -  v] do       // reads from  v \n            fat = fat * i;          // writes to  fat \n        end\n    end\n    ok = true;                      // completed within  1s \nend", 
            "title": "Asynchronous Threads"
        }, 
        {
            "location": "/050-statements/#atomic-blocks", 
            "text": "Atomic blocks provide mutual exclusion among threads and the synchronous\nside of application.\nOnce an atomic block starts to execute, no other atomic block in the program\nstarts.  Examples:  // A  race  between two threads: one incrementing, the other decrementing  count .\n\nvar s64 count = 0;                              //  count  is a shared variable\npar do\n    every 1s do\n        atomic do\n            _printf( count = %d\\n , count);     // prints current value of  count  every  1s \n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count - 1;              // decrements  count  as fast as possible\n            end\n        end\n    end\nwith\n    await async/thread (count) do\n        loop do\n            atomic do\n                count = count + 1;              // increments  count  as fast as possible\n            end\n        end\n    end\nend", 
            "title": "Atomic Blocks"
        }, 
        {
            "location": "/060-expressions/", 
            "text": "TODO", 
            "title": "Expressions"
        }, 
        {
            "location": "/070-static_analysis/", 
            "text": "TODO", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/080-environment/", 
            "text": "TODO", 
            "title": "Environment"
        }, 
        {
            "location": "/090-errors/", 
            "text": "TODO", 
            "title": "Errors"
        }, 
        {
            "location": "/syntax/", 
            "text": "Syntax\n\n\nFollows the complete syntax of C\u00e9u in a BNF-like syntax:\n\n\n\n\nA\n : non terminal (starting in uppercase)\n\n\na\n : terminal (in bold and lowercase)\n\n\n.\n : terminal (non-alphanumeric characters)\n\n\nA ::= ...\n : defines \nA\n as \n...\n\n\nx y\n : \nx\n in sequence with \ny\n\n\nx|y\n : \nx\n or \ny\n\n\n{x}\n : zero or more xs\n\n\n[x]\n : optional x\n\n\nLIST(x)\n : expands to \nx {\n,\n x} [\n,\n]\n\n\n(...)\n : groups \n...\n\n\n...\n : special informal rule\n\n\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(`_\u00b4|ID_int)]\n            Block\n        end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Classes */\n\n      | var [`\n\u00b4|`\n?\u00b4] Type LIST(ID_int [`=\u00b4 Set])\n      | vector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | pool [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | event [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      | output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Name) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Name [`(\u00b4 [LIST(Exp)] `)\u00b4]\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (`_\u00b4|ID_int) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `-\n\u00b4 (`_\u00b4|Exp))\n                        | ((`_\u00b4|Exp) `\n-\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Name do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Name | `(\u00b4 LIST(Name|`_\u00b4) `)\u00b4) in] (ID_ext|Name|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Name|WCLOCKK|WCLOCKE|Code2) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Name|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      // Async_Thread ::=\n      | await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [is Exp]\n      | data ID_abs [is Exp] [ with\n                                { \nvar|vector|pool|event declaration\n `;\u00b4 {`;\u00b4} }\n                               end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `-\n\u00b4 Type\n\n      // Code_Await ::=\n      | code/await [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `-\n\u00b4 [ `(\u00b4 Params `)\u00b4 `-\n\u00b4 ] (Type | FOREVER)\n        // where\n            Params ::= void | LIST([dynamic] Class ID_int)\n            Class ::= var [`\n\u00b4|`\n?\u00b4] [`/\u00b4hold] * Type\n                   |  vector `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  pool `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  event [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4LIST(Type)`)\u00b4)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code instantiation */\n\n      // Call_Code ::=\n      | call  Mods Code1\n\n      // Await_Code ::=\n      | await Mods Code2\n\n      // Spawn_Code ::=\n      | spawn Mods Code2 [in Name]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Code1 ::= ID_abs `(\u00b4 [LIST(Exp)] `)\u00b4\n            Code2 ::= Code1 [`-\n\u00b4 `(\u00b4 LIST(`\n\u00b4 Var) `)\u00b4])\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n            \ncode definitions in C\n\n        end\n      | native `/\u00b4 end\n      | `{\u00b4 \ncode in C\n `}\u00b4\n\n      // Call_Nat ::=\n      | call [`/\u00b4recursive] (Name | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var `\n?\u00b4 Type ID_int `=\u00b4 `\n\u00b4 (Call_Nat | Call_Code) Finalize\n        // where\n            Finalize ::= finalize `(\u00b4 LIST(Name) `)\u00b4 with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { \ncode in Lua\n | `@\u00b4 Exp }\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Assignments */\n\n      | (Name | `(\u00b4 LIST(Name|`_\u00b4) `)\u00b4) `=\u00b4 Set\n        // where\n            Set ::= ( Await\n                    | Emit_Ext\n                    | Watching\n                    | Async_Thread\n                    | Do\n                    | Data\n                    | Await_Code\n                    | Spawn_Code\n                    | Lua\n                    | Vector\n                    | `_\u00b4\n                    | Exp )\n            Data ::= (val|new) ID_abs `(\u00b4 LIST(Exp) `)\u00b4 \n            Vector ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua | `[\u00b4 [LIST(Exp)] `]\u00b4) }\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID         // beginning with lowercase\nID_ext   ::= ID         // all in uppercase, not beginning with digit\nID_abs   ::= ID         // beginning with uppercase, containining at least one lowercase)\nID_field ::= ID         // not beginning with digit\nID_nat   ::= ID         // beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { `\n\u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Expressions */\n\nName    ::= Name_01\nName_01 ::= [`*\u00b4|`$\u00b4] Name_02\nName_02 ::= Name_03 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nName_03 ::= `(\u00b4 Name_01 [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4 \ncode in C\n `}\u00b4\n\nExp  ::= Prim (combined with the \nOperator Precedence\n below)\nPrim ::= `(\u00b4 Exp `)\u00b4\n      |  `\n\u00b4 Name\n      |  Name [`?\u00b4]\n      |  `\n\u00b4 (Call_Nat | Name)\n      |  Call_Nat | Call_Code\n      |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n      |  NUM | STR | null | true | false\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::= \n [^\\\n\\n]* \n                        // regex\n\n/* Operator precedence */\n\n    /* lowest priority */\n    is    as\n    or\n    and\n    !=    ==    \n=    \n=    \n     \n\n    |\n    ^\n    \n\n    \n    \n\n    +     -\n    *     /     %\n    not   +    -    ~    $$\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive", 
            "title": "Syntax"
        }, 
        {
            "location": "/syntax/#syntax", 
            "text": "Follows the complete syntax of C\u00e9u in a BNF-like syntax:   A  : non terminal (starting in uppercase)  a  : terminal (in bold and lowercase)  .  : terminal (non-alphanumeric characters)  A ::= ...  : defines  A  as  ...  x y  :  x  in sequence with  y  x|y  :  x  or  y  {x}  : zero or more xs  [x]  : optional x  LIST(x)  : expands to  x { ,  x} [ , ]  (...)  : groups  ...  ...  : special informal rule   Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      | do [`/\u00b4(`_\u00b4|ID_int)]\n            Block\n        end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Classes */\n\n      | var [` \u00b4|` ?\u00b4] Type LIST(ID_int [`=\u00b4 Set])\n      | vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | pool [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | event [` \u00b4|` ?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      | output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n\n  /* Event Handling */\n\n      // Await ::=\n      | await (ID_ext | Name) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await (FOREVER | pause | resume)\n\n      // Emit_Ext ::=\n      | emit ID_ext [`(\u00b4 [LIST(Exp)] `)\u00b4]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Name [`(\u00b4 [LIST(Exp)] `)\u00b4]\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (`_\u00b4|ID_int) in [Range] do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( (      Exp `- \u00b4 (`_\u00b4|Exp))\n                        | ((`_\u00b4|Exp) ` -\u00b4 Exp      ) )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Name do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Name | `(\u00b4 LIST(Name|`_\u00b4) `)\u00b4) in] (ID_ext|Name|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST(ID_ext|Name|WCLOCKK|WCLOCKE|Code2) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn do\n            Block\n        end\n\n  /* Pause */\n\n      | pause/if (Name|ID_ext) do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      // Async_Thread ::=\n      | await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [is Exp]\n      | data ID_abs [is Exp] [ with\n                                {  var|vector|pool|event declaration  `;\u00b4 {`;\u00b4} }\n                               end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `- \u00b4 Type\n\n      // Code_Await ::=\n      | code/await [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `- \u00b4 [ `(\u00b4 Params `)\u00b4 `- \u00b4 ] (Type | FOREVER)\n        // where\n            Params ::= void | LIST([dynamic] Class ID_int)\n            Class ::= var [` \u00b4|` ?\u00b4] [`/\u00b4hold] * Type\n                   |  vector ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  pool ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  event [` \u00b4|` ?\u00b4] (Type | `(\u00b4LIST(Type)`)\u00b4)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code instantiation */\n\n      // Call_Code ::=\n      | call  Mods Code1\n\n      // Await_Code ::=\n      | await Mods Code2\n\n      // Spawn_Code ::=\n      | spawn Mods Code2 [in Name]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Code1 ::= ID_abs `(\u00b4 [LIST(Exp)] `)\u00b4\n            Code2 ::= Code1 [`- \u00b4 `(\u00b4 LIST(` \u00b4 Var) `)\u00b4])\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n             code definitions in C \n        end\n      | native `/\u00b4 end\n      | `{\u00b4  code in C  `}\u00b4\n\n      // Call_Nat ::=\n      | call [`/\u00b4recursive] (Name | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\n      /* finalization */\n      | do [Stmt] Finalize\n      | var ` ?\u00b4 Type ID_int `=\u00b4 ` \u00b4 (Call_Nat | Call_Code) Finalize\n        // where\n            Finalize ::= finalize `(\u00b4 LIST(Name) `)\u00b4 with\n                             Block\n                         [ pause  with Block ]\n                         [ resume with Block ]\n                         end\n\n  /* Lua integration */\n\n      // Lua ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            {  code in Lua  | `@\u00b4 Exp }\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Assignments */\n\n      | (Name | `(\u00b4 LIST(Name|`_\u00b4) `)\u00b4) `=\u00b4 Set\n        // where\n            Set ::= ( Await\n                    | Emit_Ext\n                    | Watching\n                    | Async_Thread\n                    | Do\n                    | Data\n                    | Await_Code\n                    | Spawn_Code\n                    | Lua\n                    | Vector\n                    | `_\u00b4\n                    | Exp )\n            Data ::= (val|new) ID_abs `(\u00b4 LIST(Exp) `)\u00b4 \n            Vector ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua | `[\u00b4 [LIST(Exp)] `]\u00b4) }\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID         // beginning with lowercase\nID_ext   ::= ID         // all in uppercase, not beginning with digit\nID_abs   ::= ID         // beginning with uppercase, containining at least one lowercase)\nID_field ::= ID         // not beginning with digit\nID_nat   ::= ID         // beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { ` \u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Expressions */\n\nName    ::= Name_01\nName_01 ::= [`*\u00b4|`$\u00b4] Name_02\nName_02 ::= Name_03 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nName_03 ::= `(\u00b4 Name_01 [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4  code in C  `}\u00b4\n\nExp  ::= Prim (combined with the  Operator Precedence  below)\nPrim ::= `(\u00b4 Exp `)\u00b4\n      |  ` \u00b4 Name\n      |  Name [`?\u00b4]\n      |  ` \u00b4 (Call_Nat | Name)\n      |  Call_Nat | Call_Code\n      |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n      |  NUM | STR | null | true | false\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::=   [^\\ \\n]*                          // regex\n\n/* Operator precedence */\n\n    /* lowest priority */\n    is    as\n    or\n    and\n    !=    ==     =     =           \n    |\n    ^\n     \n          \n    +     -\n    *     /     %\n    not   +    -    ~    $$\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive", 
            "title": "Syntax"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nC\u00e9u is distributed under the MIT license reproduced below:\n\n\n Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \nSoftware\n), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "C\u00e9u is distributed under the MIT license reproduced below:   Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the  Software ), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }
    ]
}