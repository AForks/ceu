{
    "docs": [
        {
            "location": "/", 
            "text": "C\u00e9u v0.20 - Reference Manual\n\n\n\n\nIntroduction\n\n\nLexical Rules\n\n\nTypes\n\n\nStorage Classes\n\n\nStatements\n\n\nExpressions\n\n\nStatic Analsysis\n\n\nEnvironment\n\n\nErrors\n\n\nSyntax\n\n\nLicense", 
            "title": "Home"
        }, 
        {
            "location": "/#ceu-v020-reference-manual", 
            "text": "Introduction  Lexical Rules  Types  Storage Classes  Statements  Expressions  Static Analsysis  Environment  Errors  Syntax  License", 
            "title": "C\u00e9u v0.20 - Reference Manual"
        }, 
        {
            "location": "/010-introduction/", 
            "text": "Introduction\n\n\nC\u00e9u provides \nStructured Synchronous Reactive Programming\n which supports\nsafe and deterministic concurrency with side effects.\nThe lines of execution in C\u00e9u, known as \ntrails\n, react together continuously\nand in synchronous steps to external input events from the environment.\nWaiting for an event halts the running trail until that event occurs.\nThe environment broadcasts an occurring event to all active trails, which share \na single global time reference.\n\n\nThe synchronous concurrency model of C\u00e9u diverges from multithreading and also\nfrom actor-based models (e.g. \npthreads\n and \nerlang\n).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, trails can share variables deterministically without\nsynchronization primitives (i.e., no \nlocks\n, \nsemaphores\n, or \nqueues\n).\n\n\nC\u00e9u provides automatic memory management based on static lexical scopes (i.e.,\nno \nfree\n or \ndelete\n) and does not require runtime garbage collection.\n\n\nC\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers.\n\n\nC\u00e9u is \nfree software\n.\n\n\nSynchronous Execution Model\n\n\nC\u00e9u is grounded on a precise definition of \nlogical time\n (as opposed to\n\nphysical\n or \nwall-clock time\n) as a discrete sequence of external input\nevents:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see \nBounded Execution\n).\n\n\nThe execution model for C\u00e9u programs is as follows:\n\n\n\n\nThe program initiates the \nboot reaction\n from the first line of code in a\n      single trail.\n\n\nActive trails\n1\n, one after another, execute until they await or \n      terminate.\n      This step is named a \nreaction chain\n, and always runs in bounded time.\n\n\nThe program goes idle and the environment takes control.\n\n\nOn the occurrence of a new external input event, the environment awakes \n      \nall\n trails awaiting that event.\n      It then goes to step 2.\n\n\n\n\n(\n1\n\n\nTrails can be created with \nparallel \ncompositions\n.\n)\n\n\nThe synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run \ninfinitely faster\n in comparison to the rate of external events.\nA reaction chain is the set of computations that execute when an external \nevent occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new external input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is somewhat arbitrary, but provides a priority scheme for trails, \nand also ensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.\n\n\nThe program and diagram below illustrate the behavior of the scheduler of C\u00e9u:\n\n\n 1:  input void A, B, C;\n 2:  par/and do           // A, B, and C are external input events\n 3:      // trail 1\n 4:      \n...\n            // \n...\n represents non-awaiting statements\n 5:      await A;\n 6:      \n...\n\n 7:  with\n 8:      // trail 2\n 9:      \n...\n\n10:      await B;\n11:      \n...\n\n12:  with\n13:      // trail 3\n14:      \n...\n\n15:      await A;\n16:      \n...\n\n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:          \n...\n\n21:      with\n22:          // trail 4\n23:          \n...\n\n24:      end\n25:  end\n\n\n\n\n\n\nThe program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows (\nt0\n in the diagram):\n\n\n\n\ntrail-1\n executes up to the \nawait A\n (line 5);\n\n\ntrail-2\n, up to the \nawait B\n (line 10);\n\n\ntrail-3\n, up to \nawait A\n (line 15).\n\n\n\n\nAs no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event \nA\n occurs (\nt1\n in the diagram):\n\n\n\n\ntrail-1\n awakes, executes and terminates (line 6);\n\n\ntrail-2\n remains suspended, as it is not awaiting \nA\n.\n\n\ntrail-3\n executes up to \nawait B\n (line 17).\n\n\n\n\nDuring the reaction \nt1\n, new instances of events \nA\n, \nB\n, and \nC\n occur and\nare enqueued to be handled in the reactions in sequence.\nAs \nA\n happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n(\nt2\n in the diagram).\nThe next reaction dequeues the event \nB\n (\nt3\n in the diagram):\n\n\n\n\ntrail-2\n awakes, executes and terminates;\n\n\ntrail-3\n splits in two and they both terminate immediately.\n\n\n\n\nA \npar/and\n rejoins after all trails terminate.\nWith all trails terminated, the program also terminates and does not react to \nthe pending event \nC\n.\n\n\nNote that each step in the logical time line (\nt0\n, \nt1\n, etc.) is identified \nby the unique event it handles.\nInside a reaction, trails only react to that identifying event (or remain \nsuspended).\n\n\n\n\n\nParallel Compositions and Abortion\n\n\nThe use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:\n\n\n\n\na \npar/and\n rejoins after all trails in parallel terminate;\n\n\na \npar/or\n rejoins after any trail in parallel terminates, aborting all\n   other trails;\n\n\na \npar\n never rejoins, even if all trails terminate.\n\n\n\n\nThe termination of a trail inside a \npar/or\n aborts the other trails in \nparallel which are necessarily idle\n(see \nrule 2\n for external reactions\n).\nBefore being aborted, a trail has a last opportunity to execute active \n\nfinalization statements\n.\n\n\nAs mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions should read as \nawaiting in parallel\n, rather\nthan \nexecuting in parallel\n.\n\n\nBounded Execution\n\n\nReaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle upcoming input events from the environment.\nFor this reason, C\u00e9u requires every path inside the body of a \nloop\n statement\nto contain at least one \nawait\n or \nbreak\n statement.\nThis prevents \ntight loops\n, i.e., unbounded loops that do not await.\n\n\nIn the example below, the true branch of the \nif\n may never execute, resulting\nin a tight loop when the condition is false:\n\n\nloop do\n    if \ncond\n then\n        break;\n    end\nend\n\n\n\n\nC\u00e9u complains about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides \nAsynchronous \nExecution\n.\n\n\nDeterministic Execution\n\n\nTODO (shared memory + deterministic scheduler + optional static analysis)\n\n\nInternal Reactions\n\n\nC\u00e9u supports inter-trail communication through \nawait\n and \nemit\n statements\nfor \ninternal events\n.\nA trail can \nemit\n an event which is broadcast to the program to awake trails\nin parallel that are blocked in an \nawait\n statement for that same event.\n\n\nAn \nemit\n starts a new \ninternal reaction\n in the program relying on a\nruntime stack:\n\n\n\n\nAn \nemit\n suspends the current trail and its continuation is pushed into the\n    stack (i.e., the statement in sequence with the \nemit\n).\n\n\nAll trails awaiting the emitted event awake and execute\n    (see \nrule 2\n for external reactions\n).\n\n\nThe top of stack is popped and the last emitting trail resumes execution\n    from its continuation.\n\n\n\n\nNote that if an awaking trail emits another internal event (in \nrule 2\n), a\nnested internal reaction starts (in \nrule 1\n).\nExample:\n\n\n1:  par/and do\n2:      await e;\n3:      emit f;\n4:  with\n5:      await f;\n6:  with\n7:      ...\n8:      emit e;\n9:  end\n\n\n\n\nThe \nemit e\n in \ntrail-3\n (line 8) starts an internal reaction that awakes the \n\nawait e\n in \ntrail-1\n (line 2).\nThen, the \nemit f\n (line 3) starts another internal reaction that awakes the \n\nawait f\n in \ntrail-2\n (line 5).\n\nTrail-2\n terminates and the \nemit f\n resumes in \ntrail-1\n.\n\nTrail-1\n terminates and the \nemit e\n resumes in \ntrail-3\n.\n\nTrail-3\n terminates.\nFinally, the \npar/and\n rejoins and the program terminates.", 
            "title": "Introduction"
        }, 
        {
            "location": "/010-introduction/#introduction", 
            "text": "C\u00e9u provides  Structured Synchronous Reactive Programming  which supports\nsafe and deterministic concurrency with side effects.\nThe lines of execution in C\u00e9u, known as  trails , react together continuously\nand in synchronous steps to external input events from the environment.\nWaiting for an event halts the running trail until that event occurs.\nThe environment broadcasts an occurring event to all active trails, which share \na single global time reference.  The synchronous concurrency model of C\u00e9u diverges from multithreading and also\nfrom actor-based models (e.g.  pthreads  and  erlang ).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, trails can share variables deterministically without\nsynchronization primitives (i.e., no  locks ,  semaphores , or  queues ).  C\u00e9u provides automatic memory management based on static lexical scopes (i.e.,\nno  free  or  delete ) and does not require runtime garbage collection.  C\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers.  C\u00e9u is  free software .", 
            "title": "Introduction"
        }, 
        {
            "location": "/010-introduction/#synchronous-execution-model", 
            "text": "C\u00e9u is grounded on a precise definition of  logical time  (as opposed to physical  or  wall-clock time ) as a discrete sequence of external input\nevents:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see  Bounded Execution ).  The execution model for C\u00e9u programs is as follows:   The program initiates the  boot reaction  from the first line of code in a\n      single trail.  Active trails 1 , one after another, execute until they await or \n      terminate.\n      This step is named a  reaction chain , and always runs in bounded time.  The program goes idle and the environment takes control.  On the occurrence of a new external input event, the environment awakes \n       all  trails awaiting that event.\n      It then goes to step 2.   ( 1  Trails can be created with  parallel \ncompositions . )  The synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run  infinitely faster  in comparison to the rate of external events.\nA reaction chain is the set of computations that execute when an external \nevent occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new external input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is somewhat arbitrary, but provides a priority scheme for trails, \nand also ensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.  The program and diagram below illustrate the behavior of the scheduler of C\u00e9u:   1:  input void A, B, C;\n 2:  par/and do           // A, B, and C are external input events\n 3:      // trail 1\n 4:       ...             //  ...  represents non-awaiting statements\n 5:      await A;\n 6:       ... \n 7:  with\n 8:      // trail 2\n 9:       ... \n10:      await B;\n11:       ... \n12:  with\n13:      // trail 3\n14:       ... \n15:      await A;\n16:       ... \n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:           ... \n21:      with\n22:          // trail 4\n23:           ... \n24:      end\n25:  end   The program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows ( t0  in the diagram):   trail-1  executes up to the  await A  (line 5);  trail-2 , up to the  await B  (line 10);  trail-3 , up to  await A  (line 15).   As no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event  A  occurs ( t1  in the diagram):   trail-1  awakes, executes and terminates (line 6);  trail-2  remains suspended, as it is not awaiting  A .  trail-3  executes up to  await B  (line 17).   During the reaction  t1 , new instances of events  A ,  B , and  C  occur and\nare enqueued to be handled in the reactions in sequence.\nAs  A  happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n( t2  in the diagram).\nThe next reaction dequeues the event  B  ( t3  in the diagram):   trail-2  awakes, executes and terminates;  trail-3  splits in two and they both terminate immediately.   A  par/and  rejoins after all trails terminate.\nWith all trails terminated, the program also terminates and does not react to \nthe pending event  C .  Note that each step in the logical time line ( t0 ,  t1 , etc.) is identified \nby the unique event it handles.\nInside a reaction, trails only react to that identifying event (or remain \nsuspended).", 
            "title": "Synchronous Execution Model"
        }, 
        {
            "location": "/010-introduction/#parallel-compositions-and-abortion", 
            "text": "The use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:   a  par/and  rejoins after all trails in parallel terminate;  a  par/or  rejoins after any trail in parallel terminates, aborting all\n   other trails;  a  par  never rejoins, even if all trails terminate.   The termination of a trail inside a  par/or  aborts the other trails in \nparallel which are necessarily idle\n(see  rule 2  for external reactions ).\nBefore being aborted, a trail has a last opportunity to execute active  finalization statements .  As mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions should read as  awaiting in parallel , rather\nthan  executing in parallel .", 
            "title": "Parallel Compositions and Abortion"
        }, 
        {
            "location": "/010-introduction/#bounded-execution", 
            "text": "Reaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle upcoming input events from the environment.\nFor this reason, C\u00e9u requires every path inside the body of a  loop  statement\nto contain at least one  await  or  break  statement.\nThis prevents  tight loops , i.e., unbounded loops that do not await.  In the example below, the true branch of the  if  may never execute, resulting\nin a tight loop when the condition is false:  loop do\n    if  cond  then\n        break;\n    end\nend  C\u00e9u complains about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides  Asynchronous \nExecution .", 
            "title": "Bounded Execution"
        }, 
        {
            "location": "/010-introduction/#deterministic-execution", 
            "text": "TODO (shared memory + deterministic scheduler + optional static analysis)", 
            "title": "Deterministic Execution"
        }, 
        {
            "location": "/010-introduction/#internal-reactions", 
            "text": "C\u00e9u supports inter-trail communication through  await  and  emit  statements\nfor  internal events .\nA trail can  emit  an event which is broadcast to the program to awake trails\nin parallel that are blocked in an  await  statement for that same event.  An  emit  starts a new  internal reaction  in the program relying on a\nruntime stack:   An  emit  suspends the current trail and its continuation is pushed into the\n    stack (i.e., the statement in sequence with the  emit ).  All trails awaiting the emitted event awake and execute\n    (see  rule 2  for external reactions ).  The top of stack is popped and the last emitting trail resumes execution\n    from its continuation.   Note that if an awaking trail emits another internal event (in  rule 2 ), a\nnested internal reaction starts (in  rule 1 ).\nExample:  1:  par/and do\n2:      await e;\n3:      emit f;\n4:  with\n5:      await f;\n6:  with\n7:      ...\n8:      emit e;\n9:  end  The  emit e  in  trail-3  (line 8) starts an internal reaction that awakes the  await e  in  trail-1  (line 2).\nThen, the  emit f  (line 3) starts another internal reaction that awakes the  await f  in  trail-2  (line 5). Trail-2  terminates and the  emit f  resumes in  trail-1 . Trail-1  terminates and the  emit e  resumes in  trail-3 . Trail-3  terminates.\nFinally, the  par/and  rejoins and the program terminates.", 
            "title": "Internal Reactions"
        }, 
        {
            "location": "/020-lexical_rules/", 
            "text": "Lexical Rules\n\n\nKeywords\n\n\nKeywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):\n\n\n    and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    loop            lua             native          new             nohold          \n\n    not             nothing         null            or              outer           \n\n    output          par             pause           plain           pool            \n\n    pos             pre             pure            recursive       request         \n\n    sizeof          spawn           then            thread          tight           \n\n    traverse        true            until           val             var             \n\n    vector          watching        with            bool            byte            \n\n    f32             f64             float           int             s16             \n\n    s32             s64             s8              ssize           u16             \n\n    u32             u64             u8              uint            usize           \n\n    void            \n\n\n\n\nIdentifiers\n\n\nC\u00e9u uses identifiers to refer to \ntypes\n, \nvariables\n, \nvectors\n, \npools\n,\n\ninternal events\n, \nexternal events\n, \ncode abstractions\n, \ndata abstractions\n,\n\nfields\n, \nnative symbols\n, and \nblock labels\n.\n\n\nID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID (first is lowercase)                        // variables, vectors, pools, internal events, and block labels\nID_ext   ::= ID (all in uppercase, first is not digit)      // external events\nID_abs   ::= ID (first is uppercase, contains lowercase)    // data and code abstractions\nID_field ::= ID (first is not digit)                        // fields\nID_nat   ::= ID (first is underscore)                       // native symbols\nID_type  ::= ( ID_nat | ID_abs                              // types\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n\n\n\nDeclarations for \ncode\n and \ndata\n [TODO-abstractions] create new [types] which can\nbe used as type identifiers.\n\n\nExamples:\n\n\nvar int a;                    // \na\n is a variable, \nint\n is a type\nemit e;                       // \ne\n is an internal event\nawait E;                      // \nE\n is an external input event\nspawn Move();                 // \nMove\n is a code abstraction and a type\nvar Rect r;                   // \nRect\n is a data abstraction and a type\nreturn r.width;               // \nwidth\n is a field\n_printf(\nhello world!\\n\n);    // \n_printf\n is a native symbol\n\n\n\n\nLiterals\n\n\nBooleans\n\n\nThe boolean type has two values, \ntrue\n and \nfalse\n.\n\n\nIntegers\n\n\nInteger values can be written in decimal and hexadecimal bases:\n\n\n\n\nDecimals are written \nas is\n.\n\n\nHexadecimals are prefixed with \n0x\n.\n\n\nTODO: \"0b---\", \"0o---\"\n\n\n\n\nExamples:\n\n\n// both are equal to the decimal 127\nv = 127;\nv = 0x7F;\n\n\n\n\nFloats\n\n\nTODO (like C)\n\n\nNull pointer\n\n\nThe \nnull\n literal represents null \npointers\n.\n\n\nStrings\n\n\nA sequence of characters surrounded by \n\"\n is converted into a \nnull-terminated \nstring\n, just like in C:\n\n\nExample:\n\n\n_printf(\nHello World!\\n\n);\n\n\n\n\nComments\n\n\nC\u00e9u provides C-style comments.\n\n\nSingle-line comments begin with \n//\n and run to end of the line.\n\n\nMulti-line comments use \n/*\n and \n*/\n as delimiters.\nMulti-line comments can be nested by using a different number of \n*\n as\ndelimiters.\n\n\nExamples:\n\n\nvar int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/020-lexical_rules/#lexical-rules", 
            "text": "", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/020-lexical_rules/#keywords", 
            "text": "Keywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):      and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    loop            lua             native          new             nohold          \n\n    not             nothing         null            or              outer           \n\n    output          par             pause           plain           pool            \n\n    pos             pre             pure            recursive       request         \n\n    sizeof          spawn           then            thread          tight           \n\n    traverse        true            until           val             var             \n\n    vector          watching        with            bool            byte            \n\n    f32             f64             float           int             s16             \n\n    s32             s64             s8              ssize           u16             \n\n    u32             u64             u8              uint            usize           \n\n    void", 
            "title": "Keywords"
        }, 
        {
            "location": "/020-lexical_rules/#identifiers", 
            "text": "C\u00e9u uses identifiers to refer to  types ,  variables ,  vectors ,  pools , internal events ,  external events ,  code abstractions ,  data abstractions , fields ,  native symbols , and  block labels .  ID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID (first is lowercase)                        // variables, vectors, pools, internal events, and block labels\nID_ext   ::= ID (all in uppercase, first is not digit)      // external events\nID_abs   ::= ID (first is uppercase, contains lowercase)    // data and code abstractions\nID_field ::= ID (first is not digit)                        // fields\nID_nat   ::= ID (first is underscore)                       // native symbols\nID_type  ::= ( ID_nat | ID_abs                              // types\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )  Declarations for  code  and  data  [TODO-abstractions] create new [types] which can\nbe used as type identifiers.  Examples:  var int a;                    //  a  is a variable,  int  is a type\nemit e;                       //  e  is an internal event\nawait E;                      //  E  is an external input event\nspawn Move();                 //  Move  is a code abstraction and a type\nvar Rect r;                   //  Rect  is a data abstraction and a type\nreturn r.width;               //  width  is a field\n_printf( hello world!\\n );    //  _printf  is a native symbol", 
            "title": "Identifiers"
        }, 
        {
            "location": "/020-lexical_rules/#literals", 
            "text": "", 
            "title": "Literals"
        }, 
        {
            "location": "/020-lexical_rules/#booleans", 
            "text": "The boolean type has two values,  true  and  false .", 
            "title": "Booleans"
        }, 
        {
            "location": "/020-lexical_rules/#integers", 
            "text": "Integer values can be written in decimal and hexadecimal bases:   Decimals are written  as is .  Hexadecimals are prefixed with  0x .  TODO: \"0b---\", \"0o---\"   Examples:  // both are equal to the decimal 127\nv = 127;\nv = 0x7F;", 
            "title": "Integers"
        }, 
        {
            "location": "/020-lexical_rules/#floats", 
            "text": "TODO (like C)", 
            "title": "Floats"
        }, 
        {
            "location": "/020-lexical_rules/#null-pointer", 
            "text": "The  null  literal represents null  pointers .", 
            "title": "Null pointer"
        }, 
        {
            "location": "/020-lexical_rules/#strings", 
            "text": "A sequence of characters surrounded by  \"  is converted into a  null-terminated \nstring , just like in C:  Example:  _printf( Hello World!\\n );", 
            "title": "Strings"
        }, 
        {
            "location": "/020-lexical_rules/#comments", 
            "text": "C\u00e9u provides C-style comments.  Single-line comments begin with  //  and run to end of the line.  Multi-line comments use  /*  and  */  as delimiters.\nMulti-line comments can be nested by using a different number of  *  as\ndelimiters.  Examples:  var int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Comments"
        }, 
        {
            "location": "/030-types/", 
            "text": "Types\n\n\nC\u00e9u is statically typed, requiring all variables and events to be declared\nbefore they are used.\n\n\nA type is composed of a \ntype identifier\n, followed by a sequence\nof optional \npointer\n modifiers \n, and an optional \noption\n modifier \n?\n:\n\n\nType ::= ID_type {`\n\u00b4} [`?\u00b4]\n\n\n\n\nExamples:\n\n\nvar u8     v;   // \nv\n is of 8-bit unsigned integer type\nvar _rect  r;   // \nr\n is of external native type \nrect\n\nvar byte\n buf; // \nbuf\n is a pointer to a \nbyte\n\nvar Tree   t;   // \nt\n is a data of type \nTree\n\n\n\n\n\nPrimitive Types\n\n\nC\u00e9u has the following primitive types:\n\n\nvoid               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integer\ns16      u16       // signed and unsigned 16-bit integer\ns32      u32       // signed and unsigned 32-bit integer\ns64      u64       // signed and unsigned 64-bit integer\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types\n\n\n\n\nSee also the \nliterals\n for these types.\n\n\nNative Types\n\n\nTypes defined externally in C can be prefixed by \n_\n to be used in C\u00e9u programs.\n\n\nExample:\n\n\nvar _message_t msg;      // \nmessage_t\n is a C type defined in an external library\n\n\n\n\nNative types support [TODO-annotations] to provide additional information to\nthe compiler.\n\n\nAbstraction Types\n\n\nTODO (brief description)\n\n\nSee also \nAbstractions\n.\n\n\nType Modifiers\n\n\nTypes can be suffixed with the following modifiers: \n, \n?\n.\n\n\nPointer\n\n\nTODO (like C)\n\n\nTODO: restrictions\n    - cannot cross yielding statements\n\n\nOption\n\n\nTODO (like Maybe)", 
            "title": "Types"
        }, 
        {
            "location": "/030-types/#types", 
            "text": "C\u00e9u is statically typed, requiring all variables and events to be declared\nbefore they are used.  A type is composed of a  type identifier , followed by a sequence\nof optional  pointer  modifiers  , and an optional  option  modifier  ? :  Type ::= ID_type {` \u00b4} [`?\u00b4]  Examples:  var u8     v;   //  v  is of 8-bit unsigned integer type\nvar _rect  r;   //  r  is of external native type  rect \nvar byte  buf; //  buf  is a pointer to a  byte \nvar Tree   t;   //  t  is a data of type  Tree", 
            "title": "Types"
        }, 
        {
            "location": "/030-types/#primitive-types", 
            "text": "C\u00e9u has the following primitive types:  void               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integer\ns16      u16       // signed and unsigned 16-bit integer\ns32      u32       // signed and unsigned 32-bit integer\ns64      u64       // signed and unsigned 64-bit integer\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types  See also the  literals  for these types.", 
            "title": "Primitive Types"
        }, 
        {
            "location": "/030-types/#native-types", 
            "text": "Types defined externally in C can be prefixed by  _  to be used in C\u00e9u programs.  Example:  var _message_t msg;      //  message_t  is a C type defined in an external library  Native types support [TODO-annotations] to provide additional information to\nthe compiler.", 
            "title": "Native Types"
        }, 
        {
            "location": "/030-types/#abstraction-types", 
            "text": "TODO (brief description)  See also  Abstractions .", 
            "title": "Abstraction Types"
        }, 
        {
            "location": "/030-types/#type-modifiers", 
            "text": "Types can be suffixed with the following modifiers:  ,  ? .", 
            "title": "Type Modifiers"
        }, 
        {
            "location": "/030-types/#pointer", 
            "text": "TODO (like C)  TODO: restrictions\n    - cannot cross yielding statements", 
            "title": "Pointer"
        }, 
        {
            "location": "/030-types/#option", 
            "text": "TODO (like Maybe)", 
            "title": "Option"
        }, 
        {
            "location": "/040-storage_classes/", 
            "text": "Storage Classes\n\n\nStorage classes represent all entities that are stored in memory at runtime.\nC\u00e9u supports \nvariables\n, \nvectors\n, \nevents\n (external and internal), and\n\npools\n as storage classes.\nAn entity \ndeclaration\n consists of a storage class,\na \ntype\n, and an \nidentifier\n.\n\n\nExamples:\n\n\nvar       int    v;     // \nv\n is a variable of type \nint\n\nvector[9] byte   buf;   // \nbuf\n is a vector with at most 9 values of type \nbyte\n\ninput     void\n A;     // \nA\n is an external event that carries values of type \nvoid\n\npool[]    Anim   anims; // \nanims\n is a dynamic \npool\n for instances of type \nAnim\n\n\n\n\n\nA declaration binds the identifier with a memory location to hold values of the\nassociated type.\n\n\nLexical Scope\n\n\nStorage entities have lexical scope, i.e., they are visible only in the\n\nblock\n in which they are declared.\nThe lifetime of entities, (i.e., the period between allocation and deallocation\nin memory) is also limited to the scope of the enclosing block.\nHowever, individual elements inside \nvector\n and \npool\n entities have dynamic\nlifetime, but which never outlive the scope of the declaration.\n\n\nVariables\n\n\nAs in typical imperative languages, a variable in C\u00e9u holds a value of a\n\ndeclared\n \ntype\n that may vary during program execution.\nThe value of a variable can be read in \nexpressions\n or written in\n\nassignments\n.\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.\n\n\n\n\n\nNote: since blocks can contain parallel compositions, variables can be read\n       and written in trails in parallel.\n\n\nExample:\n\n\nvar int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)\n\n\n\n\nVectors\n\n\nIn C\u00e9u, a vector is a dynamic and contiguous collection of elements of the same\ntype.\nA vector \ndeclaration\n specifies its type and maximum number of\nelements (possibly unlimited).\nThe current size of a vector is dynamic and can be accessed through the\n\noperator \n$\n.\nIndividual elements of a vector can be accessed through a\n\nnumeric index\n starting from \n0\n.\n\n\nExample:\n\n\nvector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)\n\n\n\n\nEvents\n\n\nEvents are the most fundamental concept of C\u00e9u, accounting for its reactive \nnature.\nPrograms manipulate events through the \nawait\n and \nemit\n \nstatements\n.\nAn \nawait\n halts the running trail until that event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.\n\n\nAs described in the \nIntroduction\n, C\u00e9u supports external and internal events\nwith different behaviors.\n\n\nUnlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through \nemit\n and \nawait\n statements.\nA \ndeclaration\n includes the type of value the occurring event carries.\n\n\nNote: \nvoid\n is a valid type for signal-only internal events.\n\n\nExample:\n\n\ninput  void I;           // \nI\n is an external input event that carries no valuess\noutput int  O;           // \nO\n is an external output event that values of type \nint\n\nevent  int  e;           // \ne\n is an internal event that carries values of type \nint\n\npar/and do\n    await I;             // awakes when \nI\n occurs\n    emit e(10);          // broadcasts \ne\n passing 10, awakes the \nawait\n below\nwith\n    var int v = await e; // awaits \ne\n assigning the received value to \nv\n\n    emit O(v);           // emits \nO\n back to the environment passing \nv\n\nend\n\n\n\n\nExternal Events\n\n\nExternal events are used as interfaces between programs and devices from the \nreal world:\n\n\n\n\ninput\n events represent input devices, such as sensors, switches, etc.\n\n\noutput\n events represent output devices, such as LEDs, motors, etc.\n\n\n\n\nThe availability of external events depends on the platform in use.\nTherefore, external declarations only make pre-existing events visible to a \nprogram.\nRefer to \nEnvironment\n for information about interfacing with \nexternal events at the platform level.\n\n\nExternal Input Events\n\n\nAs a reactive language, programs in C\u00e9u have input events as entry points in\nthe code through \nawait statements\n.\nInput events represent the notion of \nlogical time\n in C\u00e9u.\n\n\nOnly the \nenvironment\n can emit inputs to the application.\nPrograms can only \nawait\n input events.\n\n\nExternal Output Events\n\n\nOutput events communicate values from the program back to the\n\nenvironment\n.\n\n\nPrograms can only \nemit\n output events.\n\n\nInternal Events\n\n\nInternal events serve as signalling and communication mechanisms between\ntrails in a program.\n\n\nPrograms can \nemit\n and \nawait\n internal events.\n\n\nPools\n\n\nA pool is a dynamic container to hold running \ncode abstractions\n.\nA pool \ndeclaration\n specifies the type of the abstraction and maximum\nnumber of concurrent instances (possibly unlimited).\nIndividual elements of a pool can only be accessed through \niterators\n.\nNew elements are created with \nspawn\n and are removed automatically when and\nonly the code execution terminates.\n\n\nExample:\n\n\ncode/await Anim (void) =\n void do       // defines a code abstraction\n    ...\nend\npool[] Anim ms;                         // declares an unlimited container for \nMove\n instances\nloop i in [0-\n10[ do\n    spawn Anim() in ms;                 // creates 10 instances of \nAnim\n into \nms\n\nend\n\n\n\n\nWhen a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.\n\n\nReferences\n\n\nC\u00e9u supports \naliases\n and \npointers\n as references to entities\n(a.k.a. as \nstrong\n and \nweak\n references, respectively).\n\n\nAn alias is an alternate view for an entity---after the entity and alias are\nbounded, they are indistinguishable.\nA pointer is the address of an entity and provides indirect access to it.\n\n\nAs an analogy with a person's identity,\na family nickname used by her family to refer to her is an alias;\na job position used by her company to refer to her is a pointer.\n\n\nAliases\n\n\nAn alias is \ndeclared\n by suffixing the storage class with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\n\n\nExample:\n\n\nvar  int v = 0;\nvar\n int a = \nv;        // \na\n is an alias to \nv\n\n...\na = 1;                  // \na\n and \nv\n are indistinguishable\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nAn alias must have a narrower scope than the entity it refers to.\nThe \nbinding\n to the alias is immutable and must occur between its\ndeclaration and first access or next \nyielding statement\n.\nIt is not possible to acquire aliases to external events or to pointer types.\n\n\nTODO: \n?\n\n\nPointers\n\n\nA pointer is \ndeclared\n by suffixing the type with the modifier\n\n and is acquired by prefixing an entity with the operator \n.\nApplying the operator \n*\n to a pointer provides indirect access to its\nreferenced entity.\n\n\nExample:\n\n\nvar int   v = 0;\nvar int\n p = \nv;      // \np\n holds a pointer to \nv\n\n...\n*p = 1;                 // \np\n provides indirect access to \nv\n\n_printf(\n%d\\n\n, v);     // prints 1\n\n\n\n\nC\u00e9u only supports pointers to \nprimitive\n and\n\ndata abstraction\n types.\nAlso, it is only possible to acquire pointers to variables (not to events,\nvectors, or pools).\nHowever, a variable of a pointer type is only visible between its declaration\nand the next \nyielding statement\n.", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/040-storage_classes/#storage-classes", 
            "text": "Storage classes represent all entities that are stored in memory at runtime.\nC\u00e9u supports  variables ,  vectors ,  events  (external and internal), and pools  as storage classes.\nAn entity  declaration  consists of a storage class,\na  type , and an  identifier .  Examples:  var       int    v;     //  v  is a variable of type  int \nvector[9] byte   buf;   //  buf  is a vector with at most 9 values of type  byte \ninput     void  A;     //  A  is an external event that carries values of type  void \npool[]    Anim   anims; //  anims  is a dynamic  pool  for instances of type  Anim   A declaration binds the identifier with a memory location to hold values of the\nassociated type.", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/040-storage_classes/#lexical-scope", 
            "text": "Storage entities have lexical scope, i.e., they are visible only in the block  in which they are declared.\nThe lifetime of entities, (i.e., the period between allocation and deallocation\nin memory) is also limited to the scope of the enclosing block.\nHowever, individual elements inside  vector  and  pool  entities have dynamic\nlifetime, but which never outlive the scope of the declaration.", 
            "title": "Lexical Scope"
        }, 
        {
            "location": "/040-storage_classes/#variables", 
            "text": "As in typical imperative languages, a variable in C\u00e9u holds a value of a declared   type  that may vary during program execution.\nThe value of a variable can be read in  expressions  or written in assignments .\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.   Note: since blocks can contain parallel compositions, variables can be read\n       and written in trails in parallel.  Example:  var int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)", 
            "title": "Variables"
        }, 
        {
            "location": "/040-storage_classes/#vectors", 
            "text": "In C\u00e9u, a vector is a dynamic and contiguous collection of elements of the same\ntype.\nA vector  declaration  specifies its type and maximum number of\nelements (possibly unlimited).\nThe current size of a vector is dynamic and can be accessed through the operator  $ .\nIndividual elements of a vector can be accessed through a numeric index  starting from  0 .  Example:  vector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)", 
            "title": "Vectors"
        }, 
        {
            "location": "/040-storage_classes/#events", 
            "text": "Events are the most fundamental concept of C\u00e9u, accounting for its reactive \nnature.\nPrograms manipulate events through the  await  and  emit   statements .\nAn  await  halts the running trail until that event occurs.\nAn event occurrence is broadcast to the whole program and awakes trails\nawaiting that event to resume execution.  As described in the  Introduction , C\u00e9u supports external and internal events\nwith different behaviors.  Unlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through  emit  and  await  statements.\nA  declaration  includes the type of value the occurring event carries.  Note:  void  is a valid type for signal-only internal events.  Example:  input  void I;           //  I  is an external input event that carries no valuess\noutput int  O;           //  O  is an external output event that values of type  int \nevent  int  e;           //  e  is an internal event that carries values of type  int \npar/and do\n    await I;             // awakes when  I  occurs\n    emit e(10);          // broadcasts  e  passing 10, awakes the  await  below\nwith\n    var int v = await e; // awaits  e  assigning the received value to  v \n    emit O(v);           // emits  O  back to the environment passing  v \nend", 
            "title": "Events"
        }, 
        {
            "location": "/040-storage_classes/#external-events", 
            "text": "External events are used as interfaces between programs and devices from the \nreal world:   input  events represent input devices, such as sensors, switches, etc.  output  events represent output devices, such as LEDs, motors, etc.   The availability of external events depends on the platform in use.\nTherefore, external declarations only make pre-existing events visible to a \nprogram.\nRefer to  Environment  for information about interfacing with \nexternal events at the platform level.", 
            "title": "External Events"
        }, 
        {
            "location": "/040-storage_classes/#external-input-events", 
            "text": "As a reactive language, programs in C\u00e9u have input events as entry points in\nthe code through  await statements .\nInput events represent the notion of  logical time  in C\u00e9u.  Only the  environment  can emit inputs to the application.\nPrograms can only  await  input events.", 
            "title": "External Input Events"
        }, 
        {
            "location": "/040-storage_classes/#external-output-events", 
            "text": "Output events communicate values from the program back to the environment .  Programs can only  emit  output events.", 
            "title": "External Output Events"
        }, 
        {
            "location": "/040-storage_classes/#internal-events", 
            "text": "Internal events serve as signalling and communication mechanisms between\ntrails in a program.  Programs can  emit  and  await  internal events.", 
            "title": "Internal Events"
        }, 
        {
            "location": "/040-storage_classes/#pools", 
            "text": "A pool is a dynamic container to hold running  code abstractions .\nA pool  declaration  specifies the type of the abstraction and maximum\nnumber of concurrent instances (possibly unlimited).\nIndividual elements of a pool can only be accessed through  iterators .\nNew elements are created with  spawn  and are removed automatically when and\nonly the code execution terminates.  Example:  code/await Anim (void) =  void do       // defines a code abstraction\n    ...\nend\npool[] Anim ms;                         // declares an unlimited container for  Move  instances\nloop i in [0- 10[ do\n    spawn Anim() in ms;                 // creates 10 instances of  Anim  into  ms \nend  When a pool declaration goes out of scope, all running code abstractions are\nautomatically aborted.", 
            "title": "Pools"
        }, 
        {
            "location": "/040-storage_classes/#references", 
            "text": "C\u00e9u supports  aliases  and  pointers  as references to entities\n(a.k.a. as  strong  and  weak  references, respectively).  An alias is an alternate view for an entity---after the entity and alias are\nbounded, they are indistinguishable.\nA pointer is the address of an entity and provides indirect access to it.  As an analogy with a person's identity,\na family nickname used by her family to refer to her is an alias;\na job position used by her company to refer to her is a pointer.", 
            "title": "References"
        }, 
        {
            "location": "/040-storage_classes/#aliases", 
            "text": "An alias is  declared  by suffixing the storage class with the modifier  and is acquired by prefixing an entity with the operator  .  Example:  var  int v = 0;\nvar  int a =  v;        //  a  is an alias to  v \n...\na = 1;                  //  a  and  v  are indistinguishable\n_printf( %d\\n , v);     // prints 1  An alias must have a narrower scope than the entity it refers to.\nThe  binding  to the alias is immutable and must occur between its\ndeclaration and first access or next  yielding statement .\nIt is not possible to acquire aliases to external events or to pointer types.  TODO:  ?", 
            "title": "Aliases"
        }, 
        {
            "location": "/040-storage_classes/#pointers", 
            "text": "A pointer is  declared  by suffixing the type with the modifier  and is acquired by prefixing an entity with the operator  .\nApplying the operator  *  to a pointer provides indirect access to its\nreferenced entity.  Example:  var int   v = 0;\nvar int  p =  v;      //  p  holds a pointer to  v \n...\n*p = 1;                 //  p  provides indirect access to  v \n_printf( %d\\n , v);     // prints 1  C\u00e9u only supports pointers to  primitive  and data abstraction  types.\nAlso, it is only possible to acquire pointers to variables (not to events,\nvectors, or pools).\nHowever, a variable of a pointer type is only visible between its declaration\nand the next  yielding statement .", 
            "title": "Pointers"
        }, 
        {
            "location": "/050-statements/", 
            "text": "Statements\n\n\nA program in C\u00e9u is a sequence of statements delimited by an enclosing block as\nfollows:\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\n\n\n\nNote: statements terminated with the \nend\n keyword do not require a\nterminating semicolon.\n\n\nBlocks\n\n\nA \nBlock\n creates a new scope for \nstorage entities\n which are visible\nonly for statements inside the block.\n\n\nCompound statements (e.g. \ndo-end\n, \nif-then-else\n, \nloops\n, etc.) create new\nblocks and can be nested to an arbitrary level.\n\n\ndo-end\n and \nescape\n\n\nThe \ndo-end\n statement creates an explicit block with an optional identifier.\nThe \nescape\n statement aborts the deepest enclosing \ndo-end\n matching its\nidentifier:\n\n\ndo [`/\u00b4 (`_\u00b4|ID_int)]\n    Block\nend\n\nescape [`/\u00b4ID_int] [Exp]\n\n\n\n\nA \ndo-end\n supports the identifier \n_\n which is guaranteed not to match any\n\nescape\n statement.\n\n\nExample:\n\n\ndo/a\n    do/_\n        do\n            escape;     // matches line 3\n        end\n        escape/a;       // matches line 1\n    end\nend\n\n\n\n\npre-do-end\n\n\nA \npre-do-end\n prepends its statements in the beginning of the program:\n\n\npre do\n    Block\nend\n\n\n\n\nAll \npre-do-end\n statements are concatenated together in the order they appear\nand moved to the beginning of the top-level block, before all other statements.\n\n\nDeclarations\n\n\nA declaration exposes a \nstorage entity\n to the program.\nIts \nscope\n begins after the declaration and goes until the end of the\nenclosing \nblock\n.\n\n\nSee also \nStorage Classes\n for a general overview of storage entities.\n\n\nVariables\n\n\nVariable declarations are as follows:\n\n\nvar [`\n\u00b4|`\n?\u00b4] Type LIST(ID_int [`=\u00b4 Set])\n\n\n\n\nA variable has an associated \ntype\n and can be optionally\n\ninitialized\n.\nA single statement can declare multiple variables of the same type.\nDeclarations can also be \naliases\n or \noption aliases\n.\n\n\nExamples:\n\n\nvar  int v = 10;    // \nv\n is an integer variable initialized to 10\nvar  int a=0, b=3;  // \na\n and \nb\n are integer variables initialized to 0 and 3\nvar\n int z = \nv;    // \nz\n is an alias to \nv\n\n\n\n\n\nVectors\n\n\nVector declarations are as follows:\n\n\nvector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n\n\n\n\nA vector has a dimension, an associated \ntype\n and can be optionally\n\ninitialized\n.\nA single statement can declare multiple vectors of the same dimension and type.\nDeclarations can also be \naliases\n.\n\n\nThe expression between the brackets specifies the dimension of the vector with\nthe options that follow:\n\n\n\n\nconstant expression\n: Maximum number of elements is fixed and space is\n                         statically pre-allocated.\n\n\nvariable expression\n: Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.\n\n\nomitted\n: Maximum number of elements is unbounded and space is dynamically\n             allocated.\n\n\n\n\nThe space for dynamic vectors grow and shrink automatically.\n\n\nExamples:\n\n\nvar int n = 10;\nvector[10] int vs1 = [];    // \nvs1\n is a static vector of 10 elements max\nvector[n]  int vs2 = [];    // \nvs2\n is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    // \nvs3\n is an unbounded vector\nvector\n[]  int vs4 = \nvs1;  // \nvs4\n is an alias to \nvs1\n\n\n\n\n\nEvents\n\n\nSee also \nIntroduction\n for a general overview of events.\n\n\nExternal events\n\n\nExternal event declarations are as follows:\n\n\ninput  (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\noutput (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n\n\n\n\nA declaration includes the \ntype\n of the value the event carries.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.\n\n\nExamples:\n\n\ninput  void A,B;        // \nA\n and \nB\n are input events carrying no values\noutput int  MY_EVT;     // \nMY_EVT\n is an output event carrying integer values\ninput (int,byte\n) BUF; // \nBUF\n is an input event carrying an \n(int,byte\n)\n pair\n\n\n\n\nInternal events\n\n\nInternal event declarations are as follows:\n\n\nevent [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])\n\n\n\n\nA declaration includes the \ntype\n of the value the event carries.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.\nDeclarations can also be \naliases\n or \noption aliases\n.\nOnly in this case they can contain an \ninitialization\n.\n\n\nExamples:\n\n\nevent  void a,b;        // \na\n and \nb\n are internal events carrying no values\nevent\n void z = \na;     // \nz\n is an alias to event \na\n\nevent (int,int) c;      // \nc\n is a internal event carrying an \n(int,int)\n pair", 
            "title": "Statements"
        }, 
        {
            "location": "/050-statements/#statements", 
            "text": "A program in C\u00e9u is a sequence of statements delimited by an enclosing block as\nfollows:  Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}  Note: statements terminated with the  end  keyword do not require a\nterminating semicolon.", 
            "title": "Statements"
        }, 
        {
            "location": "/050-statements/#blocks", 
            "text": "A  Block  creates a new scope for  storage entities  which are visible\nonly for statements inside the block.  Compound statements (e.g.  do-end ,  if-then-else ,  loops , etc.) create new\nblocks and can be nested to an arbitrary level.", 
            "title": "Blocks"
        }, 
        {
            "location": "/050-statements/#do-end-and-escape", 
            "text": "The  do-end  statement creates an explicit block with an optional identifier.\nThe  escape  statement aborts the deepest enclosing  do-end  matching its\nidentifier:  do [`/\u00b4 (`_\u00b4|ID_int)]\n    Block\nend\n\nescape [`/\u00b4ID_int] [Exp]  A  do-end  supports the identifier  _  which is guaranteed not to match any escape  statement.  Example:  do/a\n    do/_\n        do\n            escape;     // matches line 3\n        end\n        escape/a;       // matches line 1\n    end\nend", 
            "title": "do-end and escape"
        }, 
        {
            "location": "/050-statements/#pre-do-end", 
            "text": "A  pre-do-end  prepends its statements in the beginning of the program:  pre do\n    Block\nend  All  pre-do-end  statements are concatenated together in the order they appear\nand moved to the beginning of the top-level block, before all other statements.", 
            "title": "pre-do-end"
        }, 
        {
            "location": "/050-statements/#declarations", 
            "text": "A declaration exposes a  storage entity  to the program.\nIts  scope  begins after the declaration and goes until the end of the\nenclosing  block .  See also  Storage Classes  for a general overview of storage entities.", 
            "title": "Declarations"
        }, 
        {
            "location": "/050-statements/#variables", 
            "text": "Variable declarations are as follows:  var [` \u00b4|` ?\u00b4] Type LIST(ID_int [`=\u00b4 Set])  A variable has an associated  type  and can be optionally initialized .\nA single statement can declare multiple variables of the same type.\nDeclarations can also be  aliases  or  option aliases .  Examples:  var  int v = 10;    //  v  is an integer variable initialized to 10\nvar  int a=0, b=3;  //  a  and  b  are integer variables initialized to 0 and 3\nvar  int z =  v;    //  z  is an alias to  v", 
            "title": "Variables"
        }, 
        {
            "location": "/050-statements/#vectors", 
            "text": "Vector declarations are as follows:  vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])  A vector has a dimension, an associated  type  and can be optionally initialized .\nA single statement can declare multiple vectors of the same dimension and type.\nDeclarations can also be  aliases .  The expression between the brackets specifies the dimension of the vector with\nthe options that follow:   constant expression : Maximum number of elements is fixed and space is\n                         statically pre-allocated.  variable expression : Maximum number of elements is fixed but space is\n                         dynamically allocated.\n                         The expression is evaulated once at declaration time.  omitted : Maximum number of elements is unbounded and space is dynamically\n             allocated.   The space for dynamic vectors grow and shrink automatically.  Examples:  var int n = 10;\nvector[10] int vs1 = [];    //  vs1  is a static vector of 10 elements max\nvector[n]  int vs2 = [];    //  vs2  is a dynamic vector of 10 elements max\nvector[]   int vs3 = [];    //  vs3  is an unbounded vector\nvector []  int vs4 =  vs1;  //  vs4  is an alias to  vs1", 
            "title": "Vectors"
        }, 
        {
            "location": "/050-statements/#events", 
            "text": "See also  Introduction  for a general overview of events.", 
            "title": "Events"
        }, 
        {
            "location": "/050-statements/#external-events", 
            "text": "External event declarations are as follows:  input  (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\noutput (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)  A declaration includes the  type  of the value the event carries.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.  Examples:  input  void A,B;        //  A  and  B  are input events carrying no values\noutput int  MY_EVT;     //  MY_EVT  is an output event carrying integer values\ninput (int,byte ) BUF; //  BUF  is an input event carrying an  (int,byte )  pair", 
            "title": "External events"
        }, 
        {
            "location": "/050-statements/#internal-events", 
            "text": "Internal event declarations are as follows:  event [` \u00b4|` ?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])  A declaration includes the  type  of the value the event carries.\nIt can be also a list of types if the event communicates multiple values.\nA single statement can declare multiple events of the same type.\nDeclarations can also be  aliases  or  option aliases .\nOnly in this case they can contain an  initialization .  Examples:  event  void a,b;        //  a  and  b  are internal events carrying no values\nevent  void z =  a;     //  z  is an alias to event  a \nevent (int,int) c;      //  c  is a internal event carrying an  (int,int)  pair", 
            "title": "Internal events"
        }, 
        {
            "location": "/060-expressions/", 
            "text": "TODO", 
            "title": "Expressions"
        }, 
        {
            "location": "/070-static_analysis/", 
            "text": "TODO", 
            "title": "Static Analysis"
        }, 
        {
            "location": "/080-environment/", 
            "text": "TODO", 
            "title": "Environment"
        }, 
        {
            "location": "/090-errors/", 
            "text": "TODO", 
            "title": "Errors"
        }, 
        {
            "location": "/syntax/", 
            "text": "Syntax\n\n\nFollows the complete syntax of C\u00e9u in a BNF-like syntax:\n\n\n\n\nA\n : non terminal (starting in uppercase)\n\n\na\n : terminal (in bold and lowercase)\n\n\n.\n : terminal (non-alphanumeric characters)\n\n\nA ::= ...\n : defines \nA\n as \n...\n\n\nx y\n : \nx\n in sequence with \ny\n\n\nx|y\n : \nx\n or \ny\n\n\n{x}\n : zero or more xs\n\n\n[x]\n : optional x\n\n\nLIST(x)\n : expands to \nx {\n,\n x} [\n,\n]\n\n\n(...)\n : groups \n...\n\n\n...\n : special informal rule\n\n\n\n\nProgram ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      |  do [`/\u00b4(`_\u00b4|ID_int)]\n             Block\n         end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Classes */\n\n      | var [`\n\u00b4|`\n?\u00b4] Type LIST(ID_int [`=\u00b4 Set])\n      | vector [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | pool [`\n\u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | event [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      | output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n\n  /* Event handling */\n\n      // Await ::=\n      | await (ID_ext | Name) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await FOREVER\n\n      // Emit_Ext ::=\n      | emit ID_ext [`=\n\u00b4 (Exp | `(\u00b4 [LIST(Exp)] `)\u00b4)]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Name [`=\n\u00b4 (Exp | `(\u00b4 [LIST(Exp)] `)\u00b4)]\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (`_\u00b4|ID_int) in Range do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( Exp `-\n\u00b4 (`_\u00b4|Exp)\n                        | (`_\u00b4|Exp) `\n-\u00b4 Exp )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Name do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Name | `(\u00b4TODO/List_Name_Any`)\u00b4) in] (ID_ext|Name|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Pause */\n\n      | pause/if (Name|ID_ext) do\n            Block\n        end\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST((ID_ext|Name|WCLOCKK|WCLOCKE|Code) [`=\n\u00b4 `(\u00b4 LIST(Var) `)\u00b4]) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      // Async_Thread ::=\n      | await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [is Exp]\n      | data ID_abs [is Exp] [ with\n                                { \nvar|vector|pool|event declaration\n `;\u00b4 {`;\u00b4} }\n                               end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `=\n\u00b4 Type\n\n      // Code_Await ::=\n      | code/await [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `=\n\u00b4 [ `(\u00b4 Params `)\u00b4 `=\n\u00b4 ] (Type | FOREVER)\n        // where\n            Params ::= void | LIST([dynamic] Class ID_int)\n            Class ::= var [`\n\u00b4|`\n?\u00b4] [`/\u00b4hold] * Type\n                   |  vector `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  pool `\n\u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  event [`\n\u00b4|`\n?\u00b4] (Type | `(\u00b4LIST(Type)`)\u00b4)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code instantiation */\n\n      // Call_Code ::=\n      | call  Mods Code\n\n      // Await_Code ::=\n      | await Mods Code\n\n      // Spawn_Code ::=\n      | spawn Mods Code [in Name] [`=\n\u00b4 `(\u00b4 LIST(Var) `)\u00b4]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Code ::= ID_abs `(\u00b4 [LIST(Exp)] `)\u00b4\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n            \ncode definitions in C\n\n        end\n      | native `/\u00b4 end\n      | `{\u00b4 \ncode in C\n `}\u00b4\n\n      // Call_Nat ::=\n      | call [`/\u00b4recursive] (Name | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\n      /* finalization */\n      | do\n            Block\n        finalize `(\u00b4 LIST(Name) `)\u00b4 with\n            Block\n        end\n      | var `\n?\u00b4 Type ID_int `=\u00b4 `\n\u00b4 (Call_Nat | Call_Code)\n        finalize `(\u00b4 LIST(Name) `)\u00b4 with\n            Block\n        end\n\n  /* Lua integration */\n\n      // Lua ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            { \ncode in Lua\n | `@\u00b4 Exp }\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Assignments */\n\n      | (Name | `(\u00b4 (LIST(Name)|`_\u00b4) `)\u00b4) `=\u00b4 Set\n        // where\n            Set ::= ( Await\n                    | Emit_Ext\n                    | Watching\n                    | Async_Thread\n                    | Do\n                    | Data\n                    | Await_Code\n                    | Spawn_Code\n                    | Lua\n                    | Vector\n                    | `_\u00b4\n                    | Exp )\n            Data ::= (val|new) ID_abs `(\u00b4 LIST(Exp) `)\u00b4 \n            Vector ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua | `[\u00b4 [LIST(Exp)] `]\u00b4) }\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID         // beginning with lowercase\nID_ext   ::= ID         // all in uppercase, not beginning with digit\nID_abs   ::= ID         // beginning with uppercase, containining at least one lowercase)\nID_field ::= ID         // not beginning with digit\nID_nat   ::= ID         // beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { `\n\u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Expressions */\n\nName    ::= Name_01\nName_01 ::= [`*\u00b4|`$\u00b4] Name_02\nName_02 ::= Name_03 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nName_03 ::= `(\u00b4 Name_01 [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4 \ncode in C\n `}\u00b4\n\nExp  ::= Prim (combined with the \nOperator Precedence\n below)\nPrim ::= `(\u00b4 Exp `)\u00b4\n      |  `\n\u00b4 Name\n      |  Name [`?\u00b4]\n      |  `\n\u00b4 (Call_Nat | Name)\n      |  Call_Nat | Call_Code\n      |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n      |  NUM | STR | null | true | false\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::= \n [^\\\n\\n]* \n                        // regex\n\n/* Operator precedence */\n\n    /* lowest priority */\n    is    as\n    or\n    and\n    !=    ==    \n=    \n=    \n     \n\n    |\n    ^\n    \n\n    \n    \n\n    +     -\n    *     /     %\n    not   +    -    ~    $$\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive", 
            "title": "Syntax"
        }, 
        {
            "location": "/syntax/#syntax", 
            "text": "Follows the complete syntax of C\u00e9u in a BNF-like syntax:   A  : non terminal (starting in uppercase)  a  : terminal (in bold and lowercase)  .  : terminal (non-alphanumeric characters)  A ::= ...  : defines  A  as  ...  x y  :  x  in sequence with  y  x|y  :  x  or  y  {x}  : zero or more xs  [x]  : optional x  LIST(x)  : expands to  x { ,  x} [ , ]  (...)  : groups  ...  ...  : special informal rule   Program ::= Block\nBlock   ::= {Stmt `;\u00b4} {`;\u00b4}\n\nStmt ::= nothing\n\n  /* Blocks */\n\n      // Do ::=\n      |  do [`/\u00b4(`_\u00b4|ID_int)]\n             Block\n         end\n      |  escape [`/\u00b4ID_int] [Exp]\n\n      /* pre (top level) execution */\n      | pre do\n            Block\n        end\n\n  /* Storage Classes */\n\n      | var [` \u00b4|` ?\u00b4] Type LIST(ID_int [`=\u00b4 Set])\n      | vector [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | pool [` \u00b4] `[\u00b4 [Exp] `]\u00b4 Type LIST(ID_int [`=\u00b4 Set])\n      | event [` \u00b4|` ?\u00b4] (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_int [`=\u00b4 Set])\n      | input (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n      | output (Type | `(\u00b4 LIST(Type) `)\u00b4) LIST(ID_ext)\n\n  /* Event handling */\n\n      // Await ::=\n      | await (ID_ext | Name) [until Exp]\n      | await (WCLOCKK|WCLOCKE)\n      //\n      | await FOREVER\n\n      // Emit_Ext ::=\n      | emit ID_ext [`= \u00b4 (Exp | `(\u00b4 [LIST(Exp)] `)\u00b4)]\n      | emit (WCLOCKK|WCLOCKE)\n      //\n      | emit Name [`= \u00b4 (Exp | `(\u00b4 [LIST(Exp)] `)\u00b4)]\n\n  /* Conditional */\n\n      | if Exp then\n            Block\n        { else/if Exp then\n            Block }\n        [ else\n            Block ]\n        end\n\n  /* Loops */\n\n      /* simple */\n      | loop [`/\u00b4Exp] do\n            Block\n        end\n\n      /* numeric iterator */\n      | loop [`/\u00b4Exp] (`_\u00b4|ID_int) in Range do\n            Block\n        end\n        // where\n            Range ::= (`[\u00b4 | `]\u00b4)\n                        ( Exp `- \u00b4 (`_\u00b4|Exp)\n                        | (`_\u00b4|Exp) ` -\u00b4 Exp )\n                      (`[\u00b4 | `]\u00b4) [`,\u00b4 Exp]\n\n      /* pool iterator */\n      | loop [`/\u00b4Exp] [ `(\u00b4 LIST(Var) `)\u00b4 ] in Name do\n            Block\n        end\n\n      /* event iterator */\n      | every [(Name | `(\u00b4TODO/List_Name_Any`)\u00b4) in] (ID_ext|Name|WCLOCKK|WCLOCKE) do\n            Block\n        end\n\n      |  break [`/\u00b4ID_int]\n      |  continue [`/\u00b4ID_int]\n\n  /* Pause */\n\n      | pause/if (Name|ID_ext) do\n            Block\n        end\n\n  /* Parallel Compositions */\n\n      /* parallels */\n      | (par | par/and | par/or) do\n            Block\n        with\n            Block\n        { with\n            Block }\n         end\n\n      /* watching */\n      // Watching ::=\n      | watching LIST((ID_ext|Name|WCLOCKK|WCLOCKE|Code) [`= \u00b4 `(\u00b4 LIST(Var) `)\u00b4]) do\n            Block\n        end\n\n      /* block spawn */\n      | spawn do\n            Block\n        end\n\n  /* Asynchronous Execution */\n\n      | await async [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      // Async_Thread ::=\n      | await async/thread [ `(\u00b4LIST(Var)`)\u00b4 ] do\n            Block\n        end\n\n      /* synchronization */\n      | atomic do\n            Block\n        end\n\n  /* Abstractions */\n\n      /* Data */\n\n      | data ID_abs [is Exp]\n      | data ID_abs [is Exp] [ with\n                                {  var|vector|pool|event declaration  `;\u00b4 {`;\u00b4} }\n                               end ]\n\n      /* Code */\n\n      // Code_Tight ::=\n      | code/tight [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `= \u00b4 Type\n\n      // Code_Await ::=\n      | code/await [`/\u00b4dynamic] [`/\u00b4recursive] ID_abs `(\u00b4 Params `)\u00b4 `= \u00b4 [ `(\u00b4 Params `)\u00b4 `= \u00b4 ] (Type | FOREVER)\n        // where\n            Params ::= void | LIST([dynamic] Class ID_int)\n            Class ::= var [` \u00b4|` ?\u00b4] [`/\u00b4hold] * Type\n                   |  vector ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  pool ` \u00b4 `[\u00b4 [Exp] `]\u00b4 Type\n                   |  event [` \u00b4|` ?\u00b4] (Type | `(\u00b4LIST(Type)`)\u00b4)\n\n      /* code implementation */\n      | (Code_Tight | Code_Await) do\n            Block\n        end\n\n      /* code instantiation */\n\n      // Call_Code ::=\n      | call  Mods Code\n\n      // Await_Code ::=\n      | await Mods Code\n\n      // Spawn_Code ::=\n      | spawn Mods Code [in Name] [`= \u00b4 `(\u00b4 LIST(Var) `)\u00b4]\n\n        // where\n            Mods ::= [`/\u00b4dynamic | `/\u00b4static] [`/\u00b4recursive]\n            Code ::= ID_abs `(\u00b4 [LIST(Exp)] `)\u00b4\n\n  /* C integration */\n\n      | native [`/\u00b4(pure|const|nohold|plain)] `(\u00b4 List_Nat `)\u00b4\n        // where\n            List_Nat ::= LIST(ID_nat)\n      | native `/\u00b4(pre|pos) do\n             code definitions in C \n        end\n      | native `/\u00b4 end\n      | `{\u00b4  code in C  `}\u00b4\n\n      // Call_Nat ::=\n      | call [`/\u00b4recursive] (Name | `(\u00b4 Exp `)\u00b4)  `(\u00b4 [ LIST(Exp)] `)\u00b4\n\n      /* finalization */\n      | do\n            Block\n        finalize `(\u00b4 LIST(Name) `)\u00b4 with\n            Block\n        end\n      | var ` ?\u00b4 Type ID_int `=\u00b4 ` \u00b4 (Call_Nat | Call_Code)\n        finalize `(\u00b4 LIST(Name) `)\u00b4 with\n            Block\n        end\n\n  /* Lua integration */\n\n      // Lua ::=\n      | lua `[\u00b4 [Exp] `]\u00b4 do\n            Block\n        end\n      | `[\u00b4 {`=\u00b4} `[\u00b4\n            {  code in Lua  | `@\u00b4 Exp }\n        `]\u00b4 {`=\u00b4} `]\u00b4\n\n  /* Assignments */\n\n      | (Name | `(\u00b4 (LIST(Name)|`_\u00b4) `)\u00b4) `=\u00b4 Set\n        // where\n            Set ::= ( Await\n                    | Emit_Ext\n                    | Watching\n                    | Async_Thread\n                    | Do\n                    | Data\n                    | Await_Code\n                    | Spawn_Code\n                    | Lua\n                    | Vector\n                    | `_\u00b4\n                    | Exp )\n            Data ::= (val|new) ID_abs `(\u00b4 LIST(Exp) `)\u00b4 \n            Vector ::= (Exp | `[\u00b4 [LIST(Exp)] `]\u00b4) { `..\u00b4 (Exp | Lua | `[\u00b4 [LIST(Exp)] `]\u00b4) }\n\n/* Identifiers */\n\nID       ::= [a-zA-Z0-9_]+\nID_int   ::= ID         // beginning with lowercase\nID_ext   ::= ID         // all in uppercase, not beginning with digit\nID_abs   ::= ID         // beginning with uppercase, containining at least one lowercase)\nID_field ::= ID         // not beginning with digit\nID_nat   ::= ID         // beginning with underscore\nID_type  ::= ( ID_nat | ID_abs\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n/* Types */\n\nType ::= ID_type { ` \u00b4 } [`?\u00b4]\n\n/* Wall-clock values */\n\nWCLOCKK ::= [NUM h] [NUM min] [NUM s] [NUM ms] [NUM us]\nWCLOCKE ::= `(\u00b4 Exp `)\u00b4 (h|min|s|ms|us)\n\n/* Expressions */\n\nName    ::= Name_01\nName_01 ::= [`*\u00b4|`$\u00b4] Name_02\nName_02 ::= Name_03 { `[\u00b4Exp`]\u00b4 | (`:\u00b4|`.\u00b4) (ID_int|ID_nat) | `!\u00b4 }\nName_03 ::= `(\u00b4 Name_01 [as (Type | `/\u00b4(nohold|plain|pure)) `)\u00b4\n         |  ID_int\n         |  ID_nat\n         |  outer\n         |  `{\u00b4  code in C  `}\u00b4\n\nExp  ::= Prim (combined with the  Operator Precedence  below)\nPrim ::= `(\u00b4 Exp `)\u00b4\n      |  ` \u00b4 Name\n      |  Name [`?\u00b4]\n      |  ` \u00b4 (Call_Nat | Name)\n      |  Call_Nat | Call_Code\n      |  sizeof `(\u00b4 (Type|Exp) `)\u00b4\n      |  NUM | STR | null | true | false\n\n/* Literals */\n\nNUM ::= [0-9] ([0-9]|[xX]|[A-F]|[a-f]|\\.)*  // regex\nSTR ::=   [^\\ \\n]*                          // regex\n\n/* Operator precedence */\n\n    /* lowest priority */\n    is    as\n    or\n    and\n    !=    ==     =     =           \n    |\n    ^\n     \n          \n    +     -\n    *     /     %\n    not   +    -    ~    $$\n    /* highest priority */\n\n/* Other */\n\n    // single-line comment\n\n    /** nested\n        /* multi-line */\n        comments **/\n\n    # preprocessor directive", 
            "title": "Syntax"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nC\u00e9u is distributed under the MIT license reproduced below:\n\n\n Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \nSoftware\n), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "C\u00e9u is distributed under the MIT license reproduced below:   Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the  Software ), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }
    ]
}