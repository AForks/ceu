{
    "docs": [
        {
            "location": "/", 
            "text": "C\u00e9u v0.20 - Reference Manual\n\n\n\n\nIntroduction\n\n\nLexical Rules\n\n\nTypes\n\n\nStorage Classes\n\n\nLicense", 
            "title": "Home"
        }, 
        {
            "location": "/#ceu-v020-reference-manual", 
            "text": "Introduction  Lexical Rules  Types  Storage Classes  License", 
            "title": "C\u00e9u v0.20 - Reference Manual"
        }, 
        {
            "location": "/010-introduction/", 
            "text": "Introduction\n\n\nC\u00e9u provides \nStructured Synchronous Reactive Programming\n which supports\nsafe and deterministic concurrency with side effects.\nThe lines of execution in C\u00e9u, known as \ntrails\n, react together continuously\nand in synchronous steps to external input events from the environment.\nWaiting for an event halts the running trail until that event occurs.\nThe environment broadcasts an occurring event to all active trails, which share \na single global time reference.\n\n\nThe synchronous concurrency model of C\u00e9u diverges from multithreading and also\nfrom actor-based models (e.g. \npthreads\n and \nerlang\n).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, trails can share variables deterministically without\nsynchronization primitives (i.e., no \nlocks\n, \nsemaphores\n, or \nqueues\n).\n\n\nC\u00e9u provides automatic memory management based on static lexical scopes (i.e.,\nno \nfree\n or \ndelete\n) and does not require runtime garbage collection.\n\n\nC\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers.\n\n\nC\u00e9u is \nfree software\n.\n\n\nSynchronous Execution Model\n\n\nC\u00e9u is grounded on a precise definition of \nlogical time\n (as opposed to\n\nphysical\n or \nwall-clock time\n) as a discrete sequence of external input\nevents:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see \nBounded Execution\n).\n\n\nThe execution model for C\u00e9u programs is as follows:\n\n\n\n\nThe program initiates the \nboot reaction\n from the first line of code in a\n      single trail.\n\n\nActive trails\n1\n, one after another, execute until they await or \n      terminate.\n      This step is named a \nreaction chain\n, and always runs in bounded time.\n\n\nThe program goes idle and the environment takes control.\n\n\nOn the occurrence of a new external input event, the environment awakes \n      \nall\n trails awaiting that event.\n      It then goes to step 2.\n\n\n\n\n(\n1\n\n\nTrails can be created with \nparallel \ncompositions\n.\n)\n\n\nThe synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run \ninfinitely faster\n in comparison to the rate of external events.\nA reaction chain is the set of computations that execute when an external \nevent occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new external input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is somewhat arbitrary, but provides a priority scheme for trails, \nand also ensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.\n\n\nThe program and diagram below illustrate the behavior of the scheduler of C\u00e9u:\n\n\n 1:  input void A, B, C;\n 2:  par/and do           // A, B, and C are external input events\n 3:      // trail 1\n 4:      \n...\n            // \n...\n represents non-awaiting statements\n 5:      await A;\n 6:      \n...\n\n 7:  with\n 8:      // trail 2\n 9:      \n...\n\n10:      await B;\n11:      \n...\n\n12:  with\n13:      // trail 3\n14:      \n...\n\n15:      await A;\n16:      \n...\n\n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:          \n...\n\n21:      with\n22:          // trail 4\n23:          \n...\n\n24:      end\n25:  end\n\n\n\n\n\n\nThe program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows (\nt0\n in the diagram):\n\n\n\n\ntrail-1\n executes up to the \nawait A\n (line 5);\n\n\ntrail-2\n, up to the \nawait B\n (line 10);\n\n\ntrail-3\n, up to \nawait A\n (line 15).\n\n\n\n\nAs no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event \nA\n occurs (\nt1\n in the diagram):\n\n\n\n\ntrail-1\n awakes, executes and terminates (line 6);\n\n\ntrail-2\n remains suspended, as it is not awaiting \nA\n.\n\n\ntrail-3\n executes up to \nawait B\n (line 17).\n\n\n\n\nDuring the reaction \nt1\n, new instances of events \nA\n, \nB\n, and \nC\n occur and\nare enqueued to be handled in the reactions in sequence.\nAs \nA\n happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n(\nt2\n in the diagram).\nThe next reaction dequeues the event \nB\n (\nt3\n in the diagram):\n\n\n\n\ntrail-2\n awakes, executes and terminates;\n\n\ntrail-3\n splits in two and they both terminate immediately.\n\n\n\n\nA \npar/and\n rejoins after all trails terminate.\nWith all trails terminated, the program also terminates and does not react to \nthe pending event \nC\n.\n\n\nNote that each step in the logical time line (\nt0\n, \nt1\n, etc.) is identified \nby the unique event it handles.\nInside a reaction, trails only react to that identifying event (or remain \nsuspended).\n\n\n\n\n\nParallel Compositions and Abortion\n\n\nThe use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:\n\n\n\n\na \npar/and\n rejoins after all trails in parallel terminate;\n\n\na \npar/or\n rejoins after any trail in parallel terminates, aborting all\n   other trails;\n\n\na \npar\n never rejoins, even if all trails terminate.\n\n\n\n\nThe termination of a trail inside a \npar/or\n aborts the other trails in \nparallel which are necessarily idle\n(see \nrule 2\n for external reactions\n).\nBefore being aborted, a trail has a last opportunity to execute active \n\nfinalization statements\n.\n\n\nAs mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions should read as \nawaiting in parallel\n, rather\nthan \nexecuting in parallel\n.\n\n\nBounded Execution\n\n\nReaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle upcoming input events from the environment.\nFor this reason, C\u00e9u requires every path inside the body of a \nloop\n statement\nto contain at least one \nawait\n or \nbreak\n statement.\nThis prevents \ntight loops\n, i.e., unbounded loops that do not await.\n\n\nIn the example below, the true branch of the \nif\n may never execute, resulting\nin a tight loop when the condition is false:\n\n\nloop do\n    if \ncond\n then\n        break;\n    end\nend\n\n\n\n\nC\u00e9u complains about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides \nAsynchronous \nExecution\n.\n\n\nDeterministic Execution\n\n\nTODO (shared memory + deterministic scheduler + optional static analysis)\n\n\nInternal Reactions\n\n\nC\u00e9u supports inter-trail communication through \nawait\n and \nemit\n statements\nfor \ninternal events\n.\nA trail can \nemit\n an event which is broadcast to the program to awake trails\nin parallel that are blocked in an \nawait\n statement for that same event.\n\n\nAn \nemit\n starts a new \ninternal reaction\n in the program relying on a\nruntime stack:\n\n\n\n\nAn \nemit\n suspends the current trail and its continuation is pushed into the\n    stack (i.e., the statement in sequence with the \nemit\n).\n\n\nAll trails awaiting the emitted event awake and execute\n    (see \nrule 2\n for external reactions\n).\n\n\nThe top of stack is popped and the last emitting trail resumes execution\n    from its continuation.\n\n\n\n\nNote that if an awaking trail emits another internal event (in \nrule 2\n), a\nnested internal reaction starts (in \nrule 1\n).\nExample:\n\n\n1:  par/and do\n2:      await e;\n3:      emit f;\n4:  with\n5:      await f;\n6:  with\n7:      ...\n8:      emit e;\n9:  end\n\n\n\n\nThe \nemit e\n in \ntrail-3\n (line 8) starts an internal reaction that awakes the \n\nawait e\n in \ntrail-1\n (line 2).\nThen, the \nemit f\n (line 3) starts another internal reaction that awakes the \n\nawait f\n in \ntrail-2\n (line 5).\n\nTrail-2\n terminates and the \nemit f\n resumes in \ntrail-1\n.\n\nTrail-1\n terminates and the \nemit e\n resumes in \ntrail-3\n.\n\nTrail-3\n terminates.\nFinally, the \npar/and\n rejoins and the program terminates.", 
            "title": "Introduction"
        }, 
        {
            "location": "/010-introduction/#introduction", 
            "text": "C\u00e9u provides  Structured Synchronous Reactive Programming  which supports\nsafe and deterministic concurrency with side effects.\nThe lines of execution in C\u00e9u, known as  trails , react together continuously\nand in synchronous steps to external input events from the environment.\nWaiting for an event halts the running trail until that event occurs.\nThe environment broadcasts an occurring event to all active trails, which share \na single global time reference.  The synchronous concurrency model of C\u00e9u diverges from multithreading and also\nfrom actor-based models (e.g.  pthreads  and  erlang ).\nOn the one hand, there is no real parallelism at the synchronous kernel of the\nlanguage (i.e., no multi-core execution).\nOn the other hand, trails can share variables deterministically without\nsynchronization primitives (i.e., no  locks ,  semaphores , or  queues ).  C\u00e9u provides automatic memory management based on static lexical scopes (i.e.,\nno  free  or  delete ) and does not require runtime garbage collection.  C\u00e9u integrates safely with C, and programs can define and make native calls\nseamlessly while avoiding memory leaks and dangling pointers.  C\u00e9u is  free software .", 
            "title": "Introduction"
        }, 
        {
            "location": "/010-introduction/#synchronous-execution-model", 
            "text": "C\u00e9u is grounded on a precise definition of  logical time  (as opposed to physical  or  wall-clock time ) as a discrete sequence of external input\nevents:\na sequence because only a single input event is handled at a logical time; \ndiscrete because reactions to events are guaranteed to execute in bounded\nphysical time (see  Bounded Execution ).  The execution model for C\u00e9u programs is as follows:   The program initiates the  boot reaction  from the first line of code in a\n      single trail.  Active trails 1 , one after another, execute until they await or \n      terminate.\n      This step is named a  reaction chain , and always runs in bounded time.  The program goes idle and the environment takes control.  On the occurrence of a new external input event, the environment awakes \n       all  trails awaiting that event.\n      It then goes to step 2.   ( 1  Trails can be created with  parallel \ncompositions . )  The synchronous execution model of C\u00e9u is based on the hypothesis that reaction\nchains run  infinitely faster  in comparison to the rate of external events.\nA reaction chain is the set of computations that execute when an external \nevent occurs.\nConceptually, a program takes no time on step 2 and is always idle on step 3.\nIn practice, if a new external input event occurs while a reaction chain is \nrunning (step 2), it is enqueued to run in the next reaction.\nWhen multiple trails are active at a logical time (i.e. awaking from the same \nevent), C\u00e9u schedules them in the order they appear in the program text.\nThis policy is somewhat arbitrary, but provides a priority scheme for trails, \nand also ensures deterministic and reproducible execution for programs.\nAt any time, at most one trail is executing.  The program and diagram below illustrate the behavior of the scheduler of C\u00e9u:   1:  input void A, B, C;\n 2:  par/and do           // A, B, and C are external input events\n 3:      // trail 1\n 4:       ...             //  ...  represents non-awaiting statements\n 5:      await A;\n 6:       ... \n 7:  with\n 8:      // trail 2\n 9:       ... \n10:      await B;\n11:       ... \n12:  with\n13:      // trail 3\n14:       ... \n15:      await A;\n16:       ... \n17:      await B;\n18:      par/and do\n19:          // trail 3\n20:           ... \n21:      with\n22:          // trail 4\n23:           ... \n24:      end\n25:  end   The program starts in the boot reaction and forks into three trails.\nRespecting the lexical order of declaration for the trails, they are scheduled\nas follows ( t0  in the diagram):   trail-1  executes up to the  await A  (line 5);  trail-2 , up to the  await B  (line 10);  trail-3 , up to  await A  (line 15).   As no other trails are pending, the reaction chain terminates and the scheduler \nremains idle until the event  A  occurs ( t1  in the diagram):   trail-1  awakes, executes and terminates (line 6);  trail-2  remains suspended, as it is not awaiting  A .  trail-3  executes up to  await B  (line 17).   During the reaction  t1 , new instances of events  A ,  B , and  C  occur and\nare enqueued to be handled in the reactions in sequence.\nAs  A  happened first, it is used in the next reaction.\nHowever, no trails are awaiting it, so an empty reaction chain takes place \n( t2  in the diagram).\nThe next reaction dequeues the event  B  ( t3  in the diagram):   trail-2  awakes, executes and terminates;  trail-3  splits in two and they both terminate immediately.   A  par/and  rejoins after all trails terminate.\nWith all trails terminated, the program also terminates and does not react to \nthe pending event  C .  Note that each step in the logical time line ( t0 ,  t1 , etc.) is identified \nby the unique event it handles.\nInside a reaction, trails only react to that identifying event (or remain \nsuspended).", 
            "title": "Synchronous Execution Model"
        }, 
        {
            "location": "/010-introduction/#parallel-compositions-and-abortion", 
            "text": "The use of trails in parallel allows programs to wait for multiple events at \nthe same time.\nC\u00e9u supports three kinds of parallel compositions that differ in how they\nrejoin and proceed to the statement in sequence:   a  par/and  rejoins after all trails in parallel terminate;  a  par/or  rejoins after any trail in parallel terminates, aborting all\n   other trails;  a  par  never rejoins, even if all trails terminate.   The termination of a trail inside a  par/or  aborts the other trails in \nparallel which are necessarily idle\n(see  rule 2  for external reactions ).\nBefore being aborted, a trail has a last opportunity to execute active  finalization statements .  As mentioned in the introduction and emphasized in the execution model, trails\nin parallel do not execute with real parallelism.\nTherefore, parallel compositions should read as  awaiting in parallel , rather\nthan  executing in parallel .", 
            "title": "Parallel Compositions and Abortion"
        }, 
        {
            "location": "/010-introduction/#bounded-execution", 
            "text": "Reaction chains must run in bounded time to guarantee that programs are \nresponsive and can handle upcoming input events from the environment.\nFor this reason, C\u00e9u requires every path inside the body of a  loop  statement\nto contain at least one  await  or  break  statement.\nThis prevents  tight loops , i.e., unbounded loops that do not await.  In the example below, the true branch of the  if  may never execute, resulting\nin a tight loop when the condition is false:  loop do\n    if  cond  then\n        break;\n    end\nend  C\u00e9u complains about tight loops in programs at compile time.\nFor time-consuming algorithms that require unrestricted loops (e.g., \ncryptography, image processing), C\u00e9u provides  Asynchronous \nExecution .", 
            "title": "Bounded Execution"
        }, 
        {
            "location": "/010-introduction/#deterministic-execution", 
            "text": "TODO (shared memory + deterministic scheduler + optional static analysis)", 
            "title": "Deterministic Execution"
        }, 
        {
            "location": "/010-introduction/#internal-reactions", 
            "text": "C\u00e9u supports inter-trail communication through  await  and  emit  statements\nfor  internal events .\nA trail can  emit  an event which is broadcast to the program to awake trails\nin parallel that are blocked in an  await  statement for that same event.  An  emit  starts a new  internal reaction  in the program relying on a\nruntime stack:   An  emit  suspends the current trail and its continuation is pushed into the\n    stack (i.e., the statement in sequence with the  emit ).  All trails awaiting the emitted event awake and execute\n    (see  rule 2  for external reactions ).  The top of stack is popped and the last emitting trail resumes execution\n    from its continuation.   Note that if an awaking trail emits another internal event (in  rule 2 ), a\nnested internal reaction starts (in  rule 1 ).\nExample:  1:  par/and do\n2:      await e;\n3:      emit f;\n4:  with\n5:      await f;\n6:  with\n7:      ...\n8:      emit e;\n9:  end  The  emit e  in  trail-3  (line 8) starts an internal reaction that awakes the  await e  in  trail-1  (line 2).\nThen, the  emit f  (line 3) starts another internal reaction that awakes the  await f  in  trail-2  (line 5). Trail-2  terminates and the  emit f  resumes in  trail-1 . Trail-1  terminates and the  emit e  resumes in  trail-3 . Trail-3  terminates.\nFinally, the  par/and  rejoins and the program terminates.", 
            "title": "Internal Reactions"
        }, 
        {
            "location": "/020-lexical_rules/", 
            "text": "Lexical Rules\n\n\nKeywords\n\n\nKeywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):\n\n\n    and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    loop            lua             native          new             nohold          \n\n    not             nothing         null            or              outer           \n\n    output          par             pause           plain           pool            \n\n    pos             pre             pure            recursive       request         \n\n    sizeof          spawn           then            thread          tight           \n\n    traverse        true            until           val             var             \n\n    vector          watching        with            bool            byte            \n\n    f32             f64             float           int             s16             \n\n    s32             s64             s8              ssize           u16             \n\n    u32             u64             u8              uint            usize           \n\n    void            \n\n\n\n\nIdentifiers\n\n\nC\u00e9u uses identifiers to refer to \ntypes\n, \nvariables\n, \nvectors\n, \npools\n,\n\ninternal events\n, \nexternal events\n, \ncode abstractions\n, \ndata abstractions\n,\n\nfields\n, \nnative symbols\n, and \nblock labels\n.\n\n\nID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID (first is lowercase)                        // variables, vectors, pools, internal events, and block labels\nID_ext   ::= ID (all in uppercase, first is not digit)      // external events\nID_abs   ::= ID (first is uppercase, contains lowercase)    // data and code abstractions\nID_field ::= ID (first is not digit)                        // fields\nID_nat   ::= ID (first is underscore)                       // native symbols\nID_type  ::= ( ID_nat | ID_abs                              // types\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )\n\n\n\n\nDeclarations for \ncode\n and \ndata\n [TODO-abstractions] create new [types] which can\nbe used as type identifiers.\n\n\nExamples:\n\n\nvar int a;                    // \na\n is a variable, \nint\n is a type\nemit e;                       // \ne\n is an internal event\nawait E;                      // \nE\n is an external input event\nspawn Move();                 // \nMove\n is a code abstraction and a type\nvar Rect r;                   // \nRect\n is a data abstraction and a type\nreturn r.width;               // \nwidth\n is a field\n_printf(\nhello world!\\n\n);    // \n_printf\n is a native symbol\n\n\n\n\nLiterals\n\n\nBooleans\n\n\nThe boolean type has two values, \ntrue\n and \nfalse\n.\n\n\nIntegers\n\n\nInteger values can be written in decimal and hexadecimal bases:\n\n\n\n\nDecimals are written \nas is\n.\n\n\nHexadecimals are prefixed with \n0x\n.\n\n\nTODO: \"0b---\", \"0o---\"\n\n\n\n\nExamples:\n\n\n// both are equal to the decimal 127\nv = 127;\nv = 0x7F;\n\n\n\n\nFloats\n\n\nTODO (like C)\n\n\nNull pointer\n\n\nThe \nnull\n literal represents null \npointers\n.\n\n\nStrings\n\n\nA sequence of characters surrounded by \n\"\n is converted into a \nnull-terminated \nstring\n, just like in C:\n\n\nExample:\n\n\n_printf(\nHello World!\\n\n);\n\n\n\n\nComments\n\n\nC\u00e9u provides C-style comments.\n\n\nSingle-line comments begin with \n//\n and run to end of the line.\n\n\nMulti-line comments use \n/*\n and \n*/\n as delimiters.\nMulti-line comments can be nested by using a different number of \n*\n as\ndelimiters.\n\n\nExamples:\n\n\nvar int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/020-lexical_rules/#lexical-rules", 
            "text": "", 
            "title": "Lexical Rules"
        }, 
        {
            "location": "/020-lexical_rules/#keywords", 
            "text": "Keywords in C\u00e9u are reserved names that cannot be used as identifiers (e.g., \nvariable names):      and             as              async           atomic          await           \n\n    break           call            code            const           continue        \n\n    data            deterministic   do              dynamic         else            \n\n    emit            end             escape          event           every           \n\n    false           finalize        FOREVER         hold            if              \n\n    in              input           is              isr             kill            \n\n    loop            lua             native          new             nohold          \n\n    not             nothing         null            or              outer           \n\n    output          par             pause           plain           pool            \n\n    pos             pre             pure            recursive       request         \n\n    sizeof          spawn           then            thread          tight           \n\n    traverse        true            until           val             var             \n\n    vector          watching        with            bool            byte            \n\n    f32             f64             float           int             s16             \n\n    s32             s64             s8              ssize           u16             \n\n    u32             u64             u8              uint            usize           \n\n    void", 
            "title": "Keywords"
        }, 
        {
            "location": "/020-lexical_rules/#identifiers", 
            "text": "C\u00e9u uses identifiers to refer to  types ,  variables ,  vectors ,  pools , internal events ,  external events ,  code abstractions ,  data abstractions , fields ,  native symbols , and  block labels .  ID       ::= [a-z, A-Z, 0-9, _]+\nID_int   ::= ID (first is lowercase)                        // variables, vectors, pools, internal events, and block labels\nID_ext   ::= ID (all in uppercase, first is not digit)      // external events\nID_abs   ::= ID (first is uppercase, contains lowercase)    // data and code abstractions\nID_field ::= ID (first is not digit)                        // fields\nID_nat   ::= ID (first is underscore)                       // native symbols\nID_type  ::= ( ID_nat | ID_abs                              // types\n             | void  | bool  | byte\n             | f32   | f64   | float\n             | s8    | s16   | s32   | s64\n             | u8    | u16   | u32   | u64\n             | int   | uint  | ssize | usize )  Declarations for  code  and  data  [TODO-abstractions] create new [types] which can\nbe used as type identifiers.  Examples:  var int a;                    //  a  is a variable,  int  is a type\nemit e;                       //  e  is an internal event\nawait E;                      //  E  is an external input event\nspawn Move();                 //  Move  is a code abstraction and a type\nvar Rect r;                   //  Rect  is a data abstraction and a type\nreturn r.width;               //  width  is a field\n_printf( hello world!\\n );    //  _printf  is a native symbol", 
            "title": "Identifiers"
        }, 
        {
            "location": "/020-lexical_rules/#literals", 
            "text": "", 
            "title": "Literals"
        }, 
        {
            "location": "/020-lexical_rules/#booleans", 
            "text": "The boolean type has two values,  true  and  false .", 
            "title": "Booleans"
        }, 
        {
            "location": "/020-lexical_rules/#integers", 
            "text": "Integer values can be written in decimal and hexadecimal bases:   Decimals are written  as is .  Hexadecimals are prefixed with  0x .  TODO: \"0b---\", \"0o---\"   Examples:  // both are equal to the decimal 127\nv = 127;\nv = 0x7F;", 
            "title": "Integers"
        }, 
        {
            "location": "/020-lexical_rules/#floats", 
            "text": "TODO (like C)", 
            "title": "Floats"
        }, 
        {
            "location": "/020-lexical_rules/#null-pointer", 
            "text": "The  null  literal represents null  pointers .", 
            "title": "Null pointer"
        }, 
        {
            "location": "/020-lexical_rules/#strings", 
            "text": "A sequence of characters surrounded by  \"  is converted into a  null-terminated \nstring , just like in C:  Example:  _printf( Hello World!\\n );", 
            "title": "Strings"
        }, 
        {
            "location": "/020-lexical_rules/#comments", 
            "text": "C\u00e9u provides C-style comments.  Single-line comments begin with  //  and run to end of the line.  Multi-line comments use  /*  and  */  as delimiters.\nMulti-line comments can be nested by using a different number of  *  as\ndelimiters.  Examples:  var int a;    // this is a single-line comment\n\n/** comments a block that contains comments\n\nvar int a;\n/* this is a nested multi-line comment\na = 1;\n*/\n\n**/", 
            "title": "Comments"
        }, 
        {
            "location": "/030-types/", 
            "text": "Types\n\n\nC\u00e9u is statically typed, requiring all variables and events to be declared\nbefore they are used.\n\n\nA type is composed of a \ntype identifier\n, followed by a sequence\nof optional \npointer\n modifiers \n, and an optional \noption\n modifier \n?\n:\n\n\nType ::= ID_type {`\n\u00b4} [`?\u00b4]\n\n\n\n\nExamples:\n\n\nvar u8     v;   // \nv\n is of 8-bit unsigned integer type\nvar _rect  r;   // \nr\n is of external native type \nrect\n\nvar byte\n buf; // \nbuf\n is a pointer to a \nbyte\n\nvar Tree   t;   // \nt\n is a data of type \nTree\n\n\n\n\n\nPrimitive Types\n\n\nC\u00e9u has the following primitive types:\n\n\nvoid               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integer\ns16      u16       // signed and unsigned 16-bit integer\ns32      u32       // signed and unsigned 32-bit integer\ns64      u64       // signed and unsigned 64-bit integer\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types\n\n\n\n\nSee also the \nliterals\n for these types.\n\n\nNative Types\n\n\nTypes defined externally in C can be prefixed by \n_\n to be used in C\u00e9u programs.\n\n\nExample:\n\n\nvar _message_t msg;      // \nmessage_t\n is a C type defined in an external library\n\n\n\n\nNative types support [TODO-annotations] to provide additional information to\nthe compiler.\n\n\nAbstraction Types\n\n\nTODO (brief description)\n\n\nSee also \nAbstractions\n.\n\n\nType Modifiers\n\n\nTypes can be suffixed with the following modifiers: \n, \n?\n.\n\n\nPointer\n\n\nTODO (like C)\n\n\nTODO: restrictions\n    - cannot cross yielding statements\n\n\nOption\n\n\nTODO (like Maybe)", 
            "title": "Types"
        }, 
        {
            "location": "/030-types/#types", 
            "text": "C\u00e9u is statically typed, requiring all variables and events to be declared\nbefore they are used.  A type is composed of a  type identifier , followed by a sequence\nof optional  pointer  modifiers  , and an optional  option  modifier  ? :  Type ::= ID_type {` \u00b4} [`?\u00b4]  Examples:  var u8     v;   //  v  is of 8-bit unsigned integer type\nvar _rect  r;   //  r  is of external native type  rect \nvar byte  buf; //  buf  is a pointer to a  byte \nvar Tree   t;   //  t  is a data of type  Tree", 
            "title": "Types"
        }, 
        {
            "location": "/030-types/#primitive-types", 
            "text": "C\u00e9u has the following primitive types:  void               // void type\nbool               // boolean type\nbyte               // 1-byte type\nint      uint      // platform dependent signed and unsigned integer\ns8       u8        // signed and unsigned  8-bit integer\ns16      u16       // signed and unsigned 16-bit integer\ns32      u32       // signed and unsigned 32-bit integer\ns64      u64       // signed and unsigned 64-bit integer\nfloat              // platform dependent float\nf32      f64       // 32-bit and 64-bit floats\nssize    usize     // signed and unsigned size types  See also the  literals  for these types.", 
            "title": "Primitive Types"
        }, 
        {
            "location": "/030-types/#native-types", 
            "text": "Types defined externally in C can be prefixed by  _  to be used in C\u00e9u programs.  Example:  var _message_t msg;      //  message_t  is a C type defined in an external library  Native types support [TODO-annotations] to provide additional information to\nthe compiler.", 
            "title": "Native Types"
        }, 
        {
            "location": "/030-types/#abstraction-types", 
            "text": "TODO (brief description)  See also  Abstractions .", 
            "title": "Abstraction Types"
        }, 
        {
            "location": "/030-types/#type-modifiers", 
            "text": "Types can be suffixed with the following modifiers:  ,  ? .", 
            "title": "Type Modifiers"
        }, 
        {
            "location": "/030-types/#pointer", 
            "text": "TODO (like C)  TODO: restrictions\n    - cannot cross yielding statements", 
            "title": "Pointer"
        }, 
        {
            "location": "/030-types/#option", 
            "text": "TODO (like Maybe)", 
            "title": "Option"
        }, 
        {
            "location": "/040-storage_classes/", 
            "text": "Storage Classes\n\n\nStorage classes represent all entities that are stored in memory at runtime.\nC\u00e9u supports \nvariables\n, \nvectors\n, \nevents\n (external and internal), and\n\npools\n as storage classes.\nAn entity \ndeclaration\n consists of a storage class,\na \ntype\n, and an \nidentifier\n.\n\n\nExamples:\n\n\nvar       int    v;   // \nv\n is a variable of type \nint\n\nvector[9] byte   buf; // \nbuf\n is a vector with at most 9 values of type \nbyte\n\ninput     void\n A;   // \nA\n is an external event that carries values of type \nvoid\n\npool[]    Anim   ans; // \nans\n is a dynamic \npool\n for instances of type \nAnim\n\n\n\n\n\nA declaration binds the identifier with a memory location to hold values of the\nassociated type.\nEntities have lexical scope, i.e., they are visible only in the \nblock\n\nin which they are declared.\nThe lifetime of entities, (i.e., the period between allocation and deallocation\nin memory) is also limited to the scope of the enclosing block.\nHowever, individual elements inside \nvector\n and \npool\n entities have dynamic\nlifetime, but which never outlive the scope of the declaration.\n\n\nVariables\n\n\nAs in typical imperative languages, a variable in C\u00e9u holds a value of a\n\ndeclared\n \ntype\n that may vary during program execution.\nThe value of a variable can be read in \nexpressions\n or written in\n\nassignments\n.\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.\n\n\n\n\n\nNote: since blocks can contain parallel compositions, variables can be read\n       and written in trails in parallel.\n\n\nExample:\n\n\nvar int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)\n\n\n\n\nVectors\n\n\nIn C\u00e9u, a vector is a dynamic and contiguous collection of elements of the same\ntype.\nA vector \ndeclaration\n specifies its type and maximum size (possibly\nunlimited).\nThe current size of a vector is dynamic and can be accessed through the\n\noperator \n$\n.\nIndividual elements of a vector can be accessed through a\n\nnumeric index\n starting from \n0\n.\n\n\nExample:\n\n\nvector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)\n\n\n\n\nEvents\n\n\nEvents are the most fundamental concept of C\u00e9u, accounting for its reactive \nnature.\nPrograms manipulate events through the \nawait\n and \nemit\n \nstatements\n.\nAn \nawait\n halts the running trail until that event occurs.\nAn event occurrence is broadcast to all trails trails awaiting that event, \nawaking them to resume execution.\n\n\nC\u00e9u supports external and internal events.\nExternal events are triggered by the \nenvironment\n, while \ninternal events, by the \nemit\n statement.\nSee also [Synchronous execution model] for the differences between external and \ninternal reactions.\n\n\nUnlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through \nemit\n and \nawait\n statements.\nA \ndeclaration\n includes the type of value the occurring event carries.\n\n\nNote: \nvoid\n is a valid type for signal-only internal events.\n\n\nExamples:\n\n\nevent int e;   // \ne\n is an internal event that carries values of type \nint\n\npar do\n    var int v = await e; // awaits \ne\n assigning the received value to \nv\n\n    escape v;            // terminates the program (yields 10)\nwith\n    emit e(10);          // broadcasts \ne\n passing 10, awakes the \nawait\n above\nend\n\n\n\n\nExternal Events\n\n\nExternal events are used as interfaces between programs and devices from the \nreal world:\n\n\n\n\ninput\n events represent input devices, such as sensors, switches, etc.\n\n\noutput\n events represent output devices, such as LEDs, motors, etc.\n\n\n\n\nThe availability of external events depends on the platform in use.\nTherefore, external declarations only make pre-existing events visible to a \nprogram.\nRefer to \nEnvironment\n for information about interfacing with \nexternal events at the platform level.\n\n\nExternal Input Events\n\n\nAs a reactive language, programs in C\u00e9u have input events as entry points in\nthe code through \nawait statements\n.\n\n\n\n\n\nExternal Output Events\n\n\nInternal Events\n\n\n\n\n\nPools\n\n\nAliases\n\n\nExceptions", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/040-storage_classes/#storage-classes", 
            "text": "Storage classes represent all entities that are stored in memory at runtime.\nC\u00e9u supports  variables ,  vectors ,  events  (external and internal), and pools  as storage classes.\nAn entity  declaration  consists of a storage class,\na  type , and an  identifier .  Examples:  var       int    v;   //  v  is a variable of type  int \nvector[9] byte   buf; //  buf  is a vector with at most 9 values of type  byte \ninput     void  A;   //  A  is an external event that carries values of type  void \npool[]    Anim   ans; //  ans  is a dynamic  pool  for instances of type  Anim   A declaration binds the identifier with a memory location to hold values of the\nassociated type.\nEntities have lexical scope, i.e., they are visible only in the  block \nin which they are declared.\nThe lifetime of entities, (i.e., the period between allocation and deallocation\nin memory) is also limited to the scope of the enclosing block.\nHowever, individual elements inside  vector  and  pool  entities have dynamic\nlifetime, but which never outlive the scope of the declaration.", 
            "title": "Storage Classes"
        }, 
        {
            "location": "/040-storage_classes/#variables", 
            "text": "As in typical imperative languages, a variable in C\u00e9u holds a value of a declared   type  that may vary during program execution.\nThe value of a variable can be read in  expressions  or written in assignments .\nThe current value of a variable is preserved until the next assignment, during\nits whole lifetime.   Note: since blocks can contain parallel compositions, variables can be read\n       and written in trails in parallel.  Example:  var int v = _;  // empty initializaton\npar/and do\n    v = 1;      // write access\nwith\n    v = 2;      // write access\nend\nescape v;       // read access (yields 2)", 
            "title": "Variables"
        }, 
        {
            "location": "/040-storage_classes/#vectors", 
            "text": "In C\u00e9u, a vector is a dynamic and contiguous collection of elements of the same\ntype.\nA vector  declaration  specifies its type and maximum size (possibly\nunlimited).\nThe current size of a vector is dynamic and can be accessed through the operator  $ .\nIndividual elements of a vector can be accessed through a numeric index  starting from  0 .  Example:  vector[9] byte buf = [1,2,3];   // write access\nbuf[$buf+1] = 4;                // write access\nescape buf[1];                  // read access (yields 2)", 
            "title": "Vectors"
        }, 
        {
            "location": "/040-storage_classes/#events", 
            "text": "Events are the most fundamental concept of C\u00e9u, accounting for its reactive \nnature.\nPrograms manipulate events through the  await  and  emit   statements .\nAn  await  halts the running trail until that event occurs.\nAn event occurrence is broadcast to all trails trails awaiting that event, \nawaking them to resume execution.  C\u00e9u supports external and internal events.\nExternal events are triggered by the  environment , while \ninternal events, by the  emit  statement.\nSee also [Synchronous execution model] for the differences between external and \ninternal reactions.  Unlike all other storage classes, the value of an event is ephemeral and does\nnot persist after a reaction terminates.\nFor this reason, an event identifier is not a variable: values can only\nbe communicated through  emit  and  await  statements.\nA  declaration  includes the type of value the occurring event carries.  Note:  void  is a valid type for signal-only internal events.  Examples:  event int e;   //  e  is an internal event that carries values of type  int \npar do\n    var int v = await e; // awaits  e  assigning the received value to  v \n    escape v;            // terminates the program (yields 10)\nwith\n    emit e(10);          // broadcasts  e  passing 10, awakes the  await  above\nend", 
            "title": "Events"
        }, 
        {
            "location": "/040-storage_classes/#external-events", 
            "text": "External events are used as interfaces between programs and devices from the \nreal world:   input  events represent input devices, such as sensors, switches, etc.  output  events represent output devices, such as LEDs, motors, etc.   The availability of external events depends on the platform in use.\nTherefore, external declarations only make pre-existing events visible to a \nprogram.\nRefer to  Environment  for information about interfacing with \nexternal events at the platform level.", 
            "title": "External Events"
        }, 
        {
            "location": "/040-storage_classes/#external-input-events", 
            "text": "As a reactive language, programs in C\u00e9u have input events as entry points in\nthe code through  await statements .", 
            "title": "External Input Events"
        }, 
        {
            "location": "/040-storage_classes/#external-output-events", 
            "text": "", 
            "title": "External Output Events"
        }, 
        {
            "location": "/040-storage_classes/#internal-events", 
            "text": "", 
            "title": "Internal Events"
        }, 
        {
            "location": "/040-storage_classes/#pools", 
            "text": "", 
            "title": "Pools"
        }, 
        {
            "location": "/040-storage_classes/#aliases", 
            "text": "", 
            "title": "Aliases"
        }, 
        {
            "location": "/040-storage_classes/#exceptions", 
            "text": "", 
            "title": "Exceptions"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\n\nC\u00e9u is distributed under the MIT license reproduced below:\n\n\n Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the \nSoftware\n), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \nAS IS\n, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "C\u00e9u is distributed under the MIT license reproduced below:   Copyright (C) 2012-2016 Francisco Sant'Anna\n\n Permission is hereby granted, free of charge, to any person obtaining a copy of\n this software and associated documentation files (the  Software ), to deal in\n the Software without restriction, including without limitation the rights to\n use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n of the Software, and to permit persons to whom the Software is furnished to do\n so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED  AS IS , WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.", 
            "title": "License"
        }
    ]
}